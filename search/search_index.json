{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Documents: http://bioinf.shenwei.me/seqkit ( Usage , FAQ , Tutorial , and Benchmark ) Source code: https://github.com/shenwei356/seqkit Latest version: Please cite : Others : Features Easy to install ( download ) Providing statically linked executable binaries for multiple platforms (Linux/Windows/macOS, amd64/arm64) Light weight and out-of-the-box, no dependencies, no compilation, no configuration conda install -c bioconda seqkit Easy to use Ultrafast (see technical-details and benchmark ) Seamlessly parsing both FASTA and FASTQ formats Supporting ( gzip / xz / zstd / bzip2 compressed) STDIN/STDOUT and input/output file, easily integrated in pipe Reproducible results (configurable rand seed in sample and shuffle ) Supporting custom sequence ID via regular expression Supporting Bash/Zsh autocompletion Versatile commands ( usages and examples ) Practical functions supported by 37 subcommands Installation Go to Download Page for more download options and changelogs, or install via conda: conda install -c bioconda seqkit Subcommands category command function input strand-sensitivity multi-threads popularity basic seq transform sequences: extract ID/seq, filter by length/quality, remove gaps, reverse complement\u2026 FASTA/Q \u2605\u2605\u2605\u2605\u2605 stats simple statistics: #seqs, min/max_len, N50, Q20%, Q30%\u2026 FASTA/Q \u2713 \u2605\u2605\u2605\u2605\u2605 sum compute message digest for all sequences in FASTA/Q files FASTA/Q + or both \u2713 subseq extract subsequences or flanking sequences by region/gtf/bed, FASTA/Q + or/and - \u2605\u2605\u2605 sliding extract subsequences in sliding windows FASTA/Q + only \u2605\u2605 faidx create FASTA index file and extract subsequence (with more features than samtools faidx) FASTA + or/and - watch monitoring and online histograms of sequence features FASTA/Q sana sanitize broken single line FASTQ files FASTQ scat real time concatenation and streaming of fastx files FASTA/Q \u2713 format conversion fq2fa convert FASTQ to FASTA FASTQ \u2605\u2605 fa2fq retrieve corresponding FASTQ records by a FASTA file FASTA/Q fx2tab convert FASTA/Q to tabular format FASTA/Q \u2605\u2605 tab2fx convert tabular format to FASTA/Q format FASTA/Q convert convert FASTQ quality encoding between Sanger, Solexa and Illumina FASTA/Q translate translate DNA/RNA to protein sequence FASTA/Q + or/and - \u2605\u2605 searching grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed FASTA/Q + and - partly, -m \u2605\u2605\u2605\u2605\u2605 locate locate subsequences/motifs, mismatch allowed FASTA/Q + and - partly, -m \u2605\u2605\u2605\u2605\u2605 amplicon extract amplicon (or specific region around it), mismatch allowed FASTA/Q + and - partly, -m \u2605 fish look for short sequences in larger sequences FASTA/Q + and - set operation sample sample sequences by number or proportion FASTA/Q \u2605\u2605\u2605\u2605 rmdup remove duplicated sequences by ID/name/sequence FASTA/Q + and - \u2605\u2605\u2605 common find common sequences of multiple files by id/name/sequence FASTA/Q + and - duplicate duplicate sequences N times FASTA/Q \u2605 split split sequences into files by id/seq region/size/parts (mainly for FASTA) FASTA preffered \u2605 split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) FASTA/Q \u2605\u2605 head print first N FASTA/Q records FASTA/Q head-genome print sequences of the first genome with common prefixes in name FASTA/Q range print FASTA/Q records in a range (start:end) FASTA/Q pair match up paired-end reads from two fastq files FASTA/Q edit concat concatenate sequences with same the ID from multiple files FASTA/Q + only \u2605\u2605\u2605 replace replace name/sequence by regular expression FASTA/Q + only \u2605\u2605 restart reset start position for circular genome FASTA/Q + only \u2605 mutate edit sequence (point mutation, insertion, deletion) FASTA/Q + only rename rename duplicated IDs FASTA/Q \u2605 ordering sort sort sequences by id/name/sequence/length FASTA preffered \u2605\u2605 shuffle shuffle sequences FASTA preffered BAM processing bam monitoring and online histograms of BAM record features BAM Notes: Strand-sensitivity: + only : only processing on the positive/forward strand. + and - : searching on both strands. + or/and - : depends on users' flags/options/arguments. Multiple-threads: Using the default 4 threads is fast enough for most commands, some commands can benefit from extra threads. Popularity: Bases on statistics of 227 publications citing seqkit since 2020. Citation W Shen , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE . doi:10.1371/journal.pone.0163962 . Contributors Wei Shen Botond Sipos : bam , scat , fish , sana , watch . others Acknowledgements We thank Lei Zhang for testing SeqKit, and also thank Jim Hester , author of fasta_utilities , for advice on early performance improvements of for FASTA parsing and Brian Bushnell , author of BBMaps , for advice on naming SeqKit and adding accuracy evaluation in benchmarks. We also thank Nicholas C. Wu from the Scripps Research Institute, USA for commenting on the manuscript and Guangchuang Yu from State Key Laboratory of Emerging Infectious Diseases, The University of Hong Kong, HK for advice on the manuscript. We thank Li Peng for reporting many bugs. We appreciate Klaus Post for his fantastic packages ( compress and pgzip ) which accelerate gzip file reading and writing. Contact Create an issue to report bugs, propose new functions or ask for help. License MIT License Starchart","title":"Home"},{"location":"#seqkit-a-cross-platform-and-ultrafast-toolkit-for-fastaq-file-manipulation","text":"Documents: http://bioinf.shenwei.me/seqkit ( Usage , FAQ , Tutorial , and Benchmark ) Source code: https://github.com/shenwei356/seqkit Latest version: Please cite : Others :","title":"SeqKit - a cross-platform and ultrafast toolkit for FASTA/Q file manipulation"},{"location":"#features","text":"Easy to install ( download ) Providing statically linked executable binaries for multiple platforms (Linux/Windows/macOS, amd64/arm64) Light weight and out-of-the-box, no dependencies, no compilation, no configuration conda install -c bioconda seqkit Easy to use Ultrafast (see technical-details and benchmark ) Seamlessly parsing both FASTA and FASTQ formats Supporting ( gzip / xz / zstd / bzip2 compressed) STDIN/STDOUT and input/output file, easily integrated in pipe Reproducible results (configurable rand seed in sample and shuffle ) Supporting custom sequence ID via regular expression Supporting Bash/Zsh autocompletion Versatile commands ( usages and examples ) Practical functions supported by 37 subcommands","title":"Features"},{"location":"#installation","text":"Go to Download Page for more download options and changelogs, or install via conda: conda install -c bioconda seqkit","title":"Installation"},{"location":"#subcommands","text":"category command function input strand-sensitivity multi-threads popularity basic seq transform sequences: extract ID/seq, filter by length/quality, remove gaps, reverse complement\u2026 FASTA/Q \u2605\u2605\u2605\u2605\u2605 stats simple statistics: #seqs, min/max_len, N50, Q20%, Q30%\u2026 FASTA/Q \u2713 \u2605\u2605\u2605\u2605\u2605 sum compute message digest for all sequences in FASTA/Q files FASTA/Q + or both \u2713 subseq extract subsequences or flanking sequences by region/gtf/bed, FASTA/Q + or/and - \u2605\u2605\u2605 sliding extract subsequences in sliding windows FASTA/Q + only \u2605\u2605 faidx create FASTA index file and extract subsequence (with more features than samtools faidx) FASTA + or/and - watch monitoring and online histograms of sequence features FASTA/Q sana sanitize broken single line FASTQ files FASTQ scat real time concatenation and streaming of fastx files FASTA/Q \u2713 format conversion fq2fa convert FASTQ to FASTA FASTQ \u2605\u2605 fa2fq retrieve corresponding FASTQ records by a FASTA file FASTA/Q fx2tab convert FASTA/Q to tabular format FASTA/Q \u2605\u2605 tab2fx convert tabular format to FASTA/Q format FASTA/Q convert convert FASTQ quality encoding between Sanger, Solexa and Illumina FASTA/Q translate translate DNA/RNA to protein sequence FASTA/Q + or/and - \u2605\u2605 searching grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed FASTA/Q + and - partly, -m \u2605\u2605\u2605\u2605\u2605 locate locate subsequences/motifs, mismatch allowed FASTA/Q + and - partly, -m \u2605\u2605\u2605\u2605\u2605 amplicon extract amplicon (or specific region around it), mismatch allowed FASTA/Q + and - partly, -m \u2605 fish look for short sequences in larger sequences FASTA/Q + and - set operation sample sample sequences by number or proportion FASTA/Q \u2605\u2605\u2605\u2605 rmdup remove duplicated sequences by ID/name/sequence FASTA/Q + and - \u2605\u2605\u2605 common find common sequences of multiple files by id/name/sequence FASTA/Q + and - duplicate duplicate sequences N times FASTA/Q \u2605 split split sequences into files by id/seq region/size/parts (mainly for FASTA) FASTA preffered \u2605 split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) FASTA/Q \u2605\u2605 head print first N FASTA/Q records FASTA/Q head-genome print sequences of the first genome with common prefixes in name FASTA/Q range print FASTA/Q records in a range (start:end) FASTA/Q pair match up paired-end reads from two fastq files FASTA/Q edit concat concatenate sequences with same the ID from multiple files FASTA/Q + only \u2605\u2605\u2605 replace replace name/sequence by regular expression FASTA/Q + only \u2605\u2605 restart reset start position for circular genome FASTA/Q + only \u2605 mutate edit sequence (point mutation, insertion, deletion) FASTA/Q + only rename rename duplicated IDs FASTA/Q \u2605 ordering sort sort sequences by id/name/sequence/length FASTA preffered \u2605\u2605 shuffle shuffle sequences FASTA preffered BAM processing bam monitoring and online histograms of BAM record features BAM Notes: Strand-sensitivity: + only : only processing on the positive/forward strand. + and - : searching on both strands. + or/and - : depends on users' flags/options/arguments. Multiple-threads: Using the default 4 threads is fast enough for most commands, some commands can benefit from extra threads. Popularity: Bases on statistics of 227 publications citing seqkit since 2020.","title":"Subcommands"},{"location":"#citation","text":"W Shen , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE . doi:10.1371/journal.pone.0163962 .","title":"Citation"},{"location":"#contributors","text":"Wei Shen Botond Sipos : bam , scat , fish , sana , watch . others","title":"Contributors"},{"location":"#acknowledgements","text":"We thank Lei Zhang for testing SeqKit, and also thank Jim Hester , author of fasta_utilities , for advice on early performance improvements of for FASTA parsing and Brian Bushnell , author of BBMaps , for advice on naming SeqKit and adding accuracy evaluation in benchmarks. We also thank Nicholas C. Wu from the Scripps Research Institute, USA for commenting on the manuscript and Guangchuang Yu from State Key Laboratory of Emerging Infectious Diseases, The University of Hong Kong, HK for advice on the manuscript. We thank Li Peng for reporting many bugs. We appreciate Klaus Post for his fantastic packages ( compress and pgzip ) which accelerate gzip file reading and writing.","title":"Acknowledgements"},{"location":"#contact","text":"Create an issue to report bugs, propose new functions or ask for help.","title":"Contact"},{"location":"#license","text":"MIT License","title":"License"},{"location":"#starchart","text":"","title":"Starchart"},{"location":"benchmark/","text":"Benchmark Note: these benchmarks was performed in 2016 . Softwares seqkit . (Go). Version v0.3.1.1 . Compiled with Go 1.7rc5. fasta_utilities . (Perl). Version 3dcc0bc . Lots of dependencies to install. fastx_toolkit . (Perl). Version 0.0.13 . Can't handle multi-line FASTA files. seqmagick . (Python). Version 0.6.1 seqtk . (C). Version 1.1-r92-dirty . Not used: pyfaidx . (Python). Version 0.4.7.1 . Not used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp. A Python script memusg was used to compute running time and peak memory usage of a process. Features Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats supports Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation -- Yes Yes Yes Yes -- Filtering by size Indirect Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 2 : See usage for detailed options of seqkit. Datasets All test data is available here: seqkit-benchmark-data.tar.gz (2.2G) dataset_A.fa - large number of short sequences Dataset A is reference genomes DNA sequences of gastrointestinal tract from NIH Human Microbiome Project : Gastrointestinal_tract.nuc.fsa (FASTA format, ~2.7G). dataset_B.fa - small number of large sequences Dataset B is Human genome from ensembl . Genome DNA: Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz (Gzipped FASTA file, ~900M) . Decompress it and rename to dataset_B.fa (~2.9G). GTF file: Homo_sapiens.GRCh38.84.gtf.gz (~44M) BED file: Homo_sapiens.GRCh38.84.bed.gz was converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command $ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c > Homo_sapiens.GRCh38.84.bed.gz dataset_C.fq \u2013 Illumina single end reads (SE100) Dataset C is Illumina single end (SE 100bp) reads file (~2.2G). Summary $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100 Sequence ID list Parts of sequences IDs was sampled and shuffled from original data. They were used in test of extracting sequences by ID list. Commands: $ seqkit sample -p 0.3 dataset_A.fa | seqkit seq --name --only-id | shuf > ids_A.txt $ seqkit sample -p 0.3 dataset_B.fa | seqkit seq --name --only-id | shuf > ids_B.txt $ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf > ids_C.txt Numbers: $ wc -l ids*.txt 20138 ids_A.txt 58 ids_B.txt 2754516 ids_C.txt BED file Only BED data of chromosome 19 was used in test of subsequence with BED file: $ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c > chr19.bed.gz Platform PC: CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads RAM: DDR3 1600MHz, 12GB SSD: SAMSUNG 850 EVO 250G, SATA-3 OS: Fedora 24 (Scientific KDE spin), Kernal: 4.6.4-301.fc24.x86_64 Softwares: Perl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi Python: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2 Tests Automatic benchmark and plotting scripts are available at: https://github.com/shenwei356/seqkit/tree/master/benchmark . All tests were repeated 3 times, and average time and peak memory ware used for plotting. All data were readed once before tests began to minimize the influence of page cache. Output sequences of all softwares were not wrapped to fixed length. Test 1. Reverse Complement revcom_biogo ( source , binary ), a tool written in Golang (compiled with Go 1.6.3) using biogo (Version 7ebd71b ) package, was also used for comparison of FASTA file parsing performance. Note that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others. Commands Test 2. Extracting sequences by ID list Commands Test 3. Sampling by number Note that different softwares have different sampling strategies, the peak memory depends on size of sampled sequences and the results may not be the same. Commands Test 4. Removing duplicates by sequence content Commands Test 5. Subsequence with BED file Commands Results seqkit version: v0.3.1.1 FASTA: FASTQ: Test of multiple threads: From the results, 2 threads/CPU is enough, so the default threads of seqkit is 2. Tests on different file sizes Files are generated by replicating Human genome chr1 for N times. /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Benchmark"},{"location":"benchmark/#benchmark","text":"Note: these benchmarks was performed in 2016 .","title":"Benchmark"},{"location":"benchmark/#softwares","text":"seqkit . (Go). Version v0.3.1.1 . Compiled with Go 1.7rc5. fasta_utilities . (Perl). Version 3dcc0bc . Lots of dependencies to install. fastx_toolkit . (Perl). Version 0.0.13 . Can't handle multi-line FASTA files. seqmagick . (Python). Version 0.6.1 seqtk . (C). Version 1.1-r92-dirty . Not used: pyfaidx . (Python). Version 0.4.7.1 . Not used, because it exhausted my memory (10G) when computing reverse-complement on a 5GB fasta file of 250 bp. A Python script memusg was used to compute running time and peak memory usage of a process.","title":"Softwares"},{"location":"benchmark/#features","text":"Categories Features seqkit fasta_utilities fastx_toolkit pyfaidx seqmagick seqtk Formats supports Multi-line FASTA Yes Yes -- Yes Yes Yes FASTQ Yes Yes Yes -- Yes Yes Multi-line FASTQ Yes Yes -- -- Yes Yes Validating sequences Yes -- Yes Yes -- -- Supporting RNA Yes Yes -- -- Yes Yes Functions Searching by motifs Yes Yes -- -- Yes -- Sampling Yes -- -- -- Yes Yes Extracting sub-sequence Yes Yes -- Yes Yes Yes Removing duplicates Yes -- -- -- Partly -- Splitting Yes Yes -- Partly -- -- Splitting by seq Yes -- Yes Yes -- -- Shuffling Yes -- -- -- -- -- Sorting Yes Yes -- -- Yes -- Locating motifs Yes -- -- -- -- -- Common sequences Yes -- -- -- -- -- Cleaning bases Yes Yes Yes Yes -- -- Transcription Yes Yes Yes Yes Yes Yes Translation -- Yes Yes Yes Yes -- Filtering by size Indirect Yes -- Yes Yes -- Renaming header Yes Yes -- -- Yes Yes Other features Cross-platform Yes Partly Partly Yes Yes Yes Reading STDIN Yes Yes Yes -- Yes Yes Reading gzipped file Yes Yes -- -- Yes Yes Writing gzip file Yes -- -- -- Yes -- Note 2 : See usage for detailed options of seqkit.","title":"Features"},{"location":"benchmark/#datasets","text":"All test data is available here: seqkit-benchmark-data.tar.gz (2.2G)","title":"Datasets"},{"location":"benchmark/#dataset_afa-large-number-of-short-sequences","text":"Dataset A is reference genomes DNA sequences of gastrointestinal tract from NIH Human Microbiome Project : Gastrointestinal_tract.nuc.fsa (FASTA format, ~2.7G).","title":"dataset_A.fa - large number of short sequences"},{"location":"benchmark/#dataset_bfa-small-number-of-large-sequences","text":"Dataset B is Human genome from ensembl . Genome DNA: Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz (Gzipped FASTA file, ~900M) . Decompress it and rename to dataset_B.fa (~2.9G). GTF file: Homo_sapiens.GRCh38.84.gtf.gz (~44M) BED file: Homo_sapiens.GRCh38.84.bed.gz was converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command $ zcat Homo_sapiens.GRCh38.84.gtf.gz | gtf2bed --do-not-sort | gzip -c > Homo_sapiens.GRCh38.84.bed.gz","title":"dataset_B.fa - small number of large sequences"},{"location":"benchmark/#dataset_cfq-illumina-single-end-reads-se100","text":"Dataset C is Illumina single end (SE 100bp) reads file (~2.2G). Summary $ seqkit stat *.fa file format type num_seqs sum_len min_len avg_len max_len dataset_A.fa FASTA DNA 67,748 2,807,643,808 56 41,442.5 5,976,145 dataset_B.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 dataset_C.fq FASTQ DNA 9,186,045 918,604,500 100 100 100","title":"dataset_C.fq \u2013 Illumina single end reads (SE100)"},{"location":"benchmark/#sequence-id-list","text":"Parts of sequences IDs was sampled and shuffled from original data. They were used in test of extracting sequences by ID list. Commands: $ seqkit sample -p 0.3 dataset_A.fa | seqkit seq --name --only-id | shuf > ids_A.txt $ seqkit sample -p 0.3 dataset_B.fa | seqkit seq --name --only-id | shuf > ids_B.txt $ seqkit sample -p 0.03 dataset_C.fq | seqkit seq --name --only-id | shuf > ids_C.txt Numbers: $ wc -l ids*.txt 20138 ids_A.txt 58 ids_B.txt 2754516 ids_C.txt","title":"Sequence ID list"},{"location":"benchmark/#bed-file","text":"Only BED data of chromosome 19 was used in test of subsequence with BED file: $ zcat Homo_sapiens.GRCh38.84.bed.gz | grep -E \"^19\" | gzip -c > chr19.bed.gz","title":"BED file"},{"location":"benchmark/#platform","text":"PC: CPU: Intel Core i5-3320M @ 2.60GHz, two cores/4 threads RAM: DDR3 1600MHz, 12GB SSD: SAMSUNG 850 EVO 250G, SATA-3 OS: Fedora 24 (Scientific KDE spin), Kernal: 4.6.4-301.fc24.x86_64 Softwares: Perl: perl 5, version 22, subversion 2 (v5.22.2) built for x86_64-linux-thread-multi Python: Python 2.7.11 (default, Jul 10 2016, 20:58:20) [GCC 6.1.1 20160621 (Red Hat 6.1.1-3)] on linux2","title":"Platform"},{"location":"benchmark/#tests","text":"Automatic benchmark and plotting scripts are available at: https://github.com/shenwei356/seqkit/tree/master/benchmark . All tests were repeated 3 times, and average time and peak memory ware used for plotting. All data were readed once before tests began to minimize the influence of page cache. Output sequences of all softwares were not wrapped to fixed length.","title":"Tests"},{"location":"benchmark/#test-1-reverse-complement","text":"revcom_biogo ( source , binary ), a tool written in Golang (compiled with Go 1.6.3) using biogo (Version 7ebd71b ) package, was also used for comparison of FASTA file parsing performance. Note that some softwares (fasta_utilities and biogo) have different converting rules of computing complement sequence on ambiguous bases, there fore the results are different from others. Commands","title":"Test 1. Reverse Complement"},{"location":"benchmark/#test-2-extracting-sequences-by-id-list","text":"Commands","title":"Test 2. Extracting sequences by ID list"},{"location":"benchmark/#test-3-sampling-by-number","text":"Note that different softwares have different sampling strategies, the peak memory depends on size of sampled sequences and the results may not be the same. Commands","title":"Test 3. Sampling by number"},{"location":"benchmark/#test-4-removing-duplicates-by-sequence-content","text":"Commands","title":"Test 4. Removing duplicates by sequence content"},{"location":"benchmark/#test-5-subsequence-with-bed-file","text":"Commands","title":"Test 5. Subsequence with BED file"},{"location":"benchmark/#results","text":"seqkit version: v0.3.1.1 FASTA: FASTQ:","title":"Results"},{"location":"benchmark/#test-of-multiple-threads","text":"From the results, 2 threads/CPU is enough, so the default threads of seqkit is 2.","title":"Test of multiple threads:"},{"location":"benchmark/#tests-on-different-file-sizes","text":"Files are generated by replicating Human genome chr1 for N times. /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Tests on different file sizes"},{"location":"bioinf/","text":"","title":"Bioinf"},{"location":"download/","text":"Download SeqKit is implemented in Go programming language, statically-linked executable binary files are freely available . Please cite: W Shen , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE . doi:10.1371/journal.pone.0163962 . Current Version SeqKit v2.4.0 - 2023-03-17 seqkit : support bzip2 format . #361 support setting compression level for gzip , zstd , and bzip2 format via --compress-level . #320 the global flag --infile-list accepts stdin ( - ) now. wrap the help message of flags. seqkit locate : do not remove embeded regions when searching with regular expressions . #368 seqkit amplicon : fix BED coordinates for amplicons found in the minus strand. #367 seqkit split : fix forgetting to add extension for --two-pass . #332 seqkit stats : fix compute Q1 and Q3 of sequence length for one record. #353 seqkit grep : fix count number ( -C ) for matching with mismatch ( -m > 0 ). #370 seqkit replace : add some flags to match partly records to edit ; these flags are transplanted from seqkit grep . #348 seqkit faidx : allow empty lines at the end of sequences . seqkit faidx/sort/shuffle/split/subseq : new flag -U/--update-faidx : update the FASTA index file if it exists, to guarantee the index file matches the FASTA files . #364 improve log info and update help message. #365 seqkit seq : allow filtering sequences of length zero. thanks to @penglbio. seqkit rename : new flag -s/--separator for setting separator between original ID/name and the counter (default \"_\"). #360 new flag -N/--start-num for setting starting count number for duplicated IDs/names (default 2). #360 new flag -1/--rename-1st-rec for renaming the first record as well. #360 do not append space if there's no description after the sequene ID. seqkit sliding : new flag -S/--suffix for change the suffix added to the sequence ID (default: \"_sliding\"). Links OS Arch File, \u4e2d\u56fd\u955c\u50cf Download Count Linux 32-bit seqkit_linux_386.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux 64-bit seqkit_linux_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux arm64 seqkit_linux_arm64.tar.gz , \u4e2d\u56fd\u955c\u50cf macOS 64-bit seqkit_darwin_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf macOS arm64 seqkit_darwin_arm64.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 32-bit seqkit_windows_386.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 64-bit seqkit_windows_amd64.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Notes please open an issuse to request binaries for other platforms. run seqkit version to check update !!! run seqkit genautocomplete to update shell autocompletion script !!! Installation Method 1: Download binaries (latest stable version) Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 . Method 2: Install via conda (latest stable version) conda install -c bioconda seqkit Method 3: Install via homebrew (latest stable version) brew install seqkit Method 4: For Go developer (latest stable/dev version) go get -u github.com/shenwei356/seqkit/v2/seqkit/ Method 5: Docker based installation (latest stable/dev version) Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest Method 6: Compiling from source (latest stable/dev version) # ------------------- install golang ----------------- # download Go from https://go.dev/dl wget https://go.dev/dl/go1.17.13.linux-amd64.tar.gz tar -zxf go1.17.13.linux-amd64.tar.gz -C $HOME/ # or # echo \"export PATH=$PATH:$HOME/go/bin\" >> ~/.bashrc # source ~/.bashrc export PATH=$PATH:$HOME/go/bin # ------------- the latest stable version ------------- go get -v -u github.com/shenwei356/seqkit/seqkit # The executable binary file is located in: # ~/go/bin/seqkit # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ~/go/bin/seqkit $HOME/bin/ # --------------- the devlopment version -------------- git clone https://github.com/shenwei356/seqkit cd seqkit/seqkit/ go build # The executable binary file is located in: # ./seqkit # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ./seqkit $HOME/bin/ Shell-completion Supported shell: bash|zsh|fish|powershell Bash: # generate completion shell seqkit genautocomplete --shell bash # configure if never did. # install bash-completion if the \"complete\" command is not found. echo \"for bcfile in ~/.bash_completion.d/* ; do source \\$bcfile; done\" >> ~/.bash_completion echo \"source ~/.bash_completion\" >> ~/.bashrc Zsh: # generate completion shell seqkit genautocomplete --shell zsh --file ~/.zfunc/_seqkit # configure if never did echo 'fpath=( ~/.zfunc \"${fpath[@]}\" )' >> ~/.zshrc echo \"autoload -U compinit; compinit\" >> ~/.zshrc fish: seqkit genautocomplete --shell fish --file ~/.config/fish/completions/seqkit.fish Release history SeqKit v2.3.1 - 2022-09-22 seqkit grep/locate : fix bug of FMIndex building for empty sequences. #321 seqkit split2 : fix bug of splitting two FASTA files. #325 seqkit faidx : --id-regexp works now. SeqKit v2.3.0 - 2022-08-12 seqkit grep/rename : reduce memory comsumption for a lot of searching patterns, and it's faster . #305 2X faster -s/--by-seq . seqkit split fix outputting an empty file when the number of sequence equal to the split size. #293 add options to set output file prefix and extention. #296 seqkit split2 reduce memory consumption. #304 add options to set output file prefix seqkit stats : add GC content. #294 SeqKit v2.2.0 - 2020-03-14 seqkit : add support of xz and zstd input/output formats . #274 fix panic when reading records with header of ID + blanks. new command seqkit sum : computing message digest for all sequences in FASTA/Q files . The idea comes from @photocyte and the format borrows from seqhash #262 new command seqkit fa2fq : retrieving corresponding FASTQ records by a FASTA file seqkit split2 : new flag -e/--extension for forcing compresson or changing compression format. #276 support changing output prefix via -o/--out-file . #275 seqkit concat : fix handling of multiple seqs with the same ID in one file. #269 performaning out/full join. #270 preserve the comments. #271 seqkit locate : parallelizing -F/--use-fmi and -m for large number of search patterns. seqkit amplicon : new flag -M/--output-mismatches to append the total mismatches and mismatches of 5' end and 3' end. #286 seqkit grep : detect FASTA/Q symbol @ and > in the searching patterns and show warnings. add new flag -C/--count , like grep -c in GNU grep. #267 seqkit range : support removing leading 100 seqs ( seqkit range -r 101:-1 == tail -n +101 ). #279 seqkit subseq : report error when no options were given. update doc: seqkit head : add doc for \"seqkit tail\": seqkit range -N:-1 seqs.fasta . #272 seqkit rmdup : add the note of only the first record being saved for duplicates. #265 SeqKit v2.1.0 - 2021-11-15 seqkit seq : fix filtering by average quality -Q/-R . #257 seqkit convert : fix quality encoding checking, change default value of -N/--thresh-B-in-n-most-common from 4 to 2 . #254 and #239 seqkit split : fix writing an extra empty file when using --two-pass #244 seqkit subseq : fix --bed which fail to recognize strand . . seqkit fq2fa : faster, and do not wrap sequences. seqkit grep/locate/mutate : detect unquoted comma and show warning message, e.g., -p 'A{2,}' . #250 SeqKit v2.0.0 - 2021-08-27 Performance improvements seqkit : faster FASTA/Q reading and writing, especially on FASTQ , see the benchmark . reading (plain text): 4X faster. seqkit stats dataset_C.fq reading (gzip files): 45% faster. seqkit stats dataset_C.fq.gz reading + writing (plain text): 3.5X faster. seqkit grep -p . -v dataset_C.fq -o t reading + writing (gzip files): 2.2X faster. seqkit grep -p . -v dataset_C.fq.gz -o t.gz change default value of -j/--threads from 2 to 4 , which is faster for writting gzip files. seqkit seq : fix writing speed, which was slowed down in v0.12.1 . Breaking changes seqkit grep/rmdup/common : consider reverse complement sequence by default for comparing by sequence , add flag -P/--only-positive-strand . #215 seqkit rename : rename ID only, do not append original header to new ID . #236 seqkit fx2tab : for -s/--seq-hash : outputing MD5 instead of hash value (integers) of xxhash. #219 Bugfixes seqkit seq : fix failing to output gzipped format for file name with extension of .gz since v0.12.1 . seqkit tab2fx : fix bug for very long sequences. #214 seqkit fish : fix range check. #213 seqkit grep : it's not exactly a bug: forgot to use multi-threads for -m > 0. New features/enhancements seqkit grep : allow empty pattern files. seqkit faidx : support region with begin > end , i.e., returning reverse complement sequence add new flag -l/--region-file : file containing a list of regions. seqkit fx2tab : new flag -Q/--no-qual for disabling outputing quality even for FASTQ file. #221 seqkit amplicon : new flag -u/--save-unmatched for saving records that do not match any primer. seqkit sort : new flag -b/--by-bases for sorting by non-gap bases, for multiple sequence alignment files. #216 SeqKit v0.16.1 - 2021-05-20 seqkit shuffle --two-pass : fix bug introduced in #173 . #209 seqkit pair : fix a dangerous bug: when input files are not in current directory, input files were overwritten. SeqKit v0.16.0 - 2021-04-16 new command seqkit head-genome : print sequences of the first genome with common prefixes in name seqkit grep/locate/amplicon -m much faster (300-400x) searching with mismatch allowed by optimizing FM-indexing and parallelization. new flag -I/--immediate-output . seqkit grep/locate : fix bug of -m when querying contains letters not in alphabet, usually for protein sequences. #178 , #179 onply search on positive strand when searching unlimited or protein sequences. seqkit locate : removing debug info for -r introduced in a0f6b6e. #180 seqkit amplicon : fix bug of -m , when mismatch is allowed. seqkit fx2tab : new flag -C/--base-count for counting bases. #183 seqkit tab2fx : fix a rare bug. #197 seqkit subseq : fix bug for BED with empty columns. #195 seqkit genautocomplete : support bash|zsh|fish|powershell . SeqKit v0.15.0 - 2021-01-12 seqkit grep/locate : update help message. seqkit grep : search on both strand when searching by sequence . seqkit split2 : fix redundant log when using -s . seqkit bam : new field RightSoftClipSeq . #172 seqkit sample -2 : remove extra \\n . #173 seqkit split2 -l : fix bug for splitting by accumulative length, this bug occurs when the first record is longer than -l , no sequences are lost. SeqKit v0.14.0 - 2020-10-30 new command seqkit pair : match up paired-end reads from two fastq files, faster than fastq-pair. seqkit translate : new flag -F/--append-fram for optional adding frame info to ID. #159 seqkit stats : reduce memory usage when using -a for calculating N50. #153 seqkit mutate : fix inserting sequence -i/--insertion , this bug occurs when insert site is big in some cases, don't worry if no error reported. seqkit replace : new flag -U/--keep-untouched : do not change anything when no value found for the key (only for sequence name). do no support editing FASTQ sequence. seqkit grep/locate : new flag --circular for supporting circular genome. #158 SeqKit v0.13.2 - 2020-07-13 seqkit sana : fix bug causing hanging on empty files. #149 SeqKit v0.13.1 - 2020-07-09 seqkit sana : fix bug causing hanging on empty files. #148 SeqKit v0.13.0 - 2020-07-07 seqkit : fix a rare FASTA/Q parser bug. #127 seqkit seq : output sequence or quality in single line when -s/--seq or -q/--qual is on. #132 seqkit translate : delete debug info, #133 , and fix typo. #134 seqkit split2 : tiny performance improvement. #137 seqkit stats : new flag -i/--stdin-label for replacing default \"-\" for stdin. #139 seqkit fx2tab : new flag -s/--seq-hash for printing hash of sequence (case sensitive). #144 seqkit amplicon : fix bug of missing searching reverse strand. #140 supporting degenerate bases now. #83 new flag -p/--primer-file for reading list of primer pairs. #142 new flag --bed for outputing in BED6+1 format. #141 New features and improvements by @bsipos . #130 , #147 new command seqkit scat , for real-time robust concatenation of fastx files. Rewrote the parser behind the sana subcommand, now it supports robust parsing of fasta file as well. Added a \"toolbox\" feature to the bam subcommand ( -T ), which is a collection of filters acting on streams of BAM records configured through a YAML string (see the docs for more). Added the SEQKIT_THREADS environmental variable to override the default number of threads. SeqKit v0.12.1 - 2020-04-21 seqkit bam : add colorised and pretty printed output, by @bsipos . #110 seqkit locate/grep : fix bug of -m , when query contains letters not in subject sequences. #124 seqkit split2 : new flag -l/--by-length for splitting into chunks of N bases. seqkit fx2tab : new flag -I/--case-sensitive for calculating case sensitive base content. #108 add missing column name for averge quality for -H -q . #115 fix output of -n/--only-name , do not write empty columns of sequence and quality. #104 , #115 seqkit seq : new flag -k/--color : colorize sequences. SeqKit v0.12.0 - 2020-02-18 seqkit : fix checking input file existence. new global flag --infile-list for long list of input files, if given, they are appended to files from cli arguments. seqkit faidx : supporting \"truncated\" (no ending newline charactor) file. seqkit seq : do not force switching on -g when using -m/-M . show recommendation if flag -t/--seq-type is not DNA/RNA when computing complement sequence. #103 seqkit translate : supporting multiple frames. #96 seqkit grep/locate : add detection and warning for space existing in search pattern/sequence. speed improvement (2X) for -m/--max-mismatch . shenwei356/bwt/issues/3 seqkit locate : new flag -M/--hide-matched for hiding matched sequences. #98 new flag -r/--use-regexp for explicitly using regular expression, so improve speed of default index operation. And you have to switch this on if using regexp now . #101 new flag -F/--use-fmi for improving search speed for lots of sequence patterns . seqkit rename : making IDs unique across multiple files, and can write into multiple files. #100 seqkit sample : fix stdin checking for flag -2 . #102 . seqkit rename/split/split2 : fix detection of existed outdir. split split : fix bug of seqkit split -i -2 and parallizing it. seqkit version : checking update is optional ( -u ). SeqKit v0.11.0 - 2019-09-25 seqkit : fix hanging when reading from truncated gzip file. new commands: seqkit amplicon : retrieve amplicon (or specific region around it) via primer(s). new commands by @bsipos : seqkit watch : monitoring and online histograms of sequence features. seqkit sana : sanitize broken single line fastq files. seqkit fish : look for short sequences in larger sequences using local alignment. seqkit bam : monitoring and online histograms of BAM record features. seqkit grep/locate : reduce memory occupation when using flag -m/--max-mismatch . seqkit seq : fix panic of computing complement sequence for long sequences containing illegal letters without flag -v on. #84 SeqKit v0.10.2 - 2019-07-30 seqkit : fix bug of parsing sequence ID delimited by tab ( \\t ). #78 seqkit grep : better logic of --delete-matched . seqkit common/rmdup/split : use xxhash to replace MD5 when comparing with sequence, discard flag -m/--md5 . seqkit stats : new flag -b/--basename for outputting basename instead of full path. SeqKit v0.10.1 - 2019-02-27 seqkit fx2tab : new option -q/--avg-qual for outputting average read quality. #60 seqkit grep/locate : fix support of X when using -d/--degenerate . #61 seqkit translate : new flag -M/--init-codon-as-M to translate initial codon at beginning to 'M'. #62 translates --- to - for aligned DNA/RNA, flag -X needed. #63 supports codons containing ambiguous bases, e.g., GGN->G , ATH->I . #64 new flag -l/--list-transl-table to show details of translate table N new flag -l/--list-transl-table-with-amb-codons to show details of translate table N (including ambigugous codons) seqkit split/split2 , fix bug of ignoring -O when reading from stdin. SeqKit v0.10.0 - 2018-12-24 seqkit : report error when input is directory. new command seqkit mutate : edit sequence (point mutation, insertion, deletion). SeqKit v0.9.3 - 2018-12-02 seqkit stats : fix panic for empty file. #57 seqkit translate : add flag -x/--allow-unknown-codon to translate unknown codon to X . SeqKit v0.9.2 - 2018-11-16 seqkit : stricter checking for value of global flag -t/--seq-type . seqkit sliding : fix bug for flag -g/--greedy . #54 seqkit translate : fix bug for frame < 0. #55 seqkit seq : add TAB to default blank characters (flag -G/--gap-letters ), and fix filter result when using flag -g/--remove-gaps along with -m/--min-len or -M/--max-len SeqKit v0.9.1 - 2018-10-12 seqkit faidx : fix bug of retrieving subsequence with multiple regions on same sequence. #48 seqkit sort/shuffle/split : fix bug when using -2/--two-pass to process .gz files. #52 SeqKit v0.9.0 - 2018-09-26 seqkit : better handle of empty file, no error message shown. #36 new subcommand seqkit split2 : split sequences into files by size/parts (FASTA, PE/SE FASTQ). #35 new subcommand seqkit translate : translate DNA/RNA to protein sequence. #28 seqkit sort : fix bug when using -2 -i , and add support for sorting in natural order. #39 seqkit grep and seqkit locate : add experimental support of mismatch when searching subsequences. #14 seqkit stats : add stats of Q20 and Q30 for FASTQ. #45 SeqKit v0.8.1 - 2018-06-29 seqkit : do not call pigz or gzip for decompressing gzipped file any more. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . seqkit subseq : fix bug of missing quality when using --gtf or --bed seqkit stats : parallelize counting files, it's much faster for lots of small files, especially for files on SSD SeqKit v0.8.0 - 2018-03-22 seqkit , stricter FASTA/Q format requirement , i.e., must starting with > or @ . seqkit , fix output format for FASTQ files containing zero-length records , yes this happens . seqkit , add amino acid code O (pyrrolysine) and U (selenocysteine). seqkit replace , add flag --nr-width to fill leading 0s for {nr} , useful for preparing sequence submission (\">strain_00001 XX\", \">strain_00002 XX\"). seqkit subseq , require BED file to be tab-delimited. SeqKit v0.7.2 - 2017-12-03 seqkit tab2fx : fix a concurrency bug that occurs in low proprobability when only 1-column data provided. seqkit stats : add quartiles of sequence length seqkit faidx : add support for retrieving subsequence using seq ID and region, which is similar with \"samtools faidx\" but has some extra features SeqKit v0.7.1 - 2017-09-22 seqkit convert : fix bug of read quality containing only 3 or less values. shenwei356/bio/issues/3 seqkit stats : add option -T/--tabular to output in machine-friendly tabular format. #23 seqkit common : increase speed and decrease memory occupation, and add some notes. fix some typos. #22 suggestion: please install pigz to gain better parsing performance for gzipped data . SeqKit v0.7.0 - 2017-08-12 add new command convert for converting FASTQ quality encoding between Sanger, Solexa and Illumina. Thanks suggestion from @cviner ( #18 ). usage & example . add new command range for printing FASTA/Q records in a range (start:end). #19 . usage & example . add new command concate for concatenating sequences with same ID from multiple files. usage & example . SeqKit v0.6.0 - 2017-06-21 add new command genautocomplete to generate shell autocompletion script! ( #17 ) add new command seqkit dup for duplicating sequences ( #16 ) seqkit stats -a does not show L50 which may brings confusion ( #15 ) seqkit subseq --bed : more robust for bad BED files SeqKit v0.5.5 - 2017-05-10 Increasing speed of reading .gz file by utilizing gzip (1.3X), it would be much faster if you installed pigz (2X). Fixing colorful output in Windows seqkit locate : add flag --gtf and --bed to output GTF/BED6 format, so the result can be used in seqkit subseq . seqkit subseq : fix bug of --bed , add checking coordinate. SeqKit v0.5.4 - 2017-04-11 seqkit subseq --gtf , add flag --gtf-tag to set tag that's outputted as sequence comment fix seqkit split and seqkit sample : forget not to wrap sequence and quality in output for FASTQ format compile with go1.8.1 SeqKit v0.5.3 - 2017-04-01 seqkit grep : fix bug when using seqkit grep -r -f patternfile : all records will be retrived due to failing to discarding the blank pattern ( \"\" ). #11 SeqKit v0.5.2 - 2017-03-24 seqkit stats -a and seqkit seq -g -G : change default gap letters from '- ' to '- .' seqkit subseq : fix bug of range overflow when using -d/--down-stream or -u/--up-stream for retieving subseq using BED ( --beb ) or GTF ( --gtf ) file. seqkit locate : add flag -G/--non-greedy , non-greedy mode, faster but may miss motifs overlaping with others. SeqKit v0.5.1 - 2017-03-12 seqkit restart : fix bug of flag parsing SeqKit v0.5.0 - 2017-03-11 new command seqkit restart , for resetting start position for circular genome . seqkit sliding : add flag -g/--greedy , exporting last subsequences even shorter than windows size. seqkit seq : add flag -m/--min-len and -M/--max-len to filter sequences by length . rename flag -G/--gap-letter to -G/--gap-letters . seqkit stat : renamed to seqkit stats , don't worry, old name is still available as an alias. add new flag -a/all , for all statistics, including sum_gap , N50 , and L50 . SeqKit v0.4.5 - 2017-02-26 seqkit seq : fix bug of failing to reverse quality of FASTQ sequence SeqKit v0.4.4 - 2017-02-17 seqkit locate : fix bug of missing regular-expression motifs containing non-DNA characters (e.g., ACT.{6,7}CGG ) from motif file ( -f ). compiled with go v1.8. SeqKit v0.4.3 - 2016-12-22 fix bug of seqkit stat : min_len always be 0 in versions: v0.4.0, v0.4.1, v0.4.2 SeqKit v0.4.2 - 2016-12-21 fix header information of seqkit subseq when restriving up- and down-steam sequences using GTF/BED file. SeqKit v0.4.1 - 2016-12-16 enchancement: remove redudant regions for seqkit locate . SeqKit v0.4.0 - 2016-12-07 fix bug of seqkit locate , e.g, only find two locations ( 1-4 , 7-10 , missing 4-7 ) of ACGA in ACGACGACGA . better output of seqkit stat for empty file. SeqKit v0.3.9 - 2016-12-04 fix bug of region selection for blank sequences. affected commands include seqkit subseq --region , seqkit grep --region , seqkit split --by-region . compile with go1.8beta1. SeqKit v0.3.8.1 - 2016-11-25 enhancement and bugfix of seqkit common : two or more same files allowed, fix log information of number of extracted sequences in the first file. SeqKit v0.3.8 - 2016-12-24 enhancement of seqkit common : better handling of files containing replicated sequences SeqKit v0.3.7 - 2016-12-23 fix bug in seqkit split --by-id when sequence ID contains invalid characters for system path. add more flags validation for seqkit replace . enhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added. changes: do not wrap sequence and quality in output for FASTQ format. SeqKit v0.3.6 - 2016-11-03 add new feature for seqkit grep : new flag -R ( --region ) for specifying sequence region for searching. SeqKit v0.3.5 - 2016-10-30 fig bug of seqkit grep : flag -i ( --ignore-case ) did not work when not using regular expression SeqKit v0.3.4.1 - 2016-09-21 improve performance of reading (~10%) and writing (100%) gzip-compressed file by using github.com/klauspost/pgzip package add citation SeqKit v0.3.4 - 2016-09-17 bugfix: seq wrongly handles only the first one sequence file when multiple files given new feature: fx2tab can output alphabet letters of a sequence by flag -a ( --alphabet ) new feature: new flag -K ( --keep-key ) for replace , when replacing with key-value file, one can choose keeping the key as value or not. SeqKit v0.3.3 - 2016-08-18 fix bug of seqkit replace , wrongly starting from 2 when using {nr} in -r ( --replacement ) new feature: seqkit replace supports replacement symbols {nr} (record number) and {kv} (corresponding value of the key ($1) by key-value file) SeqKit v0.3.2 - 2016-08-13 fix bug of seqkit split , error when target file is in a directory. improve performance of seqkit spliding for big sequences, and output last part even if it's shorter than window sze, output of FASTQ is also supported. SeqKit v0.3.1.1 - 2016-08-07 compile with go1.7rc5, with higher performance and smaller size of binary file SeqKit v0.3.1 - 2016-08-02 improve speed of seqkit locate SeqKit v0.3.0 - 2016-07-28 use fork of github.com/brentp/xopen, using zcat for speedup of .gz file reading on *nix systems. improve speed of parsing sequence ID when creating FASTA index reduce memory usage of seqkit subseq --gtf fix bug of seqkit subseq when using flag --id-ncbi fix bug of seqkit split , outdir error fix bug of seqkit seq -p , last base is wrongly failed to convert when sequence length is odd. add \"sum_len\" result for output of seqkit stat seqkit v0.2.9 - 2016-07-24 fix minor bug of seqkit split and seqkit shuffle , header name error due to improper use of pointer add option -O (--out-dir) to seqkit split seqkit v0.2.8 - 2016-07-19 improve speed of parsing sequence ID, not using regular expression for default --id-regexp improve speed of record outputing for small-size sequences fix minor bug: seqkit seq for blank record update benchmark result seqkit v0.2.7 - 2016-07-18 reduce memory usage by optimize the outputing of sequences. detail: using BufferedByteSliceWrapper to resuse bytes.Buffer. reduce memory usage and improve speed by using custom buffered reading mechanism, instead of using standard library bufio , which is slow for large genome sequence. discard strategy of \"buffer\" and \"chunk\" of FASTA/Q records, just parse records one by one. delete global flags -c (--chunk-size) and -b (--buffer-size) . add function testing scripts seqkit v0.2.6 - 2016-07-01 fix bug of seqkit subseq : Inplace subseq method leaded to wrong result seqkit v0.2.5.1 fix a bug of seqkit subseq : chromesome name was not be converting to lower case when using --gtf or --bed seqkit v0.2.5 - 2016-07-01 fix a serious bug brought in v0.2.3 , using unsafe method to convert string to []byte add awk-like built-in variable of record number ( {NR} ) for seqkit replace seqkit v0.2.4.1 - 2016-06-12 fix several bugs from library bio , affected situations: Locating patterns in sequences by pattern FASTA file: seqkit locate -f Reading FASTQ file with record of which the quality starts with + add command version seqkit v0.2.4 - 2016-05-31 add subcommand head seqkit v0.2.3 - 2016-05-08 reduce memory occupation by avoid copy data when convert string to []byte speedup reverse-complement by avoid repeatly calling functions seqkit v0.2.2 - 2016-05-06 reduce memory occupation of subcommands that use FASTA index seqkit v0.2.1 - 2016-05-02 improve performance of outputing. fix bug of seqkit seq -g for FASTA fromat some other minor fix of code and docs update benchmark results seqkit v0.2.0 - 2016-04-29 reduce memory usage of writing output fix bug of subseq , shuffle , sort when reading from stdin reduce memory usage of faidx make validating sequences an optional option in seq command, it saves some time. seqkit v0.1.9 - 2016-04-26 using custom FASTA index file extension: .seqkit.fai reducing memory usage of sample --number --two-pass change default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer seqkit v0.1.8 - 2016-04-24 add subcommand rename to rename duplicated IDs add subcommand faidx to create FASTA index file utilize faidx to improve performance of subseq shuffle , sort and split support two-pass mode (by flag -2 ) with faidx to reduce memory usage. document update seqkit v0.1.7 - 2016-04-21 add support for (multi-line) FASTQ format update document, add technical details rename subcommands fa2tab and tab2fa to fx2tab and tab2fx add subcommand fq2fa add column \"seq_format\" to stat add global flag -b ( --bufer-size ) little change of flag in subseq and some other commands seqkit v0.1.6 - 2016-04-07 add subcommand replace seqkit v0.1.5.2 - 2016-04-06 fix bug of grep , when not using flag -r , flag -i will not take effect. seqkit v0.1.5.1 fix result of seqkit sample -n fix benchmark script seqkit v0.1.5 - 2016-03-29 add global flag --id-ncbi add flag -d ( --dup-seqs-file ) and -D ( --dup-num-file ) for subcommand rmdup make using MD5 as an optional flag -m ( --md5 ) in subcommand rmdup and common fix file name suffix of seqkit split result minor modification of sliding output seqkit v0.1.4.1 - 2016-03-27 change alignment of stat output preciser CPUs number control seqkit v0.1.4 - 2016-03-25 add subcommand sort improve subcommand subseq : supporting of getting subsequences by GTF and BED files change name format of sliding result prettier output of stat seqkit v0.1.3.1 - 2016-03-16 Performance improvement by reducing time of cleaning spaces Document update seqkit v0.1.3 - 2016-03-15 Further performance improvement Rename sub command extract to grep Change default value of flag --threads back CPU number of current device, change default value of flag --chunk-size back 10000 sequences. Update benchmark seqkit v0.1.2 - 2016-03-14 Add flag --dna2rna and --rna2dna to subcommand seq . seqkit v0.1.1 - 2016-03-13 5.5X speedup of FASTA file parsing by avoid using regular expression to remove spaces ( detail ) and using slice indexing instead of map to validate letters ( detail ) Change default value of global flag -- thread to 1. Since most of the subcommands are I/O intensive, For computation intensive jobs, like extract and locate, you may set a bigger value. Change default value of global flag --chunk-size to 100. Add subcommand stat Fix bug of failing to automatically detect alphabet when only one record in file. seqkit v0.1 - 2016-03-11 first release of seqkit /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Download"},{"location":"download/#download","text":"SeqKit is implemented in Go programming language, statically-linked executable binary files are freely available . Please cite: W Shen , S Le, Y Li*, F Hu*. SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation. PLOS ONE . doi:10.1371/journal.pone.0163962 .","title":"Download"},{"location":"download/#current-version","text":"SeqKit v2.4.0 - 2023-03-17 seqkit : support bzip2 format . #361 support setting compression level for gzip , zstd , and bzip2 format via --compress-level . #320 the global flag --infile-list accepts stdin ( - ) now. wrap the help message of flags. seqkit locate : do not remove embeded regions when searching with regular expressions . #368 seqkit amplicon : fix BED coordinates for amplicons found in the minus strand. #367 seqkit split : fix forgetting to add extension for --two-pass . #332 seqkit stats : fix compute Q1 and Q3 of sequence length for one record. #353 seqkit grep : fix count number ( -C ) for matching with mismatch ( -m > 0 ). #370 seqkit replace : add some flags to match partly records to edit ; these flags are transplanted from seqkit grep . #348 seqkit faidx : allow empty lines at the end of sequences . seqkit faidx/sort/shuffle/split/subseq : new flag -U/--update-faidx : update the FASTA index file if it exists, to guarantee the index file matches the FASTA files . #364 improve log info and update help message. #365 seqkit seq : allow filtering sequences of length zero. thanks to @penglbio. seqkit rename : new flag -s/--separator for setting separator between original ID/name and the counter (default \"_\"). #360 new flag -N/--start-num for setting starting count number for duplicated IDs/names (default 2). #360 new flag -1/--rename-1st-rec for renaming the first record as well. #360 do not append space if there's no description after the sequene ID. seqkit sliding : new flag -S/--suffix for change the suffix added to the sequence ID (default: \"_sliding\").","title":"Current Version"},{"location":"download/#links","text":"OS Arch File, \u4e2d\u56fd\u955c\u50cf Download Count Linux 32-bit seqkit_linux_386.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux 64-bit seqkit_linux_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf Linux arm64 seqkit_linux_arm64.tar.gz , \u4e2d\u56fd\u955c\u50cf macOS 64-bit seqkit_darwin_amd64.tar.gz , \u4e2d\u56fd\u955c\u50cf macOS arm64 seqkit_darwin_arm64.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 32-bit seqkit_windows_386.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Windows 64-bit seqkit_windows_amd64.exe.tar.gz , \u4e2d\u56fd\u955c\u50cf Notes please open an issuse to request binaries for other platforms. run seqkit version to check update !!! run seqkit genautocomplete to update shell autocompletion script !!!","title":"Links"},{"location":"download/#installation","text":"","title":"Installation"},{"location":"download/#method-1-download-binaries-latest-stable-version","text":"Just download compressed executable file of your operating system, and decompress it with tar -zxvf *.tar.gz command or other tools. And then: For Linux-like systems If you have root privilege simply copy it to /usr/local/bin : sudo cp seqkit /usr/local/bin/ Or copy to anywhere in the environment variable PATH : mkdir -p $HOME/bin/; cp seqkit $HOME/bin/ For windows , just copy seqkit.exe to C:\\WINDOWS\\system32 .","title":"Method 1: Download binaries (latest stable version)"},{"location":"download/#method-2-install-via-conda-latest-stable-version","text":"conda install -c bioconda seqkit","title":"Method 2: Install via conda (latest stable version)"},{"location":"download/#method-3-install-via-homebrew-latest-stable-version","text":"brew install seqkit","title":"Method 3: Install via homebrew (latest stable version)"},{"location":"download/#method-4-for-go-developer-latest-stabledev-version","text":"go get -u github.com/shenwei356/seqkit/v2/seqkit/","title":"Method 4: For Go developer (latest stable/dev version)"},{"location":"download/#method-5-docker-based-installation-latest-stabledev-version","text":"Install Docker git clone this repo: git clone https://github.com/shenwei356/seqkit Run the following commands: cd seqkit docker build -t shenwei356/seqkit . docker run -it shenwei356/seqkit:latest","title":"Method 5: Docker based installation (latest stable/dev version)"},{"location":"download/#method-6-compiling-from-source-latest-stabledev-version","text":"# ------------------- install golang ----------------- # download Go from https://go.dev/dl wget https://go.dev/dl/go1.17.13.linux-amd64.tar.gz tar -zxf go1.17.13.linux-amd64.tar.gz -C $HOME/ # or # echo \"export PATH=$PATH:$HOME/go/bin\" >> ~/.bashrc # source ~/.bashrc export PATH=$PATH:$HOME/go/bin # ------------- the latest stable version ------------- go get -v -u github.com/shenwei356/seqkit/seqkit # The executable binary file is located in: # ~/go/bin/seqkit # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ~/go/bin/seqkit $HOME/bin/ # --------------- the devlopment version -------------- git clone https://github.com/shenwei356/seqkit cd seqkit/seqkit/ go build # The executable binary file is located in: # ./seqkit # You can also move it to anywhere in the $PATH mkdir -p $HOME/bin cp ./seqkit $HOME/bin/","title":"Method 6: Compiling from source (latest stable/dev version)"},{"location":"download/#shell-completion","text":"Supported shell: bash|zsh|fish|powershell Bash: # generate completion shell seqkit genautocomplete --shell bash # configure if never did. # install bash-completion if the \"complete\" command is not found. echo \"for bcfile in ~/.bash_completion.d/* ; do source \\$bcfile; done\" >> ~/.bash_completion echo \"source ~/.bash_completion\" >> ~/.bashrc Zsh: # generate completion shell seqkit genautocomplete --shell zsh --file ~/.zfunc/_seqkit # configure if never did echo 'fpath=( ~/.zfunc \"${fpath[@]}\" )' >> ~/.zshrc echo \"autoload -U compinit; compinit\" >> ~/.zshrc fish: seqkit genautocomplete --shell fish --file ~/.config/fish/completions/seqkit.fish","title":"Shell-completion"},{"location":"download/#release-history","text":"SeqKit v2.3.1 - 2022-09-22 seqkit grep/locate : fix bug of FMIndex building for empty sequences. #321 seqkit split2 : fix bug of splitting two FASTA files. #325 seqkit faidx : --id-regexp works now. SeqKit v2.3.0 - 2022-08-12 seqkit grep/rename : reduce memory comsumption for a lot of searching patterns, and it's faster . #305 2X faster -s/--by-seq . seqkit split fix outputting an empty file when the number of sequence equal to the split size. #293 add options to set output file prefix and extention. #296 seqkit split2 reduce memory consumption. #304 add options to set output file prefix seqkit stats : add GC content. #294 SeqKit v2.2.0 - 2020-03-14 seqkit : add support of xz and zstd input/output formats . #274 fix panic when reading records with header of ID + blanks. new command seqkit sum : computing message digest for all sequences in FASTA/Q files . The idea comes from @photocyte and the format borrows from seqhash #262 new command seqkit fa2fq : retrieving corresponding FASTQ records by a FASTA file seqkit split2 : new flag -e/--extension for forcing compresson or changing compression format. #276 support changing output prefix via -o/--out-file . #275 seqkit concat : fix handling of multiple seqs with the same ID in one file. #269 performaning out/full join. #270 preserve the comments. #271 seqkit locate : parallelizing -F/--use-fmi and -m for large number of search patterns. seqkit amplicon : new flag -M/--output-mismatches to append the total mismatches and mismatches of 5' end and 3' end. #286 seqkit grep : detect FASTA/Q symbol @ and > in the searching patterns and show warnings. add new flag -C/--count , like grep -c in GNU grep. #267 seqkit range : support removing leading 100 seqs ( seqkit range -r 101:-1 == tail -n +101 ). #279 seqkit subseq : report error when no options were given. update doc: seqkit head : add doc for \"seqkit tail\": seqkit range -N:-1 seqs.fasta . #272 seqkit rmdup : add the note of only the first record being saved for duplicates. #265 SeqKit v2.1.0 - 2021-11-15 seqkit seq : fix filtering by average quality -Q/-R . #257 seqkit convert : fix quality encoding checking, change default value of -N/--thresh-B-in-n-most-common from 4 to 2 . #254 and #239 seqkit split : fix writing an extra empty file when using --two-pass #244 seqkit subseq : fix --bed which fail to recognize strand . . seqkit fq2fa : faster, and do not wrap sequences. seqkit grep/locate/mutate : detect unquoted comma and show warning message, e.g., -p 'A{2,}' . #250 SeqKit v2.0.0 - 2021-08-27 Performance improvements seqkit : faster FASTA/Q reading and writing, especially on FASTQ , see the benchmark . reading (plain text): 4X faster. seqkit stats dataset_C.fq reading (gzip files): 45% faster. seqkit stats dataset_C.fq.gz reading + writing (plain text): 3.5X faster. seqkit grep -p . -v dataset_C.fq -o t reading + writing (gzip files): 2.2X faster. seqkit grep -p . -v dataset_C.fq.gz -o t.gz change default value of -j/--threads from 2 to 4 , which is faster for writting gzip files. seqkit seq : fix writing speed, which was slowed down in v0.12.1 . Breaking changes seqkit grep/rmdup/common : consider reverse complement sequence by default for comparing by sequence , add flag -P/--only-positive-strand . #215 seqkit rename : rename ID only, do not append original header to new ID . #236 seqkit fx2tab : for -s/--seq-hash : outputing MD5 instead of hash value (integers) of xxhash. #219 Bugfixes seqkit seq : fix failing to output gzipped format for file name with extension of .gz since v0.12.1 . seqkit tab2fx : fix bug for very long sequences. #214 seqkit fish : fix range check. #213 seqkit grep : it's not exactly a bug: forgot to use multi-threads for -m > 0. New features/enhancements seqkit grep : allow empty pattern files. seqkit faidx : support region with begin > end , i.e., returning reverse complement sequence add new flag -l/--region-file : file containing a list of regions. seqkit fx2tab : new flag -Q/--no-qual for disabling outputing quality even for FASTQ file. #221 seqkit amplicon : new flag -u/--save-unmatched for saving records that do not match any primer. seqkit sort : new flag -b/--by-bases for sorting by non-gap bases, for multiple sequence alignment files. #216 SeqKit v0.16.1 - 2021-05-20 seqkit shuffle --two-pass : fix bug introduced in #173 . #209 seqkit pair : fix a dangerous bug: when input files are not in current directory, input files were overwritten. SeqKit v0.16.0 - 2021-04-16 new command seqkit head-genome : print sequences of the first genome with common prefixes in name seqkit grep/locate/amplicon -m much faster (300-400x) searching with mismatch allowed by optimizing FM-indexing and parallelization. new flag -I/--immediate-output . seqkit grep/locate : fix bug of -m when querying contains letters not in alphabet, usually for protein sequences. #178 , #179 onply search on positive strand when searching unlimited or protein sequences. seqkit locate : removing debug info for -r introduced in a0f6b6e. #180 seqkit amplicon : fix bug of -m , when mismatch is allowed. seqkit fx2tab : new flag -C/--base-count for counting bases. #183 seqkit tab2fx : fix a rare bug. #197 seqkit subseq : fix bug for BED with empty columns. #195 seqkit genautocomplete : support bash|zsh|fish|powershell . SeqKit v0.15.0 - 2021-01-12 seqkit grep/locate : update help message. seqkit grep : search on both strand when searching by sequence . seqkit split2 : fix redundant log when using -s . seqkit bam : new field RightSoftClipSeq . #172 seqkit sample -2 : remove extra \\n . #173 seqkit split2 -l : fix bug for splitting by accumulative length, this bug occurs when the first record is longer than -l , no sequences are lost. SeqKit v0.14.0 - 2020-10-30 new command seqkit pair : match up paired-end reads from two fastq files, faster than fastq-pair. seqkit translate : new flag -F/--append-fram for optional adding frame info to ID. #159 seqkit stats : reduce memory usage when using -a for calculating N50. #153 seqkit mutate : fix inserting sequence -i/--insertion , this bug occurs when insert site is big in some cases, don't worry if no error reported. seqkit replace : new flag -U/--keep-untouched : do not change anything when no value found for the key (only for sequence name). do no support editing FASTQ sequence. seqkit grep/locate : new flag --circular for supporting circular genome. #158 SeqKit v0.13.2 - 2020-07-13 seqkit sana : fix bug causing hanging on empty files. #149 SeqKit v0.13.1 - 2020-07-09 seqkit sana : fix bug causing hanging on empty files. #148 SeqKit v0.13.0 - 2020-07-07 seqkit : fix a rare FASTA/Q parser bug. #127 seqkit seq : output sequence or quality in single line when -s/--seq or -q/--qual is on. #132 seqkit translate : delete debug info, #133 , and fix typo. #134 seqkit split2 : tiny performance improvement. #137 seqkit stats : new flag -i/--stdin-label for replacing default \"-\" for stdin. #139 seqkit fx2tab : new flag -s/--seq-hash for printing hash of sequence (case sensitive). #144 seqkit amplicon : fix bug of missing searching reverse strand. #140 supporting degenerate bases now. #83 new flag -p/--primer-file for reading list of primer pairs. #142 new flag --bed for outputing in BED6+1 format. #141 New features and improvements by @bsipos . #130 , #147 new command seqkit scat , for real-time robust concatenation of fastx files. Rewrote the parser behind the sana subcommand, now it supports robust parsing of fasta file as well. Added a \"toolbox\" feature to the bam subcommand ( -T ), which is a collection of filters acting on streams of BAM records configured through a YAML string (see the docs for more). Added the SEQKIT_THREADS environmental variable to override the default number of threads. SeqKit v0.12.1 - 2020-04-21 seqkit bam : add colorised and pretty printed output, by @bsipos . #110 seqkit locate/grep : fix bug of -m , when query contains letters not in subject sequences. #124 seqkit split2 : new flag -l/--by-length for splitting into chunks of N bases. seqkit fx2tab : new flag -I/--case-sensitive for calculating case sensitive base content. #108 add missing column name for averge quality for -H -q . #115 fix output of -n/--only-name , do not write empty columns of sequence and quality. #104 , #115 seqkit seq : new flag -k/--color : colorize sequences. SeqKit v0.12.0 - 2020-02-18 seqkit : fix checking input file existence. new global flag --infile-list for long list of input files, if given, they are appended to files from cli arguments. seqkit faidx : supporting \"truncated\" (no ending newline charactor) file. seqkit seq : do not force switching on -g when using -m/-M . show recommendation if flag -t/--seq-type is not DNA/RNA when computing complement sequence. #103 seqkit translate : supporting multiple frames. #96 seqkit grep/locate : add detection and warning for space existing in search pattern/sequence. speed improvement (2X) for -m/--max-mismatch . shenwei356/bwt/issues/3 seqkit locate : new flag -M/--hide-matched for hiding matched sequences. #98 new flag -r/--use-regexp for explicitly using regular expression, so improve speed of default index operation. And you have to switch this on if using regexp now . #101 new flag -F/--use-fmi for improving search speed for lots of sequence patterns . seqkit rename : making IDs unique across multiple files, and can write into multiple files. #100 seqkit sample : fix stdin checking for flag -2 . #102 . seqkit rename/split/split2 : fix detection of existed outdir. split split : fix bug of seqkit split -i -2 and parallizing it. seqkit version : checking update is optional ( -u ). SeqKit v0.11.0 - 2019-09-25 seqkit : fix hanging when reading from truncated gzip file. new commands: seqkit amplicon : retrieve amplicon (or specific region around it) via primer(s). new commands by @bsipos : seqkit watch : monitoring and online histograms of sequence features. seqkit sana : sanitize broken single line fastq files. seqkit fish : look for short sequences in larger sequences using local alignment. seqkit bam : monitoring and online histograms of BAM record features. seqkit grep/locate : reduce memory occupation when using flag -m/--max-mismatch . seqkit seq : fix panic of computing complement sequence for long sequences containing illegal letters without flag -v on. #84 SeqKit v0.10.2 - 2019-07-30 seqkit : fix bug of parsing sequence ID delimited by tab ( \\t ). #78 seqkit grep : better logic of --delete-matched . seqkit common/rmdup/split : use xxhash to replace MD5 when comparing with sequence, discard flag -m/--md5 . seqkit stats : new flag -b/--basename for outputting basename instead of full path. SeqKit v0.10.1 - 2019-02-27 seqkit fx2tab : new option -q/--avg-qual for outputting average read quality. #60 seqkit grep/locate : fix support of X when using -d/--degenerate . #61 seqkit translate : new flag -M/--init-codon-as-M to translate initial codon at beginning to 'M'. #62 translates --- to - for aligned DNA/RNA, flag -X needed. #63 supports codons containing ambiguous bases, e.g., GGN->G , ATH->I . #64 new flag -l/--list-transl-table to show details of translate table N new flag -l/--list-transl-table-with-amb-codons to show details of translate table N (including ambigugous codons) seqkit split/split2 , fix bug of ignoring -O when reading from stdin. SeqKit v0.10.0 - 2018-12-24 seqkit : report error when input is directory. new command seqkit mutate : edit sequence (point mutation, insertion, deletion). SeqKit v0.9.3 - 2018-12-02 seqkit stats : fix panic for empty file. #57 seqkit translate : add flag -x/--allow-unknown-codon to translate unknown codon to X . SeqKit v0.9.2 - 2018-11-16 seqkit : stricter checking for value of global flag -t/--seq-type . seqkit sliding : fix bug for flag -g/--greedy . #54 seqkit translate : fix bug for frame < 0. #55 seqkit seq : add TAB to default blank characters (flag -G/--gap-letters ), and fix filter result when using flag -g/--remove-gaps along with -m/--min-len or -M/--max-len SeqKit v0.9.1 - 2018-10-12 seqkit faidx : fix bug of retrieving subsequence with multiple regions on same sequence. #48 seqkit sort/shuffle/split : fix bug when using -2/--two-pass to process .gz files. #52 SeqKit v0.9.0 - 2018-09-26 seqkit : better handle of empty file, no error message shown. #36 new subcommand seqkit split2 : split sequences into files by size/parts (FASTA, PE/SE FASTQ). #35 new subcommand seqkit translate : translate DNA/RNA to protein sequence. #28 seqkit sort : fix bug when using -2 -i , and add support for sorting in natural order. #39 seqkit grep and seqkit locate : add experimental support of mismatch when searching subsequences. #14 seqkit stats : add stats of Q20 and Q30 for FASTQ. #45 SeqKit v0.8.1 - 2018-06-29 seqkit : do not call pigz or gzip for decompressing gzipped file any more. But you can still utilize pigz or gzip by pigz -d -c seqs.fq.gz | seqkit xxx . seqkit subseq : fix bug of missing quality when using --gtf or --bed seqkit stats : parallelize counting files, it's much faster for lots of small files, especially for files on SSD SeqKit v0.8.0 - 2018-03-22 seqkit , stricter FASTA/Q format requirement , i.e., must starting with > or @ . seqkit , fix output format for FASTQ files containing zero-length records , yes this happens . seqkit , add amino acid code O (pyrrolysine) and U (selenocysteine). seqkit replace , add flag --nr-width to fill leading 0s for {nr} , useful for preparing sequence submission (\">strain_00001 XX\", \">strain_00002 XX\"). seqkit subseq , require BED file to be tab-delimited. SeqKit v0.7.2 - 2017-12-03 seqkit tab2fx : fix a concurrency bug that occurs in low proprobability when only 1-column data provided. seqkit stats : add quartiles of sequence length seqkit faidx : add support for retrieving subsequence using seq ID and region, which is similar with \"samtools faidx\" but has some extra features SeqKit v0.7.1 - 2017-09-22 seqkit convert : fix bug of read quality containing only 3 or less values. shenwei356/bio/issues/3 seqkit stats : add option -T/--tabular to output in machine-friendly tabular format. #23 seqkit common : increase speed and decrease memory occupation, and add some notes. fix some typos. #22 suggestion: please install pigz to gain better parsing performance for gzipped data . SeqKit v0.7.0 - 2017-08-12 add new command convert for converting FASTQ quality encoding between Sanger, Solexa and Illumina. Thanks suggestion from @cviner ( #18 ). usage & example . add new command range for printing FASTA/Q records in a range (start:end). #19 . usage & example . add new command concate for concatenating sequences with same ID from multiple files. usage & example . SeqKit v0.6.0 - 2017-06-21 add new command genautocomplete to generate shell autocompletion script! ( #17 ) add new command seqkit dup for duplicating sequences ( #16 ) seqkit stats -a does not show L50 which may brings confusion ( #15 ) seqkit subseq --bed : more robust for bad BED files SeqKit v0.5.5 - 2017-05-10 Increasing speed of reading .gz file by utilizing gzip (1.3X), it would be much faster if you installed pigz (2X). Fixing colorful output in Windows seqkit locate : add flag --gtf and --bed to output GTF/BED6 format, so the result can be used in seqkit subseq . seqkit subseq : fix bug of --bed , add checking coordinate. SeqKit v0.5.4 - 2017-04-11 seqkit subseq --gtf , add flag --gtf-tag to set tag that's outputted as sequence comment fix seqkit split and seqkit sample : forget not to wrap sequence and quality in output for FASTQ format compile with go1.8.1 SeqKit v0.5.3 - 2017-04-01 seqkit grep : fix bug when using seqkit grep -r -f patternfile : all records will be retrived due to failing to discarding the blank pattern ( \"\" ). #11 SeqKit v0.5.2 - 2017-03-24 seqkit stats -a and seqkit seq -g -G : change default gap letters from '- ' to '- .' seqkit subseq : fix bug of range overflow when using -d/--down-stream or -u/--up-stream for retieving subseq using BED ( --beb ) or GTF ( --gtf ) file. seqkit locate : add flag -G/--non-greedy , non-greedy mode, faster but may miss motifs overlaping with others. SeqKit v0.5.1 - 2017-03-12 seqkit restart : fix bug of flag parsing SeqKit v0.5.0 - 2017-03-11 new command seqkit restart , for resetting start position for circular genome . seqkit sliding : add flag -g/--greedy , exporting last subsequences even shorter than windows size. seqkit seq : add flag -m/--min-len and -M/--max-len to filter sequences by length . rename flag -G/--gap-letter to -G/--gap-letters . seqkit stat : renamed to seqkit stats , don't worry, old name is still available as an alias. add new flag -a/all , for all statistics, including sum_gap , N50 , and L50 . SeqKit v0.4.5 - 2017-02-26 seqkit seq : fix bug of failing to reverse quality of FASTQ sequence SeqKit v0.4.4 - 2017-02-17 seqkit locate : fix bug of missing regular-expression motifs containing non-DNA characters (e.g., ACT.{6,7}CGG ) from motif file ( -f ). compiled with go v1.8. SeqKit v0.4.3 - 2016-12-22 fix bug of seqkit stat : min_len always be 0 in versions: v0.4.0, v0.4.1, v0.4.2 SeqKit v0.4.2 - 2016-12-21 fix header information of seqkit subseq when restriving up- and down-steam sequences using GTF/BED file. SeqKit v0.4.1 - 2016-12-16 enchancement: remove redudant regions for seqkit locate . SeqKit v0.4.0 - 2016-12-07 fix bug of seqkit locate , e.g, only find two locations ( 1-4 , 7-10 , missing 4-7 ) of ACGA in ACGACGACGA . better output of seqkit stat for empty file. SeqKit v0.3.9 - 2016-12-04 fix bug of region selection for blank sequences. affected commands include seqkit subseq --region , seqkit grep --region , seqkit split --by-region . compile with go1.8beta1. SeqKit v0.3.8.1 - 2016-11-25 enhancement and bugfix of seqkit common : two or more same files allowed, fix log information of number of extracted sequences in the first file. SeqKit v0.3.8 - 2016-12-24 enhancement of seqkit common : better handling of files containing replicated sequences SeqKit v0.3.7 - 2016-12-23 fix bug in seqkit split --by-id when sequence ID contains invalid characters for system path. add more flags validation for seqkit replace . enhancement: raise error when key pattern matches multiple targes in cases of replacing with key-value files and more controls are added. changes: do not wrap sequence and quality in output for FASTQ format. SeqKit v0.3.6 - 2016-11-03 add new feature for seqkit grep : new flag -R ( --region ) for specifying sequence region for searching. SeqKit v0.3.5 - 2016-10-30 fig bug of seqkit grep : flag -i ( --ignore-case ) did not work when not using regular expression SeqKit v0.3.4.1 - 2016-09-21 improve performance of reading (~10%) and writing (100%) gzip-compressed file by using github.com/klauspost/pgzip package add citation SeqKit v0.3.4 - 2016-09-17 bugfix: seq wrongly handles only the first one sequence file when multiple files given new feature: fx2tab can output alphabet letters of a sequence by flag -a ( --alphabet ) new feature: new flag -K ( --keep-key ) for replace , when replacing with key-value file, one can choose keeping the key as value or not. SeqKit v0.3.3 - 2016-08-18 fix bug of seqkit replace , wrongly starting from 2 when using {nr} in -r ( --replacement ) new feature: seqkit replace supports replacement symbols {nr} (record number) and {kv} (corresponding value of the key ($1) by key-value file) SeqKit v0.3.2 - 2016-08-13 fix bug of seqkit split , error when target file is in a directory. improve performance of seqkit spliding for big sequences, and output last part even if it's shorter than window sze, output of FASTQ is also supported. SeqKit v0.3.1.1 - 2016-08-07 compile with go1.7rc5, with higher performance and smaller size of binary file SeqKit v0.3.1 - 2016-08-02 improve speed of seqkit locate SeqKit v0.3.0 - 2016-07-28 use fork of github.com/brentp/xopen, using zcat for speedup of .gz file reading on *nix systems. improve speed of parsing sequence ID when creating FASTA index reduce memory usage of seqkit subseq --gtf fix bug of seqkit subseq when using flag --id-ncbi fix bug of seqkit split , outdir error fix bug of seqkit seq -p , last base is wrongly failed to convert when sequence length is odd. add \"sum_len\" result for output of seqkit stat seqkit v0.2.9 - 2016-07-24 fix minor bug of seqkit split and seqkit shuffle , header name error due to improper use of pointer add option -O (--out-dir) to seqkit split seqkit v0.2.8 - 2016-07-19 improve speed of parsing sequence ID, not using regular expression for default --id-regexp improve speed of record outputing for small-size sequences fix minor bug: seqkit seq for blank record update benchmark result seqkit v0.2.7 - 2016-07-18 reduce memory usage by optimize the outputing of sequences. detail: using BufferedByteSliceWrapper to resuse bytes.Buffer. reduce memory usage and improve speed by using custom buffered reading mechanism, instead of using standard library bufio , which is slow for large genome sequence. discard strategy of \"buffer\" and \"chunk\" of FASTA/Q records, just parse records one by one. delete global flags -c (--chunk-size) and -b (--buffer-size) . add function testing scripts seqkit v0.2.6 - 2016-07-01 fix bug of seqkit subseq : Inplace subseq method leaded to wrong result seqkit v0.2.5.1 fix a bug of seqkit subseq : chromesome name was not be converting to lower case when using --gtf or --bed seqkit v0.2.5 - 2016-07-01 fix a serious bug brought in v0.2.3 , using unsafe method to convert string to []byte add awk-like built-in variable of record number ( {NR} ) for seqkit replace seqkit v0.2.4.1 - 2016-06-12 fix several bugs from library bio , affected situations: Locating patterns in sequences by pattern FASTA file: seqkit locate -f Reading FASTQ file with record of which the quality starts with + add command version seqkit v0.2.4 - 2016-05-31 add subcommand head seqkit v0.2.3 - 2016-05-08 reduce memory occupation by avoid copy data when convert string to []byte speedup reverse-complement by avoid repeatly calling functions seqkit v0.2.2 - 2016-05-06 reduce memory occupation of subcommands that use FASTA index seqkit v0.2.1 - 2016-05-02 improve performance of outputing. fix bug of seqkit seq -g for FASTA fromat some other minor fix of code and docs update benchmark results seqkit v0.2.0 - 2016-04-29 reduce memory usage of writing output fix bug of subseq , shuffle , sort when reading from stdin reduce memory usage of faidx make validating sequences an optional option in seq command, it saves some time. seqkit v0.1.9 - 2016-04-26 using custom FASTA index file extension: .seqkit.fai reducing memory usage of sample --number --two-pass change default CPU number to 2 for multi-cpus computer, and 1 for single-CPU computer seqkit v0.1.8 - 2016-04-24 add subcommand rename to rename duplicated IDs add subcommand faidx to create FASTA index file utilize faidx to improve performance of subseq shuffle , sort and split support two-pass mode (by flag -2 ) with faidx to reduce memory usage. document update seqkit v0.1.7 - 2016-04-21 add support for (multi-line) FASTQ format update document, add technical details rename subcommands fa2tab and tab2fa to fx2tab and tab2fx add subcommand fq2fa add column \"seq_format\" to stat add global flag -b ( --bufer-size ) little change of flag in subseq and some other commands seqkit v0.1.6 - 2016-04-07 add subcommand replace seqkit v0.1.5.2 - 2016-04-06 fix bug of grep , when not using flag -r , flag -i will not take effect. seqkit v0.1.5.1 fix result of seqkit sample -n fix benchmark script seqkit v0.1.5 - 2016-03-29 add global flag --id-ncbi add flag -d ( --dup-seqs-file ) and -D ( --dup-num-file ) for subcommand rmdup make using MD5 as an optional flag -m ( --md5 ) in subcommand rmdup and common fix file name suffix of seqkit split result minor modification of sliding output seqkit v0.1.4.1 - 2016-03-27 change alignment of stat output preciser CPUs number control seqkit v0.1.4 - 2016-03-25 add subcommand sort improve subcommand subseq : supporting of getting subsequences by GTF and BED files change name format of sliding result prettier output of stat seqkit v0.1.3.1 - 2016-03-16 Performance improvement by reducing time of cleaning spaces Document update seqkit v0.1.3 - 2016-03-15 Further performance improvement Rename sub command extract to grep Change default value of flag --threads back CPU number of current device, change default value of flag --chunk-size back 10000 sequences. Update benchmark seqkit v0.1.2 - 2016-03-14 Add flag --dna2rna and --rna2dna to subcommand seq . seqkit v0.1.1 - 2016-03-13 5.5X speedup of FASTA file parsing by avoid using regular expression to remove spaces ( detail ) and using slice indexing instead of map to validate letters ( detail ) Change default value of global flag -- thread to 1. Since most of the subcommands are I/O intensive, For computation intensive jobs, like extract and locate, you may set a bigger value. Change default value of global flag --chunk-size to 100. Add subcommand stat Fix bug of failing to automatically detect alphabet when only one record in file. seqkit v0.1 - 2016-03-11 first release of seqkit /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Release history"},{"location":"faq/","text":"FAQ on FASTA/Q manipulations This page was originally written as the section FASTA/Q manipulations of The Biostar Handbook: A Beginner's Guide to Bioinformatics ( discussion on Biostars.org ) . This page illustrates common FASTA/Q manipulations using SeqKit . Some other utilities, including csvtk (CSV/TSV toolkit) and shell commands were also used. Note: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or in stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common usage but you can always use it on the other type as well. Example data How to produce an overview of FASTQ files? How to get GC content of every sequence in FASTA/Q file? How to extract sequences subset from FASTA/Q file with name/ID list file? How to find FASTA/Q sequences containing degenerate bases and locate them? How to remove duplicated FASTA/Q records with same sequences? How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? How to sort huge number of FASTA sequences by length? How to split FASTA sequences according to information in header? How to search and replace FASTA header with known character strings from a text file? How to extract paired reads from two paired-end reads file? How to concatenate two FASTA sequences in to one? Example data One FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein sequences from NCBI RefSeq database, 60+40M) are used. wget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz How to produce an overview of FASTQ files? Sequence format and type are automatically detected. $ seqkit stat *.gz file format type num_seqs sum_len min_len avg_len max_len duplicated-reads.fq.gz FASTQ DNA 15,000 1,515,000 101 101 101 viral.1.1.genomic.fna.gz FASTA DNA 7,048 203,325,120 200 28,848.6 2,473,870 viral.1.protein.faa.gz FASTA Protein 252,611 62,024,702 5 245.5 8,960 How to get GC content of every sequence in FASTA/Q file? seqkit fx2tab converts FASTA/Q to 3-column tabular format (1th: name/ID, 2nd: sequence, 3rd: quality), and can also provides various information in new columns, including sequence length, GC content/GC skew, alphabet. GC content: $ seqkit fx2tab --name --only-id --gc viral*.fna.gz gi|526245010|ref|NC_021865.1| 40.94 gi|460042095|ref|NC_020479.1| 41.82 gi|526244636|ref|NC_021857.1| 49.17 Custom bases (A, C and A+C): $ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz #name seq qual a c ac gi|526245010|ref|NC_021865.1| 33.20 18.24 51.44 gi|460042095|ref|NC_020479.1| 32.57 19.63 52.20 gi|526244636|ref|NC_021857.1| 25.52 23.06 48.59 How to extract sequences subset from FASTA/Q file with name/ID list file? This is a frequently used manipulation. Let's create a sample ID list file, which may also come from other way like mapping result. $ seqkit sample --proportion 0.001 duplicated-reads.fq.gz \\ | seqkit seq --name --only-id > id.txt ID list file: $ head id.txt SRR1972739.2996 SRR1972739.3044 SRR1972739.3562 Searching by ID list file: $ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz \\ > duplicated-reads.subset.fq.gz How to find FASTA/Q sequences containing degenerate bases and locate them? seqkit fx2tab converts FASTA/Q to tabular format and can output the sequence alphabet in a new column. And then text searching tools can be used to filter the table. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" gi|446730228|ref|NC_019782.1| ACGNT gi|557940284|ref|NC_022800.1| ACGKT gi|564292828|ref|NC_023009.1| ACGNT Long-option version of the command: $ seqkit fx2tab --name --only-id --alphabet viral.1.1.genomic.fna.gz \\ | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\" You can then exclude these sequences with seqkit grep : # save the sequenece IDs. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1 > id2.txt # search and exclude. $ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz > clean.fa Or locate the degenerate bases, e.g, N and K $ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz \\ | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+ seqID patternName pattern strand start end matched gi|564292828|ref|NC_023009.1| N+ N+ + 87972 87972 N gi|564292828|ref|NC_023009.1| N+ N+ + 100983 100983 N gi|557307918|ref|NC_022755.1| K+ K+ + 1788 1788 K gi|557307918|ref|NC_022755.1| K+ K+ + 4044 4044 K gi|589287065|ref|NC_023585.1| K+ K+ + 28296 28296 K gi|590911929|ref|NC_023639.1| N+ N+ + 741654 741753 NNNNNNNNNNNNNNNNNNNNNNNNNNN How to remove duplicated FASTA/Q records with same sequences? $ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz > duplicated-reads.uniq.fq.gz If the FASTA/Q file is very large, please switch on flag -m/--md5 , which use MD5 instead of original seqs to reduce memory usage when comparing by sequences. You can also deduplicate according to sequence ID (default) or full name ( --by-name ). How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? Related posts: Question: Count and location of strings in fastq file reads , Question: Finding TATAWAA in sequence . Assuming a list of motifs (enzyme digest sites) in FASTA format to be located: $ cat enzymes.fa >EcoRI GAATTC >MmeI TCCRAC >SacI GAGCTC >XcmI CCANNNNNNNNNTGG Flag --degenerate is on because patterns contain degenerate bases. Command: $ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz Sample output (simplified and reformated by csvtk -t uniq -f 3 | csvtk -t pretty ) seqID patternName pattern strand start end matched gi|526245010|ref|NC_021865.1| MmeI TCCRAC + 1816 1821 TCCGAC gi|526245010|ref|NC_021865.1| SacI GAGCTC + 19506 19511 GAGCTC gi|526245010|ref|NC_021865.1| XcmI CCANNNNNNNNNTGG + 2221 2235 CCATATTTAGTGTGG How to sort huge number of FASTA sequences by length? Sorting FASTA file in order of sequence size (small to large). $ seqkit sort --by-length viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa If the files are too big, use flag --two-pass which consumes lesser memory. $ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa You can also sort by sequence ID (default), full header ( --by-name ) or sequence content ( --by-seq ). How to split FASTA sequences according to information in header? Related posts: Question: extract same all similar sequences in FASTA based on the header . For example, FASTA header line of viral.1.protein.faa.gz contain species name in square brackets. Overview of FASTA Headers: $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name gi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23] gi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23] gi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23] seqkit split can split FASTA/Q files according to ID, number of parts, size of every parts, and sequence region. In this case, we'll split according to sequence ID (species names) which can be specified by flag --id-regexp . Default ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id gi|526245011|ref|YP_008320337.1| gi|526245012|ref|YP_008320338.1| gi|526245013|ref|YP_008320339.1| New ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\" Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Split: $ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz How to search and replace FASTA header with known character strings from a text file? Related posts: Question: Replace names in FASTA file with a known character string from a text file , Question: Fasta header, search and replace...? . seqKit replace can find substrings in FASTA/Q header with regular expression and replace them with strings or corresponding values of found substrings provided by the tab-delimited key-value file. For example, to unify names of protein with unknown functions, we want to rename \"hypothetical\" to \"putative\" in lower case. The replacing rules are listed below in tab-delimited file: $ cat changes.tsv Hypothetical putative hypothetical putative Putative putative Overview the FASTA headers containing \"hypothetical\": $ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz \\ | seqkit head -n 3 | seqkit seq --name gi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23] gi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23] gi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23] A regular expression, ^([^ ]+ )(\\w+) , was used to specify the key to be replaced, which is the first word after sequence ID in this case. Note that we also capture the ID ( ^([^ ]+ ) ) so we can restore it in \"replacement\" with capture variable ${1} (robuster than $1 ). And flag -I/--key-capt-idx (default: 1) is set to 2 because the key (\\w+) is the second captured match. Command: $ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" \\ --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz > renamed.fa How to extract paired reads from two paired-end reads file? Use seqkit pair . How to concatenate two FASTA sequences in to one? Related posts: Combining two fasta sequences into one Data (not in same order): $ cat 1.fa >seq1 aaaaa >seq2 ccccc >seq3 ggggg $ cat 2.fa >seq3 TTTTT >seq2 GGGGG >seq1 CCCCC Just one command: $ seqkit concat 1.fa 2.fa >seq1 aaaaaCCCCC >seq2 cccccGGGGG >seq3 gggggTTTTT","title":"FAQ"},{"location":"faq/#faq-on-fastaq-manipulations","text":"This page was originally written as the section FASTA/Q manipulations of The Biostar Handbook: A Beginner's Guide to Bioinformatics ( discussion on Biostars.org ) . This page illustrates common FASTA/Q manipulations using SeqKit . Some other utilities, including csvtk (CSV/TSV toolkit) and shell commands were also used. Note: SeqKit seamlessly support FASTA and FASTQ formats both in their original form or in stored in gzipped compressed format. We list FASTA or FASTQ depending on the more common usage but you can always use it on the other type as well. Example data How to produce an overview of FASTQ files? How to get GC content of every sequence in FASTA/Q file? How to extract sequences subset from FASTA/Q file with name/ID list file? How to find FASTA/Q sequences containing degenerate bases and locate them? How to remove duplicated FASTA/Q records with same sequences? How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence? How to sort huge number of FASTA sequences by length? How to split FASTA sequences according to information in header? How to search and replace FASTA header with known character strings from a text file? How to extract paired reads from two paired-end reads file? How to concatenate two FASTA sequences in to one?","title":"FAQ on FASTA/Q manipulations"},{"location":"faq/#example-data","text":"One FASTQ file (sample reads, 1M) and two FASTA files (Virus DNA and protein sequences from NCBI RefSeq database, 60+40M) are used. wget http://data.biostarhandbook.com/reads/duplicated-reads.fq.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.1.genomic.fna.gz wget ftp://ftp.ncbi.nih.gov/refseq/release/viral/viral.1.protein.faa.gz","title":"Example data"},{"location":"faq/#how-to-produce-an-overview-of-fastq-files","text":"Sequence format and type are automatically detected. $ seqkit stat *.gz file format type num_seqs sum_len min_len avg_len max_len duplicated-reads.fq.gz FASTQ DNA 15,000 1,515,000 101 101 101 viral.1.1.genomic.fna.gz FASTA DNA 7,048 203,325,120 200 28,848.6 2,473,870 viral.1.protein.faa.gz FASTA Protein 252,611 62,024,702 5 245.5 8,960","title":"How to produce an overview of FASTQ files?"},{"location":"faq/#how-to-get-gc-content-of-every-sequence-in-fastaq-file","text":"seqkit fx2tab converts FASTA/Q to 3-column tabular format (1th: name/ID, 2nd: sequence, 3rd: quality), and can also provides various information in new columns, including sequence length, GC content/GC skew, alphabet. GC content: $ seqkit fx2tab --name --only-id --gc viral*.fna.gz gi|526245010|ref|NC_021865.1| 40.94 gi|460042095|ref|NC_020479.1| 41.82 gi|526244636|ref|NC_021857.1| 49.17 Custom bases (A, C and A+C): $ seqkit fx2tab -H -n -i -B a -B c -B ac viral.1.1.genomic.fna.gz #name seq qual a c ac gi|526245010|ref|NC_021865.1| 33.20 18.24 51.44 gi|460042095|ref|NC_020479.1| 32.57 19.63 52.20 gi|526244636|ref|NC_021857.1| 25.52 23.06 48.59","title":"How to get GC content of every sequence in FASTA/Q file?"},{"location":"faq/#how-to-extract-sequences-subset-from-fastaq-file-with-nameid-list-file","text":"This is a frequently used manipulation. Let's create a sample ID list file, which may also come from other way like mapping result. $ seqkit sample --proportion 0.001 duplicated-reads.fq.gz \\ | seqkit seq --name --only-id > id.txt ID list file: $ head id.txt SRR1972739.2996 SRR1972739.3044 SRR1972739.3562 Searching by ID list file: $ seqkit grep --pattern-file id.txt duplicated-reads.fq.gz \\ > duplicated-reads.subset.fq.gz","title":"How to extract sequences subset from FASTA/Q file with name/ID list file?"},{"location":"faq/#how-to-find-fastaq-sequences-containing-degenerate-bases-and-locate-them","text":"seqkit fx2tab converts FASTA/Q to tabular format and can output the sequence alphabet in a new column. And then text searching tools can be used to filter the table. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" gi|446730228|ref|NC_019782.1| ACGNT gi|557940284|ref|NC_022800.1| ACGKT gi|564292828|ref|NC_023009.1| ACGNT Long-option version of the command: $ seqkit fx2tab --name --only-id --alphabet viral.1.1.genomic.fna.gz \\ | csvtk --no-header-row --tabs grep --fields 4 --use-regexp --ignore-case --pattern \"[^ACGT]\" You can then exclude these sequences with seqkit grep : # save the sequenece IDs. $ seqkit fx2tab -n -i -a viral.1.1.genomic.fna.gz \\ | csvtk -H -t grep -f 4 -r -i -p \"[^ACGT]\" | csvtk -H -t cut -f 1 > id2.txt # search and exclude. $ seqkit grep --pattern-file id2.txt --invert-match viral.1.1.genomic.fna.gz > clean.fa Or locate the degenerate bases, e.g, N and K $ seqkit grep --pattern-file id2.txt viral.1.1.genomic.fna.gz \\ | seqkit locate --ignore-case --only-positive-strand --pattern K+ --pattern N+ seqID patternName pattern strand start end matched gi|564292828|ref|NC_023009.1| N+ N+ + 87972 87972 N gi|564292828|ref|NC_023009.1| N+ N+ + 100983 100983 N gi|557307918|ref|NC_022755.1| K+ K+ + 1788 1788 K gi|557307918|ref|NC_022755.1| K+ K+ + 4044 4044 K gi|589287065|ref|NC_023585.1| K+ K+ + 28296 28296 K gi|590911929|ref|NC_023639.1| N+ N+ + 741654 741753 NNNNNNNNNNNNNNNNNNNNNNNNNNN","title":"How to find FASTA/Q sequences containing degenerate bases and locate them?"},{"location":"faq/#how-to-remove-duplicated-fastaq-records-with-same-sequences","text":"$ seqkit rmdup --by-seq --ignore-case duplicated-reads.fq.gz > duplicated-reads.uniq.fq.gz If the FASTA/Q file is very large, please switch on flag -m/--md5 , which use MD5 instead of original seqs to reduce memory usage when comparing by sequences. You can also deduplicate according to sequence ID (default) or full name ( --by-name ).","title":"How to remove duplicated FASTA/Q records with same sequences?"},{"location":"faq/#how-to-locate-motifsubsequenceenzyme-digest-site-in-fastaq-sequence","text":"Related posts: Question: Count and location of strings in fastq file reads , Question: Finding TATAWAA in sequence . Assuming a list of motifs (enzyme digest sites) in FASTA format to be located: $ cat enzymes.fa >EcoRI GAATTC >MmeI TCCRAC >SacI GAGCTC >XcmI CCANNNNNNNNNTGG Flag --degenerate is on because patterns contain degenerate bases. Command: $ seqkit locate --degenerate --ignore-case --pattern-file enzymes.fa viral.1.1.genomic.fna.gz Sample output (simplified and reformated by csvtk -t uniq -f 3 | csvtk -t pretty ) seqID patternName pattern strand start end matched gi|526245010|ref|NC_021865.1| MmeI TCCRAC + 1816 1821 TCCGAC gi|526245010|ref|NC_021865.1| SacI GAGCTC + 19506 19511 GAGCTC gi|526245010|ref|NC_021865.1| XcmI CCANNNNNNNNNTGG + 2221 2235 CCATATTTAGTGTGG","title":"How to locate motif/subsequence/enzyme digest site in FASTA/Q sequence?"},{"location":"faq/#how-to-sort-huge-number-of-fasta-sequences-by-length","text":"Sorting FASTA file in order of sequence size (small to large). $ seqkit sort --by-length viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa If the files are too big, use flag --two-pass which consumes lesser memory. $ seqkit sort --by-length --two-pass viral.1.1.genomic.fna.gz > viral.1.1.genomic.sorted.fa You can also sort by sequence ID (default), full header ( --by-name ) or sequence content ( --by-seq ).","title":"How to sort huge number of FASTA sequences by length?"},{"location":"faq/#how-to-split-fasta-sequences-according-to-information-in-header","text":"Related posts: Question: extract same all similar sequences in FASTA based on the header . For example, FASTA header line of viral.1.protein.faa.gz contain species name in square brackets. Overview of FASTA Headers: $ seqkit head -n 3 viral.1.protein.faa.gz | seqkit seq --name gi|526245011|ref|YP_008320337.1| terminase small subunit [Paenibacillus phage phiIBB_Pl23] gi|526245012|ref|YP_008320338.1| terminase large subunit [Paenibacillus phage phiIBB_Pl23] gi|526245013|ref|YP_008320339.1| portal protein [Paenibacillus phage phiIBB_Pl23] seqkit split can split FASTA/Q files according to ID, number of parts, size of every parts, and sequence region. In this case, we'll split according to sequence ID (species names) which can be specified by flag --id-regexp . Default ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id gi|526245011|ref|YP_008320337.1| gi|526245012|ref|YP_008320338.1| gi|526245013|ref|YP_008320339.1| New ID: $ seqkit head -n 3 viral.1.protein.faa.gz \\ | seqkit seq --name --only-id --id-regexp \"\\[(.+)\\]\" Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Paenibacillus phage phiIBB_Pl23 Split: $ seqkit split --by-id --id-regexp \"\\[(.+)\\]\" viral.1.protein.faa.gz","title":"How to split FASTA sequences according to information in header?"},{"location":"faq/#how-to-search-and-replace-fasta-header-with-known-character-strings-from-a-text-file","text":"Related posts: Question: Replace names in FASTA file with a known character string from a text file , Question: Fasta header, search and replace...? . seqKit replace can find substrings in FASTA/Q header with regular expression and replace them with strings or corresponding values of found substrings provided by the tab-delimited key-value file. For example, to unify names of protein with unknown functions, we want to rename \"hypothetical\" to \"putative\" in lower case. The replacing rules are listed below in tab-delimited file: $ cat changes.tsv Hypothetical putative hypothetical putative Putative putative Overview the FASTA headers containing \"hypothetical\": $ seqkit grep --by-name --use-regexp --ignore-case --pattern hypothetical viral.1.protein.faa.gz \\ | seqkit head -n 3 | seqkit seq --name gi|526245016|ref|YP_008320342.1| hypothetical protein IBBPl23_06 [Paenibacillus phage phiIBB_Pl23] gi|526245019|ref|YP_008320345.1| hypothetical protein IBBPl23_09 [Paenibacillus phage phiIBB_Pl23] gi|526245020|ref|YP_008320346.1| hypothetical protein IBBPl23_10 [Paenibacillus phage phiIBB_Pl23] A regular expression, ^([^ ]+ )(\\w+) , was used to specify the key to be replaced, which is the first word after sequence ID in this case. Note that we also capture the ID ( ^([^ ]+ ) ) so we can restore it in \"replacement\" with capture variable ${1} (robuster than $1 ). And flag -I/--key-capt-idx (default: 1) is set to 2 because the key (\\w+) is the second captured match. Command: $ seqkit replace --kv-file changes.tsv --pattern \"^([^ ]+ )(\\w+) \" \\ --replacement \"\\${1}{kv} \" --key-capt-idx 2 --keep-key viral.1.protein.faa.gz > renamed.fa","title":"How to search and replace FASTA header with known character strings from a text file?"},{"location":"faq/#how-to-extract-paired-reads-from-two-paired-end-reads-file","text":"Use seqkit pair .","title":"How to extract paired reads from two paired-end reads file?"},{"location":"faq/#how-to-concatenate-two-fasta-sequences-in-to-one","text":"Related posts: Combining two fasta sequences into one Data (not in same order): $ cat 1.fa >seq1 aaaaa >seq2 ccccc >seq3 ggggg $ cat 2.fa >seq3 TTTTT >seq2 GGGGG >seq1 CCCCC Just one command: $ seqkit concat 1.fa 2.fa >seq1 aaaaaCCCCC >seq2 cccccGGGGG >seq3 gggggTTTTT","title":"How to concatenate two FASTA sequences in to one?"},{"location":"note/","text":"Notes Sequence Parsing Strategies In general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences. During the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made ( Seqkit v0.2.7 ). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter. Figure 1 Illustration of FASTA/Q file parsing strategies . (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences. Effect of random seed on results of seqkit sample seqkit sample supports FASTA/Q sampling by proportion or amount. For sampling by proportion ( P ), SeqKit returns a record if a random number ( [0, 1 ]) is less than P . For sampling by amount ( N ), Seqkit firstly gets the total amount of records, and compute the proportion ( P ), and sampling by proportion ( P ). Cause the generated random number is pseudorandom and affected by the random seed ( -s/--rand-seed ), the number of sampled records may not be equal to N . Here we evaluate the effect of random seed on seqkit sample results. Used softwares csvtk: https://github.com/shenwei356/csvtk rush: https://github.com/shenwei356/rush Amount distribution of sampled records 1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 1000 , and the distribution of number of sampled records was plotted in boxplot. seq 1000 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | wc -l' \\ > ns.txt cat ns.txt | csvtk -H -t plot box -f 1 --horiz --height 2 \\ --xlab \"# of sampled records\" \\ > ns.png Location distribution of sampled records 1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 10 . The record IDs ( x axis ) was used to plot a scatter plot, which show the location distribution of sampled records. The ideal distribution would produces a straight line in the plot. seq 10 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | csvtk -H -t mutate \\ | csvtk -H -t replace -f 2 -p '.+' -r '{nr}' \\ | csvtk -H -t replace -f 4 -p '.+' -r {}' \\ | csvtk -H -t plot line -x 1 -y 2 -g 4 \\ --xlab \"sampled locations\" --ylab \"new ID of sampled records\" \\ --title \"location distribution of sampled records\" \\ --width 8 --height 6 --point-size 2 \\ > pos.png /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Notes"},{"location":"note/#notes","text":"","title":"Notes"},{"location":"note/#sequence-parsing-strategies","text":"In general, most FASTA/Q file processing softwares read one sequence record and process it immediately, and then read the next one (Fig 1A). The early version of SeqKit adopted this strategy too; however, our sequence parsing algorithm was not efficient. Therefore, we tried another strategy by using a separated thread to non-blocking read and parse sequences (Fig 1B): The sequence parsing thread parsed fixed number of sequences and packaged them into Chunks, then one or more chunks were buffered in memory so they could be paralleled processed by one or more processing threads. This strategy saved time by reducing the waiting time between parsing sequences and by paralleled processing of sequences in some cases. However, this strategy consumes more memories especially for long sequences like human genome and it is hard to find an optimum combination of buffer and chunk size for different scales of sequences. During the major revision, we kept on optimizing the sequence parsing algorithm and several optimizations had been made ( Seqkit v0.2.7 ). The most important one is using custom buffered file reading algorithm instead of using standard library \u201cbufio\u201d which is not efficient in memory for large sequences. This increased the speed and lowered memory usage significantly. Note that the \u201cbuffer\u201d here is different from the previously mentioned one in Fig 1B, this \u201cbuffer\u201d evolved in the low level processing of file reading. At last, the FASTA/Q format parsing algorithm was significant improved by factor of about 3\u00d7 in speed and the memory usage was only 1/2 compared to SeqKit version 0.2.4 in the first manuscript (this was not descripted in the manuscript). Therefore, we discarded the strategy of \u201cbuffer and chunk\u201d and adopt the serially reading strategy again (Fig 1C). The only difference between Fig C and Fig A is that the time of parsing one sequence is much shorter. Figure 1 Illustration of FASTA/Q file parsing strategies . (A) and (C) Main thread parses one sequence, waits (blocked) it to be processed and then parses next one. (B) Sequence parsing thread continuously (non-blocked) parses sequences and passes them to main thread. The width of rectangles representing sequence parsing and sequence processing is proportional with running time. Sequence parsing speeds in (A) and (B) are the same, which are both much slower than that in (C). The speeds of sequence processing are identical in (A), (B) and (C). In (B), chunks of sequences in buffer can be processed in parallel, but most of the time the main thread needs to serially manipulate the sequences.","title":"Sequence Parsing Strategies"},{"location":"note/#effect-of-random-seed-on-results-of-seqkit-sample","text":"seqkit sample supports FASTA/Q sampling by proportion or amount. For sampling by proportion ( P ), SeqKit returns a record if a random number ( [0, 1 ]) is less than P . For sampling by amount ( N ), Seqkit firstly gets the total amount of records, and compute the proportion ( P ), and sampling by proportion ( P ). Cause the generated random number is pseudorandom and affected by the random seed ( -s/--rand-seed ), the number of sampled records may not be equal to N . Here we evaluate the effect of random seed on seqkit sample results. Used softwares csvtk: https://github.com/shenwei356/csvtk rush: https://github.com/shenwei356/rush","title":"Effect of random seed on results of seqkit sample"},{"location":"note/#amount-distribution-of-sampled-records","text":"1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 1000 , and the distribution of number of sampled records was plotted in boxplot. seq 1000 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | wc -l' \\ > ns.txt cat ns.txt | csvtk -H -t plot box -f 1 --horiz --height 2 \\ --xlab \"# of sampled records\" \\ > ns.png","title":"Amount distribution of sampled records"},{"location":"note/#location-distribution-of-sampled-records","text":"1000 FASTA records with IDs of 1 , 2 , ..., 1000 were sampled by proportion of 0.1 with random seeds from 1 to 10 . The record IDs ( x axis ) was used to plot a scatter plot, which show the location distribution of sampled records. The ideal distribution would produces a straight line in the plot. seq 10 \\ | rush 'seq 1000 | csvtk -t -H mutate | seqkit tab2fx \\ | seqkit sample -p 0.1 -s {} \\ | seqkit fx2tab | csvtk -H -t mutate \\ | csvtk -H -t replace -f 2 -p '.+' -r '{nr}' \\ | csvtk -H -t replace -f 4 -p '.+' -r {}' \\ | csvtk -H -t plot line -x 1 -y 2 -g 4 \\ --xlab \"sampled locations\" --ylab \"new ID of sampled records\" \\ --title \"location distribution of sampled records\" \\ --width 8 --height 6 --point-size 2 \\ > pos.png /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Location distribution of sampled records"},{"location":"tutorial/","text":"Tutorial Some manipulations on big genomes A script memusg is used to check the peek memory usage of seqkit. Usage: memusg [-t] command . Human genome $ seqkit stat hsa.fa file format type num_seqs sum_len min_len avg_len max_len hsa.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 Build FASTA index ( optional , when using flag -2 ( --two-pass ), some commands will automaticlly build it). For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files or stdin, FASTA index would be optional used for rapid acccess of sequences and reducing memory occupation. ATTENTION : the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools. SeqKit uses full sequence head instead of just ID as key. $ memusg -t seqkit faidx --id-regexp \"^(.+)$\" hsa.fa -o hsa.fa.seqkit.fai elapsed time: 10.011s peak rss: 177.21 MB Create common .fai file: $ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2 elapsed time: 10.454s peak rss: 172.82 MB Performance of samtools: $ memusg -t samtools faidx hsa.fa elapsed time: 9.574s peak rss: 1.45 MB Exactly same content: $ md5sum hsa.fa.fai* 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai2 Sorting by sequence length $ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa > hsa.sorted.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs and lengths from FASTA index ... [INFO] 194 sequences loaded [INFO] sorting ... [INFO] output ... elapsed time: 4.892s peak rss: 500.15 MB Detail: $ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more 1 248956422 2 242193529 3 198295559 4 190214555 5 181538259 6 170805979 7 159345973 X 156040895 8 145138636 9 138394717 11 135086622 10 133797422 12 133275309 13 114364328 14 107043718 15 101991189 16 90338345 17 83257441 18 80373285 20 64444167 19 58617616 Y 57227415 22 50818468 21 46709983 KI270728.1 1872759 KI270727.1 448248 ... real 0m10.697s user 0m11.153s sys 0m0.917s Shuffling sequences $ memusg -t seqkit shuffle hsa.fa --two-pass > hsa.shuffled.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... elapsed time: 6.632s peak rss: 528.3 MB Spliting into files with single sequence $ memusg -t seqkit split --by-id hsa.fa --two-pass [INFO] split by ID. idRegexp: ^([^\\s]+)\\s? [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] write 1 sequences to file: hsa.id_KI270743.1.fa [INFO] write 1 sequences to file: hsa.id_KI270706.1.fa [INFO] write 1 sequences to file: hsa.id_KI270717.1.fa [INFO] write 1 sequences to file: hsa.id_KI270718.1.fa [INFO] write 1 sequences to file: hsa.id_KI270468.1.fa ... elapsed time: 18.807s peak rss: 1.36 GB Geting subsequence of some chromesomes $ memusg -t seqkit subseq -r 1:10 --chr X --chr Y hsa.fa >X_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF nnnnnnnnnn >Y_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF NNNNNNNNNN elapsed time: 1.276s peak rss: 640.92 MB Geting CDS sequence of chr 1 by GTF files $ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds hsa.fa > chrX.gtf.cds.fa [INFO] read GTF file ... [INFO] 22420 GTF features loaded elapsed time: 8.643s peak rss: 846.14 MB Remove contaminated reads Mapping with reads on some potential contaminate genomes, and get the reads IDs list. $ wc -l contaminate.list 244 contaminate.list $ head -n 2 contaminate.list HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 HWI-D00523:240:HF3WGBCXX:1:1101:12616:2205 Remove contaminated reads $ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz $ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz $ seqkit stat *.fq.gz file seq_format seq_type num_seqs min_len avg_len max_len reads_1.clean.fq.gz FASTQ DNA 2,256 226 227 229 reads_1.fq.gz FASTQ DNA 2,500 226 227 229 reads_2.clean.fq.gz FASTQ DNA 2,256 223 224 225 reads_2.fq.gz FASTQ DNA 2,500 223 224 225 Handling of aligned sequences Some mock sequences (usually they will be much longer) $ cat seqs.fa >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Run multiple sequence alignment (clustalo) clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4 Convert FASTA format to tabular format. $ seqkit fx2tab seqs.msa.fa seq1 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG seq2 ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG or $ seqkit fx2tab seqs.msa.fa | cut -f 2 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG For me, it's useful when 1) manually assembling Sanger sequencing result, 2) designing site specific PCR primers. Remove gaps $ seqkit seq seqs.msa.fa -g >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Play with miRNA hairpins Dataset hairpin.fa.gz from The miRBase Sequence Database -- Release 21 Quick glance Sequence number $ seqkit stat hairpin.fa.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 First 10 bases $ zcat hairpin.fa.gz \\ | seqkit subseq -r 1:10 \\ | seqkit sort -s | seqkit seq -s \\ | head -n 10 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAG AAAAAAAAAG AAAAAAAAAG AAAAAAAAAU AAAAAAAAGG AAAAAAACAU AAAAAAACGA AAAAAAAUUA hmm, nothing special, non-coding RNA~ Repeated hairpin sequences We may want to check how may identical hairpins among different species there are. seqkit rmdup could remove duplicated sequences by sequence content, and save the replicates to another file (here is duplicated.fa.gz ), as well as replicating details ( duplicated.detail.txt , 1th column is the repeated number, 2nd column contains sequence IDs seperated by comma). $ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ head -n 5 duplicated.detail.txt 18 dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18 16 hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3 15 dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125 13 hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b 13 hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a The result shows the most conserved miRNAs among different species, mir-29b , mir-125 , mir-19b-1 and mir-20a . And the dre-miR-430c has the most multicopies in Danio rerio . Hairpins in different species Before spliting by species, let's take a look at the sequence names. $ seqkit seq hairpin.fa.gz -n | head -n 3 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop The first three letters (e.g. cel ) are the abbreviation of species names. So we could split hairpins by the first letters by defining custom sequence ID parsing regular expression ^([\\w]+)\\- . By default, seqkit takes the first non-space letters as sequence ID. For example, FASTA head ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . Split sequences by species. A custom ID parsing regular expression is used, ^([\\w]+)\\- . $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass To reduce memory usage when splitting big file, we should always use flag --two-pass Species with most miRNA hairpins. Third column is the sequences number. $ cd hairpin.fa.gz.split/; $ seqkit stat hairpin.id_* \\ | csvtk space2tab \\ | csvtk -t sort -k num_seqs:nr \\ | csvtk -t pretty \\ | more file format type num_seqs sum_len min_len avg_len max_len hairpin.id_hsa.fasta FASTA RNA 1,881 154,242 82 82 82 hairpin.id_mmu.fasta FASTA RNA 1,193 107,370 90 90 90 hairpin.id_bta.fasta FASTA RNA 808 61,408 76 76 76 hairpin.id_gga.fasta FASTA RNA 740 42,180 57 57 57 hairpin.id_eca.fasta FASTA RNA 715 89,375 125 125 125 hairpin.id_mtr.fasta FASTA RNA 672 231,840 345 345 345 Here, a CSV/TSV tool csvtk is used to sort and view the result. For human miRNA hairpins Length distribution. seqkit fx2tab could show extra information like sequence length, GC content. csvtk is used to plot. $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\" $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot box --xlab Length --horiz --height 1.5 Bacteria genome Dataset Pseudomonas aeruginosa PAO1 , files: Genbank file PAO1.gb Genome FASTA file PAO1.fasta GTF file PAO1.gtf was created with extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py PAO1.gb -t . -f gtf > PAO1.gtf Motif distribution Motifs $ cat motifs.fa >GTAGCGS GTAGCGS >GGWGKTCG GGWGKTCG Sliding. Remember flag --id-ncbi , do you? By the way, do not be scared by the long flag --circle-genome , --step and so on. They have short ones, -c , -s $ seqkit sliding --id-ncbi --circular-genome \\ --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa $ seqkit stat PAO1.fasta.sliding.fa file format type num_seqs sum_len min_len avg_len max_len PAO1.fasta.sliding.fa FASTA DNA 314 62,800,000 200,000 200,000 200,000 Locating motifs $ seqkit locate --id-ncbi --ignore-case --degenerate \\ --pattern-file motifs.fa PAO1.fasta.sliding.fa -o PAO1.fasta.sliding.fa.motifs.tsv Ploting distribution ( plot_motif_distribution.R ) # preproccess $ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv > PAO1.fasta.sliding.fa.motifs.tsv2 # plot $ ./plot_motif_distribution.R Result Find multicopy genes Get all CDS sequences $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta $ seqkit stat *.fasta file format type num_seqs sum_len min_len avg_len max_len PAO1.cds.fasta FASTA DNA 5,572 5,593,306 72 1,003.8 16,884 PAO1.fasta FASTA DNA 1 6,264,404 6,264,404 6,264,404 6,264,404 Get duplicated sequences $ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta \\ --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text $ cat PAO1.cds.dup.text 6 NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:- 2 NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+ 2 NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+ 2 NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+ Flanking sequences Get CDS and 1000 bp upstream sequence $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 Get 1000 bp upstream sequence of CDS, NOT including CDS. $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 --only-flank /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"tutorial/#some-manipulations-on-big-genomes","text":"A script memusg is used to check the peek memory usage of seqkit. Usage: memusg [-t] command . Human genome $ seqkit stat hsa.fa file format type num_seqs sum_len min_len avg_len max_len hsa.fa FASTA DNA 194 3,099,750,718 970 15,978,096.5 248,956,422 Build FASTA index ( optional , when using flag -2 ( --two-pass ), some commands will automaticlly build it). For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files or stdin, FASTA index would be optional used for rapid acccess of sequences and reducing memory occupation. ATTENTION : the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools. SeqKit uses full sequence head instead of just ID as key. $ memusg -t seqkit faidx --id-regexp \"^(.+)$\" hsa.fa -o hsa.fa.seqkit.fai elapsed time: 10.011s peak rss: 177.21 MB Create common .fai file: $ memusg -t seqkit faidx hsa.fa -o hsa.fa.fai2 elapsed time: 10.454s peak rss: 172.82 MB Performance of samtools: $ memusg -t samtools faidx hsa.fa elapsed time: 9.574s peak rss: 1.45 MB Exactly same content: $ md5sum hsa.fa.fai* 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai 21e0c25b4d817d1c19ee8107191b9b31 hsa.fa.fai2 Sorting by sequence length $ memusg -t seqkit sort --by-length --reverse --two-pass hsa.fa > hsa.sorted.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs and lengths from FASTA index ... [INFO] 194 sequences loaded [INFO] sorting ... [INFO] output ... elapsed time: 4.892s peak rss: 500.15 MB Detail: $ seqkit fx2tab --length hsa.sorted.fa --name --only-id | cut -f 1,4 | more 1 248956422 2 242193529 3 198295559 4 190214555 5 181538259 6 170805979 7 159345973 X 156040895 8 145138636 9 138394717 11 135086622 10 133797422 12 133275309 13 114364328 14 107043718 15 101991189 16 90338345 17 83257441 18 80373285 20 64444167 19 58617616 Y 57227415 22 50818468 21 46709983 KI270728.1 1872759 KI270727.1 448248 ... real 0m10.697s user 0m11.153s sys 0m0.917s Shuffling sequences $ memusg -t seqkit shuffle hsa.fa --two-pass > hsa.shuffled.fa [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... elapsed time: 6.632s peak rss: 528.3 MB Spliting into files with single sequence $ memusg -t seqkit split --by-id hsa.fa --two-pass [INFO] split by ID. idRegexp: ^([^\\s]+)\\s? [INFO] create and read FASTA index ... [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] write 1 sequences to file: hsa.id_KI270743.1.fa [INFO] write 1 sequences to file: hsa.id_KI270706.1.fa [INFO] write 1 sequences to file: hsa.id_KI270717.1.fa [INFO] write 1 sequences to file: hsa.id_KI270718.1.fa [INFO] write 1 sequences to file: hsa.id_KI270468.1.fa ... elapsed time: 18.807s peak rss: 1.36 GB Geting subsequence of some chromesomes $ memusg -t seqkit subseq -r 1:10 --chr X --chr Y hsa.fa >X_1-10 X dna_sm:chromosome chromosome:GRCh38:X:1:156040895:1 REF nnnnnnnnnn >Y_1-10 Y dna_sm:chromosome chromosome:GRCh38:Y:2781480:56887902:1 REF NNNNNNNNNN elapsed time: 1.276s peak rss: 640.92 MB Geting CDS sequence of chr 1 by GTF files $ memusg -t seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr X --feature cds hsa.fa > chrX.gtf.cds.fa [INFO] read GTF file ... [INFO] 22420 GTF features loaded elapsed time: 8.643s peak rss: 846.14 MB","title":"Some manipulations on big genomes"},{"location":"tutorial/#remove-contaminated-reads","text":"Mapping with reads on some potential contaminate genomes, and get the reads IDs list. $ wc -l contaminate.list 244 contaminate.list $ head -n 2 contaminate.list HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 HWI-D00523:240:HF3WGBCXX:1:1101:12616:2205 Remove contaminated reads $ seqkit grep -f contaminate.list -v reads_1.fq.gz -o reads_1.clean.fq.gz $ seqkit grep -f contaminate.list -v reads_2.fq.gz -o reads_2.clean.fq.gz $ seqkit stat *.fq.gz file seq_format seq_type num_seqs min_len avg_len max_len reads_1.clean.fq.gz FASTQ DNA 2,256 226 227 229 reads_1.fq.gz FASTQ DNA 2,500 226 227 229 reads_2.clean.fq.gz FASTQ DNA 2,256 223 224 225 reads_2.fq.gz FASTQ DNA 2,500 223 224 225","title":"Remove contaminated reads"},{"location":"tutorial/#handling-of-aligned-sequences","text":"Some mock sequences (usually they will be much longer) $ cat seqs.fa >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG Run multiple sequence alignment (clustalo) clustalo -i seqs.fa -o seqs.msa.fa --force --outfmt fasta --threads=4 Convert FASTA format to tabular format. $ seqkit fx2tab seqs.msa.fa seq1 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG seq2 ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG or $ seqkit fx2tab seqs.msa.fa | cut -f 2 ACAACGTCTACTTACGTTGCAT----CGTCATGCTGCATTACGTAGTCTGATGATG ---------------ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG------------- ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG For me, it's useful when 1) manually assembling Sanger sequencing result, 2) designing site specific PCR primers. Remove gaps $ seqkit seq seqs.msa.fa -g >seq1 ACAACGTCTACTTACGTTGCATCGTCATGCTGCATTACGTAGTCTGATGATG >seq2 ACACCGTCTACTTTCATGCTGCATTACGTAGTCTGATGATG >seq3 ACAACGTCTACTTACGTTGCATCGTCATGCTGCACTGATGATG >seq4 ACAACGTCTACTTACGTTGCATCTTCGGTCATGCTGCATTACGTAGTCTGATGATG","title":"Handling of aligned sequences"},{"location":"tutorial/#play-with-mirna-hairpins","text":"","title":"Play with miRNA hairpins"},{"location":"tutorial/#dataset","text":"hairpin.fa.gz from The miRBase Sequence Database -- Release 21","title":"Dataset"},{"location":"tutorial/#quick-glance","text":"Sequence number $ seqkit stat hairpin.fa.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 First 10 bases $ zcat hairpin.fa.gz \\ | seqkit subseq -r 1:10 \\ | seqkit sort -s | seqkit seq -s \\ | head -n 10 AAAAAAAAAA AAAAAAAAAA AAAAAAAAAG AAAAAAAAAG AAAAAAAAAG AAAAAAAAAU AAAAAAAAGG AAAAAAACAU AAAAAAACGA AAAAAAAUUA hmm, nothing special, non-coding RNA~","title":"Quick glance"},{"location":"tutorial/#repeated-hairpin-sequences","text":"We may want to check how may identical hairpins among different species there are. seqkit rmdup could remove duplicated sequences by sequence content, and save the replicates to another file (here is duplicated.fa.gz ), as well as replicating details ( duplicated.detail.txt , 1th column is the repeated number, 2nd column contains sequence IDs seperated by comma). $ seqkit rmdup -s -i hairpin.fa.gz -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ head -n 5 duplicated.detail.txt 18 dre-mir-430c-1, dre-mir-430c-2, dre-mir-430c-3, dre-mir-430c-4, dre-mir-430c-5, dre-mir-430c-6, dre-mir-430c-7, dre-mir-430c-8, dre-mir-430c-9, dre-mir-430c-10, dre-mir-430c-11, dre-mir-430c-12, dre-mir-430c-13, dre-mir-430c-14, dre-mir-430c-15, dre-mir-430c-16, dre-mir-430c-17, dre-mir-430c-18 16 hsa-mir-29b-2, mmu-mir-29b-2, rno-mir-29b-2, ptr-mir-29b-2, ggo-mir-29b-2, ppy-mir-29b-2, sla-mir-29b, mne-mir-29b, ppa-mir-29b-2, bta-mir-29b-2, mml-mir-29b-2, eca-mir-29b-2, aja-mir-29b, oar-mir-29b-1, oar-mir-29b-2, rno-mir-29b-3 15 dme-mir-125, dps-mir-125, dan-mir-125, der-mir-125, dgr-mir-125-1, dgr-mir-125-2, dmo-mir-125, dpe-mir-125-2, dpe-mir-125-1, dpe-mir-125-3, dse-mir-125, dsi-mir-125, dvi-mir-125, dwi-mir-125, dya-mir-125 13 hsa-mir-19b-1, ggo-mir-19b-1, age-mir-19b-1, ppa-mir-19b-1, ppy-mir-19b-1, ptr-mir-19b-1, mml-mir-19b-1, sla-mir-19b-1, lla-mir-19b-1, mne-mir-19b-1, bta-mir-19b, oar-mir-19b, chi-mir-19b 13 hsa-mir-20a, ssc-mir-20a, ggo-mir-20a, age-mir-20, ppa-mir-20, ppy-mir-20a, ptr-mir-20a, mml-mir-20a, sla-mir-20, lla-mir-20, mne-mir-20, bta-mir-20a, eca-mir-20a The result shows the most conserved miRNAs among different species, mir-29b , mir-125 , mir-19b-1 and mir-20a . And the dre-miR-430c has the most multicopies in Danio rerio .","title":"Repeated hairpin sequences"},{"location":"tutorial/#hairpins-in-different-species","text":"Before spliting by species, let's take a look at the sequence names. $ seqkit seq hairpin.fa.gz -n | head -n 3 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop The first three letters (e.g. cel ) are the abbreviation of species names. So we could split hairpins by the first letters by defining custom sequence ID parsing regular expression ^([\\w]+)\\- . By default, seqkit takes the first non-space letters as sequence ID. For example, FASTA head ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . Split sequences by species. A custom ID parsing regular expression is used, ^([\\w]+)\\- . $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" --two-pass To reduce memory usage when splitting big file, we should always use flag --two-pass Species with most miRNA hairpins. Third column is the sequences number. $ cd hairpin.fa.gz.split/; $ seqkit stat hairpin.id_* \\ | csvtk space2tab \\ | csvtk -t sort -k num_seqs:nr \\ | csvtk -t pretty \\ | more file format type num_seqs sum_len min_len avg_len max_len hairpin.id_hsa.fasta FASTA RNA 1,881 154,242 82 82 82 hairpin.id_mmu.fasta FASTA RNA 1,193 107,370 90 90 90 hairpin.id_bta.fasta FASTA RNA 808 61,408 76 76 76 hairpin.id_gga.fasta FASTA RNA 740 42,180 57 57 57 hairpin.id_eca.fasta FASTA RNA 715 89,375 125 125 125 hairpin.id_mtr.fasta FASTA RNA 672 231,840 345 345 345 Here, a CSV/TSV tool csvtk is used to sort and view the result. For human miRNA hairpins Length distribution. seqkit fx2tab could show extra information like sequence length, GC content. csvtk is used to plot. $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot hist --xlab Length --title \"Human pre-miRNA length distribution\" $ seqkit grep -r -p '^hsa' hairpin.fa.gz \\ | seqkit fx2tab -l \\ | cut -f 4 \\ | csvtk -H plot box --xlab Length --horiz --height 1.5","title":"Hairpins in different species"},{"location":"tutorial/#bacteria-genome","text":"","title":"Bacteria genome"},{"location":"tutorial/#dataset_1","text":"Pseudomonas aeruginosa PAO1 , files: Genbank file PAO1.gb Genome FASTA file PAO1.fasta GTF file PAO1.gtf was created with extract_features_from_genbank_file.py , by extract_features_from_genbank_file.py PAO1.gb -t . -f gtf > PAO1.gtf","title":"Dataset"},{"location":"tutorial/#motif-distribution","text":"Motifs $ cat motifs.fa >GTAGCGS GTAGCGS >GGWGKTCG GGWGKTCG Sliding. Remember flag --id-ncbi , do you? By the way, do not be scared by the long flag --circle-genome , --step and so on. They have short ones, -c , -s $ seqkit sliding --id-ncbi --circular-genome \\ --step 20000 --window 200000 PAO1.fasta -o PAO1.fasta.sliding.fa $ seqkit stat PAO1.fasta.sliding.fa file format type num_seqs sum_len min_len avg_len max_len PAO1.fasta.sliding.fa FASTA DNA 314 62,800,000 200,000 200,000 200,000 Locating motifs $ seqkit locate --id-ncbi --ignore-case --degenerate \\ --pattern-file motifs.fa PAO1.fasta.sliding.fa -o PAO1.fasta.sliding.fa.motifs.tsv Ploting distribution ( plot_motif_distribution.R ) # preproccess $ perl -ne 'if (/_sliding:(\\d+)-(\\d+)\\t(.+)/) {$loc= $1 + 100000; print \"$loc\\t$3\\n\";} else {print}' PAO1.fasta.sliding.fa.motifs.tsv > PAO1.fasta.sliding.fa.motifs.tsv2 # plot $ ./plot_motif_distribution.R Result","title":"Motif distribution"},{"location":"tutorial/#find-multicopy-genes","text":"Get all CDS sequences $ seqkit subseq --id-ncbi --gtf PAO1.gtf --feature cds PAO1.fasta -o PAO1.cds.fasta $ seqkit stat *.fasta file format type num_seqs sum_len min_len avg_len max_len PAO1.cds.fasta FASTA DNA 5,572 5,593,306 72 1,003.8 16,884 PAO1.fasta FASTA DNA 1 6,264,404 6,264,404 6,264,404 6,264,404 Get duplicated sequences $ seqkit rmdup --by-seq --ignore-case PAO1.cds.fasta -o PAO1.cds.uniq.fasta \\ --dup-seqs-file PAO1.cds.dup.fasta --dup-num-file PAO1.cds.dup.text $ cat PAO1.cds.dup.text 6 NC_002516.2_500104:501120:-, NC_002516.2_2556948:2557964:+, NC_002516.2_3043750:3044766:-, NC_002516.2_3842274:3843290:-, NC_002516.2_4473623:4474639:+, NC_002516.2_5382796:5383812:- 2 NC_002516.2_2073555:2075438:+, NC_002516.2_4716660:4718543:+ 2 NC_002516.2_2072935:2073558:+, NC_002516.2_4716040:4716663:+ 2 NC_002516.2_2075452:2076288:+, NC_002516.2_4718557:4719393:+","title":"Find multicopy genes"},{"location":"tutorial/#flanking-sequences","text":"Get CDS and 1000 bp upstream sequence $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 Get 1000 bp upstream sequence of CDS, NOT including CDS. $ seqkit subseq --id-ncbi --gtf PAO1.gtf \\ --feature cds PAO1.fasta --up-stream 1000 --only-flank /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Flanking sequences"},{"location":"usage/","text":"Usage and Examples Quick Guide Basic: seq , stats , sum , subseq , sliding , faidx , watch , sana , scat Format conversion: fq2fa , fa2fq , fx2tab , tab2fx , convert , translate Searching: grep , locate , amplicon , fish Set operation: sample , rmdup , common , duplicate , split , split2 , head , head-genome , range , pair Edit: concat , replace , restart , mutate , rename Ordering: sort , shuffle BAM processing: bam Technical details and guides for use FASTA/Q format parsing and writing Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0 . Bzip2 format is supported since v2.4.0 . SeqKit uses the author's lightweight and high-performance bioinformatics package bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Notes: seqkit uses 4 threads by default. seqkit_t1 uses 1 thread. seqtk is single-threaded. seqtk+gzip : seqtk pipes data to the single-threaded gzip . seqtk+pigz : seqtk pipes data to the multithreaded pigz which uses 4 threads here. Input and output files Seqkit accepts input data from standard input (STDIN) and plain or gzip-compressed files. Files can be given via positional arguments or the flag --infile-list . For example: seqkit seq a.fasta b.fasta seqkit seq --infile-list file-list.txt seqkit seq --infile-list <(find -name \"*.fq.gz\" directory) Result are printed to standard ouput (STDOUT) by default, you can also specify the output file via the flag -o/--out-file . The file name extension .gz is automatically recognized. For example: seqkit seq a.fasta -o a.fasta.gz seqkit grep -f IDs.txt read_1.fq.gz -o dir/read_1.fq.gz Seqkit utlizies the pgzip package to read and write gzip file, and the outputted gzip file would be slighty larger than files generated by GNU gzip . Seqkit writes gzip files very fast, much faster than the multi-threaded pigz , so there's no need to pipe the result to gzip / pigz . Sequence formats and types SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx and bam can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked. Sequence ID By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" . FASTA index For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key. Parallelization of CPU intensive jobs The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The pgzip package reads and write gzip files in parallel. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 4). Using four threads is fast enough for most commands where FASTA/Q reading and writing is the performance bottleneck, and using more threads will not increase the speed . Few commands could benefit from multiple (>4) threads: stats scat grep -s -m locate -s -m amplicon -s -m Memory occupation Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation. Reproducibility Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed. seqkit SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Version: 2.4.0 Author: Wei Shen <shenwei356@gmail.com> Documents : http://bioinf.shenwei.me/seqkit Source code: https://github.com/shenwei356/seqkit Please cite: https://doi.org/10.1371/journal.pone.0163962 Seqkit utlizies the pgzip (https://github.com/klauspost/pgzip) package to read and write gzip file, and the outputted gzip file would be slighty larger than files generated by GNU gzip. Seqkit writes gzip files very fast, much faster than the multi-threaded pigz, therefore there's no need to pipe the result to gzip/pigz. Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0. Bzip2 format is supported since v2.4.0. Compression level: format range default comment gzip 1-9 5 https://github.com/klauspost/pgzip sets 5 as the default value. xz NA NA https://github.com/ulikunitz/xz does not support. zstd 1-4 2 roughly equals to zstd 1, 3, 7, 11, respectively. bzip 1-9 6 https://github.com/dsnet/compress Usage: seqkit [command] Available Commands: amplicon extract amplicon (or specific region around it) via primer(s) bam monitoring and online histograms of BAM record features common find common sequences of multiple files by id/name/sequence concat concatenate sequences with the same ID from multiple files convert convert FASTQ quality encoding between Sanger, Solexa and Illumina duplicate duplicate sequences N times fa2fq retrieve corresponding FASTQ records by a FASTA file faidx create FASTA index file and extract subsequence fish look for short sequences in larger sequences using local alignment fq2fa convert FASTQ to FASTA fx2tab convert FASTA/Q to tabular format (and length, GC content, average quality...) genautocomplete generate shell autocompletion script (bash|zsh|fish|powershell) grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed head print first N FASTA/Q records head-genome print sequences of the first genome with common prefixes in name locate locate subsequences/motifs, mismatch allowed mutate edit sequence (point mutation, insertion, deletion) pair match up paired-end reads from two fastq files range print FASTA/Q records in a range (start:end) rename rename duplicated IDs replace replace name/sequence by regular expression restart reset start position for circular genome rmdup remove duplicated sequences by ID/name/sequence sample sample sequences by number or proportion sana sanitize broken single line FASTQ files scat real time recursive concatenation and streaming of fastx files seq transform sequences (extract ID, filter by length, remove gaps, reverse complement...) shuffle shuffle sequences sliding extract subsequences in sliding windows sort sort sequences by id/name/sequence/length split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) stats simple statistics of FASTA/Q files subseq get subsequences by region/gtf/bed, including flanking sequences sum compute message digest for all sequences in FASTA/Q files tab2fx convert tabular format to FASTA/Q format translate translate DNA/RNA to protein sequence (supporting ambiguous bases) version print version information and check for update watch monitoring and online histograms of sequence features Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --compress-level int compression level for gzip, zstd, xz and bzip2. type \"seqkit -h\" for the range and default value for each format (default -1) -h, --help help for seqkit --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") --infile-list string file of input files list (one file per line), if given, they are appended to files from cli arguments -w, --line-width int line width when outputting FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. can also set with environment variable SEQKIT_THREADS) (default 4) Use \"seqkit [command] --help\" for more information about a command. Datasets Datasets from The miRBase Sequence Database -- Release 21 hairpin.fa.gz mature.fa.gz miRNA.diff.gz Human genome from ensembl (For seqkit subseq ) Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz Homo_sapiens.GRCh38.84.gtf.gz Homo_sapiens.GRCh38.84.bed.gz is converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command zcat Homo_sapiens.GRCh38.84.gtf.gz \\ | gtf2bed --do-not-sort \\ | gzip -c > Homo_sapiens.GRCh38.84.bed.gz Only DNA and gtf/bed data of Chr1 were used: chr1.fa.gz seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz chr1.gtf.gz zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c > chr1.gtf.gz chr1.bed.gz zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c > chr1.bed.gz seq Usage transform sequences (extract ID, filter by length, remove gaps, reverse complement...) Usage: seqkit seq [flags] Flags: -k, --color colorize sequences - to be piped into \"less -R\" -p, --complement complement sequence, flag '-v' is recommended to switch on --dna2rna DNA to RNA -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for seq -l, --lower-case print sequences in lower case -M, --max-len int only print sequences shorter than or equal to the maximum length (-1 for no limit) (default -1) -R, --max-qual float only print sequences with average quality less than this limit (-1 for no limit) (default -1) -m, --min-len int only print sequences longer than or equal to the minimum length (-1 for no limit) (default -1) -Q, --min-qual float only print sequences with average quality qreater or equal than this limit (-1 for no limit) (default -1) -n, --name only print names -i, --only-id print ID instead of full head -q, --qual only print qualities -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -g, --remove-gaps remove gaps -r, --reverse reverse sequence --rna2dna RNA to DNA -s, --seq only print sequences -u, --upper-case print sequences in upper case -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Read and print From file: $ seqkit seq hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA $ seqkit seq reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII From stdin: zcat hairpin.fa.gz | seqkit seq Sequence types By default, seqkit seq automatically detect the sequence type $ echo -e \">seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA DNA 1 28 28 28 28 $ echo -e \">seq\\nACGUN ACGUN\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1 11 11 11 11 $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA Protein 1 23 23 23 23 $ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTQ DNA 1 6 6 6 6 You can also set sequence type by flag -t ( --seq-type ). But this only take effect on subcommands seq and locate . $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna [INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on [ERRO] error when parsing seq: seq (invalid DNAredundant letter: e) Only print names Full name: $ seqkit seq hairpin.fa.gz -n cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop Only ID: $ seqkit seq hairpin.fa.gz -n -i cel-let-7 cel-lin-4 cel-mir-1 Custom ID region by regular expression (this could be applied to all subcommands): $ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\" MI0000001 MI0000002 MI0000003 Only print seq (global flag -w defines the output line width, 0 for no wrap) $ seqkit seq hairpin.fa.gz -s -w 0 UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU Convert multi-line FASTQ to 4-line FASTQ $ seqkit seq reads_1.fq.gz -w 0 Reverse comlement sequence $ seqkit seq hairpin.fa.gz -r -p >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA Remove gaps and to lower/upper case $ echo -e \">seq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u >seq ACGTACTGCACC RNA to DNA $ echo -e \">seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna >seq TCATATGCTTGTCTCAAAGATTA Filter by sequence length $ cat hairpin.fa | seqkit seq | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 28,645 2,949,871 39 103 2,354 $ cat hairpin.fa | seqkit seq -m 100 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,975 1,565,486 100 142.6 2,354 $ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,972 1,560,270 100 142.2 938 subseq Usage get subsequences by region/gtf/bed, including flanking sequences. Attentions: 1. Use \"seqkit grep\" for extract subsets of sequences. \"seqtk subseq seqs.fasta id.txt\" equals to \"seqkit grep -f id.txt seqs.fasta\" Recommendation: 1. Use plain FASTA file, so seqkit could utilize FASTA index. 2. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit subseq [flags] Flags: --bed string by tab-delimited BED file --chr strings select limited sequence with sequence IDs when using --gtf or --bed (multiple value supported, case ignored) -d, --down-stream int down stream length --feature strings select limited feature types (multiple value supported, case ignored, only works with GTF) --gtf string by GTF (version 2.2) file --gtf-tag string output this tag as sequence comment (default \"gene_id\") -h, --help help for subseq -f, --only-flank only return up/down stream sequence -r, --region string by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \"seqkit subseq -h\" for more examples -u, --up-stream int up stream length -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. First 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 1:12 Last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r -12:-1 Subsequences without first and last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 13:-13 Get subsequence by GTF file $ cat t.fa >seq actgACTGactgn $ cat t.gtf seq test CDS 5 8 . . . gene_id \"A\"; transcript_id \"\"; seq test CDS 5 8 . - . gene_id \"B\"; transcript_id \"\"; $ seqkit subseq --gtf t.gtf t.fa >seq_5:8:. A ACTG >seq_5:8:- B CAGT Human genome example: AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. We could specify chromesomes and features. $ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa > chr1.gtf.cds.fa $ seqkit stats chr1.gtf.cds.fa file format type num_seqs sum_len min_len avg_len max_len chr1.gtf.cds.fa FASTA DNA 65,012 9,842,274 1 151.4 12,045 Get CDS and 3bp up-stream sequences $ seqkit subseq --gtf t.gtf t.fa -u 3 >seq_5:8:._us:3 A ctgACTG >seq_5:8:-_us:3 B agtCAGT Get 3bp up-stream sequences of CDS, not including CDS $ seqkit subseq --gtf t.gtf t.fa -u 3 -f >seq_5:8:._usf:3 A ctg >seq_5:8:-_usf:3 B agt Get subsequences by BED file. AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ > chr1.bed.gz.fa We may need to remove duplicated sequences $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ | seqkit rmdup > chr1.bed.rmdup.fa [INFO] 141060 duplicated records removed Summary: $ seqkit stats chr1.gz.*.gz file seq_format seq_type num_seqs min_len avg_len max_len chr1.gz.fa FASTA DNA 231,974 1 3,089.5 1,551,957 chr1.gz.rmdup.fa FASTA DNA 90,914 1 6,455.8 1,551,957 sliding Usage extract subsequences in sliding windows Usage: seqkit sliding [flags] Flags: -c, --circular circular genome (same to -C/--circular-genome) -C, --circular-genome circular genome (same to -c/--circular) -g, --greedy greedy mode, i.e., exporting last subsequences even shorter than windows size -h, --help help for sliding -s, --step int step size -S, --sufix string suffix added to the sequence ID -W, --window int window size Examples General use $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN Greedy mode $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-12 gtNN >seq_sliding:10-15 N Circular genome $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-2 gtNNAC >seq_sliding:10-5 NACGTa Generate GC content for ploting $ zcat hairpin.fa.gz \\ | seqkit sliding -s 5 -W 30 \\ | seqkit fx2tab -n -g cel-let-7_sliding:1-30 50.00 cel-let-7_sliding:6-35 46.67 cel-let-7_sliding:11-40 43.33 cel-let-7_sliding:16-45 36.67 cel-let-7_sliding:21-50 33.33 cel-let-7_sliding:26-55 40.00 ... stats Usage simple statistics of FASTA/Q files Columns: 1. file input file, \"-\" for STDIN 2. format FASTA or FASTQ 3. type DNA, RNA, Protein or Unlimit 4. num_seqs number of sequences 5. sum_len number of bases or residues , with gaps or spaces counted 6. min_len minimal sequence length , with gaps or spaces counted 7. avg_len average sequence length , with gaps or spaces counted 8. max_len miximal sequence length , with gaps or spaces counted 9. Q1 first quartile of sequence length , with gaps or spaces counted 10. Q2 median of sequence length , with gaps or spaces counted 11. Q3 third quartile of sequence length , with gaps or spaces counted 12. sum_gap number of gaps 13. N50 N50. https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics#N50 14. Q20(%) percentage of bases with the quality score greater than 20 15. Q30(%) percentage of bases with the quality score greater than 30 16. GC(%) percentage of GC content Attentions: 1. Sequence length metrics (sum_len, min_len, avg_len, max_len, Q1, Q2, Q3) count the number of gaps or spaces. You can remove them with \"seqkit seq -g\": seqkit seq -g input.fasta | seqkit stats Tips: 1. For lots of small files (especially on SDD), use big value of '-j' to parallelize counting. 2. Extract one metric with csvtk (https://github.com/shenwei356/csvtk): seqkit stats -Ta input.fastq.gz | csvtk cut -t -f \"Q30(%)\" | csvtk del-header Usage: seqkit stats [flags] Aliases: stats, stat Flags: -a, --all all statistics, including quartiles of seq length, sum_gap, N50 -b, --basename only output basename of files -E, --fq-encoding string fastq quality encoding. available values: 'sanger', 'solexa', 'illumina-1.3+', 'illumina-1.5+', 'illumina-1.8+'. (default \"sanger\") -G, --gap-letters string gap letters (default \"- .\") -h, --help help for stats -e, --skip-err skip error, only show warning message -i, --stdin-label string label for replacing default \"-\" for stdin (default \"-\") -T, --tabular output in machine-friendly tabular format Eexamples General use $ seqkit stats *.f{a,q}.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Machine-friendly tabular format $ seqkit stats *.f{a,q}.gz -T file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # So you can process the result with tools like csvtk: http://bioinf.shenwei.me/csvtk $ seqkit stats *.f{a,q}.gz -T | csvtk pretty -t file format type num_seqs sum_len min_len avg_len max_len ----------------- ------ ---- -------- ------- ------- ------- ------- hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # To markdown $ seqkit stats *.f{a,q}.gz -T | csvtk csv2md -t |file |format|type|num_seqs|sum_len|min_len|avg_len|max_len| |:----------------|:-----|:---|:-------|:------|:------|:------|:------| |hairpin.fa.gz |FASTA |RNA |28645 |2949871|39 |103.0 |2354 | |mature.fa.gz |FASTA |RNA |35828 |781222 |15 |21.8 |34 | |Illimina1.8.fq.gz|FASTQ |DNA |10000 |1500000|150 |150.0 |150 | |reads_1.fq.gz |FASTQ |DNA |2500 |567516 |226 |227.0 |229 | |reads_2.fq.gz |FASTQ |DNA |2500 |560002 |223 |224.0 |225 | file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 Extra information $ seqkit stats *.f{a,q}.gz -a file format type num_seqs sum_len min_len avg_len max_len Q1 Q2 Q3 sum_gap N50 Q20(%) Q30(%) GC(%) hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 76 91 111 0 101 0 0 45.77 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 21 22 22 0 22 0 0 47.6 Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 75 150 75 0 150 96.16 89.71 49.91 nanopore.fq.gz FASTQ DNA 4,000 1,798,723 153 449.7 6,006 271 318 391 0 395 40.79 12.63 46.66 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 227 227 227 0 227 91.24 86.62 53.63 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 224 224 224 0 224 91.06 87.66 54.77 Parallelize counting files, it's much faster for lots of small files, especially for files on SSD seqkit stats -j 10 refseq/virual/*.fna.gz Skip error $ seqkit stats tests/* [ERRO] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format $ seqkit stats tests/* -e [WARN] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format [WARN] tests/hairpin.fa.seqkit.fai: fastx: invalid FASTA/Q format [WARN] tests/miRNA.diff.gz: fastx: invalid FASTA/Q format [WARN] tests/test.sh: fastx: invalid FASTA/Q format file format type num_seqs sum_len min_len avg_len max_len tests/contigs.fa FASTA DNA 9 54 2 6 10 tests/hairpin.fa FASTA RNA 28,645 2,949,871 39 103 2,354 tests/Illimina1.5.fq FASTQ DNA 1 100 100 100 100 tests/Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 tests/hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 tests/reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 tests/mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 tests/reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Output basename instead of full path ( -b/--basename ) sum Usage compute message digest for all sequences in FASTA/Q files Attentions: 1. Sequence headers and qualities are skipped, only sequences matter. 2. The order of sequences records does not matter. 3. Circular complete genomes are supported with the flag -c/--circular. - The same double-stranded genomes with different start positions or in reverse complement strand will not affect the result. - For single-stranded genomes like ssRNA genomes, use -s/--single-strand. - The message digest would change with different values of k-mer size. 4. Multiple files are processed in parallel (-j/--threads). Method: 1. Converting the sequences to low cases, optionally removing gaps (-g). 2. Computing the hash (xxhash) for all sequences or k-mers of a circular complete genome (-c/--circular). 3. Sorting all hash values, for ignoring the order of sequences. 4. Computing MD5 digest from the hash values, sequences length, and the number of sequences. Following the seqhash in Poly (https://github.com/TimothyStiles/poly/), We add meta information to the message digest, with the format of: seqkit.<version>_<seq type><seq structure><strand>_<kmer size>_<seq digest> <version>: digest version <seq type>: 'D' for DNA, 'R' for RNA, 'P' for protein, 'N' for others <seq structure>: 'L' for linear sequence, 'C' for circular genome <strand>: 'D' for double-stranded, 'S' for single-stranded <kmer size>: 0 for linear sequence, other values for circular genome Examples: seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94 DNA.fq.gz seqkit.v0.1_PLS_k0_c244954e4960dd2a1409cd8ee53d92b9 Protein.fasta seqkit.v0.1_RLS_k0_0f1fb263f0c05a259ae179a61a80578d single-stranded RNA.fasta seqkit.v0.1_DCD_k31_e59dad6d561f1f1f28ebf185c6f4c183 double-stranded-circular DNA.fasta seqkit.v0.1_DCS_k31_dd050490cd62ea5f94d73d4d636b7d60 single-stranded-circular DNA.fasta Usage: seqkit sum [flags] Flags: -a, --all show all information, including the sequences length and the number of sequences -b, --basename only output basename of files -c, --circular the file contains a single cicular genome sequence -G, --gap-letters string gap letters (default \"- \\t.*\") -h, --help help for sum -k, --kmer-size int k-mer size for processing circular genomes (default 1000) -g, --remove-gaps remove gaps --rna2dna convert RNA to DNA -s, --single-strand only consider the positive strand of a circular genome, e.g., ssRNA virus genomes Examples: A, B, C, D are the same vircular genomes with different starting positions or strands: $ cat virus-{A,B,C,D}.fasta >seq TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA >seq.revcom TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA >seq.new-start GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT >seq.revcom.new-start TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT # cat to one file $ cat virus-{A,B,C,D}.fasta > virues.fasta # shuffle and rename $ cat virus-{A,B,C,D}.fasta \\ | seqkit shuffle \\ | seqkit replace -p '.*' -r '{nr}' \\ | tee virues.shuffled.fasta >1 TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT >2 TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA >3 GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT >4 TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA Sum of all files (the sequences order does not matter): $ seqkit sum viru*.fasta seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17 virues.fasta seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17 virues.shuffled.fasta seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94 virus-A.fasta seqkit.v0.1_DLS_k0_7a813339f9ae686b376b1df55cd596ca virus-B.fasta seqkit.v0.1_DLS_k0_0fd51028bfbfa85ddbdd2b86ef7bd1c1 virus-C.fasta seqkit.v0.1_DLS_k0_88b1d20dd0fe0dbf41c00b075fee4e4e virus-D.fasta Circular genomes (the same genomes with different start positions or in reverse complement strand will not affect the result): $ seqkit sum -c -k 21 virus-*.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-A.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-B.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-C.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-D.fasta $ seqkit sum -c -k 51 virus-*.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-A.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-B.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-C.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-D.fasta # collect files with the same genomes $ seqkit sum -c -k 51 virus-*.fasta | csvtk fold -Ht -f 1 -v 2 seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-A.fasta; virus-B.fasta; virus-C.fasta; virus-D.fasta faidx Usage create FASTA index file and extract subsequence This command is similar with \"samtools faidx\" but has some extra features: 1. output full header line with the flag -f 2. support regular expression as sequence ID with the flag -r 3. if you have large number of IDs, you can use: seqkit faidx seqs.fasta -l IDs.txt Attentions: 1. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit faidx [flags] <fasta-file> [regions...] Flags: -f, --full-head print full header line instead of just ID. New fasta index file ending with .seqkit.fai will be created -h, --help help for faidx -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -l, --region-file string file containing a list of regions -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed -r, --use-regexp IDs are regular expression. But subseq region is not supported here. Example common usage like samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 >hsa-let-7a-1 UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU output full header, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 -f >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU extract subsequence of specific region $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1-10 >hsa-let-7a-1:1-10 UGGGAUGAGG $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:-10--1 >hsa-let-7a-1:-10--1 GUCUUUCCUA $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1 >hsa-let-7a-1:1-1 U supporting begin > start , i.e., returning reverse complement sequence, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:10-1 >hsa-let-7a-1:10-1 CCUCAUCCCA use regular expression $ seqkit faidx tests/hairpin.fa hsa -r | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,881 154,002 41 81.9 180 watch Usage monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields, available values: ReadLen, MeanQual, GC, GCSkew (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Histogram of sequence length seqkit watch --fields ReadLen nanopore.fq.gz -O len.png Dynamic histogram of log sequence length seqkit watch --log --fields ReadLen nanopore.fq.gz Histogram of mean base qualities every 500 record, also saved as png seqkit watch -p 500 -O qhist.png -f MeanQual nanopore.fq.gz sana Usage sanitize broken single line FASTQ files Usage: seqkit sana [flags] Flags: -A, --allow-gaps allow gap character (-) in sequences -i, --format string input and output format: fastq or fasta (default \"fastq\") -h, --help help for sana -I, --in-format string input format: fastq or fasta -O, --out-format string output format: fastq or fasta -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq.gz -o rescued.fq.gz scat Usage real time recursive concatenation and streaming of fastx files Usage: seqkit scat [flags] Flags: -A, --allow-gaps allow gap character (-) in sequences -d, --delta int minimum size increase in kilobytes to trigger parsing (default 5) -D, --drop-time string Notification drop interval (default \"500ms\") -f, --find-only concatenate exisiting files and quit -i, --format string input and output format: fastq or fasta (fastq) (default \"fastq\") -g, --gz-only only look for gzipped files (.gz suffix) -h, --help help for scat -I, --in-format string input format: fastq or fasta (fastq) -O, --out-format string output format: fastq or fasta -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -r, --regexp string regexp for watched files, by default guessed from the input format -T, --time-limit string quit after inactive for this time period -p, --wait-pid int after process with this PID exited (default -1) Examples Concatenate all fastq files recursively under a directory seqkit scat -j 4 -f fastq_dir > all_records.fq Watch a directory and stream fastq records in real time until interrupt is recieved and plot read lengths using seqkit watch : seqkit scat -j 4 fastq_dir | seqkit watch -f ReadLen - Watch a directory and stream fastq records in real time until there is no write activity under the directory for 5 seconds: seqkit scat -j 4 -T \"5s\" fastq_dir > all_records.fq Watch a directory and stream fastq records in real time until a process with a specified PID is alive: seqkit scat -j 4 -p $PID fastq_dir > all_records.fq Notes : You might need to increase the ulimit allowance on open files if you intend to stream fastx records from a large number of files. fq2fa Usage convert FASTQ to FASTA Usage: seqkit fq2fa [flags] Examples seqkit fq2fa reads_1.fq.gz -o reads_1.fa.gz fa2fq Usage retrieve corresponding FASTQ records by a FASTA file Attention: 1. We assume the FASTA file comes from the FASTQ file, so they share sequence IDs, and sequences in FASTA should be subseq of sequences in FASTQ file. Usage: seqkit fa2fq [flags] Flags: -f, --fasta-file string FASTA file) -h, --help help for fa2fq -P, --only-positive-strand only search on positive strand fx2tab & tab2fx Usage (fx2tab) convert FASTA/Q to tabular format, and provide various information, like sequence length, GC content/GC skew. Attention: 1. Fixed three columns (ID, sequence, quality) are outputted for either FASTA or FASTQ, except when flag -n/--name is on. This is for format compatibility. Usage: seqkit fx2tab [flags] Flags: -a, --alphabet print alphabet letters -q, --avg-qual print average quality of a read -B, --base-content strings print base content. (case ignored, multiple values supported) e.g. -B AT -B N -C, --base-count strings print base count. (case ignored, multiple values supported) e.g. -C AT -C N -I, --case-sensitive calculate case sensitive base content/sequence hash -g, --gc print GC content -G, --gc-skew print GC-Skew -H, --header-line print header line -h, --help help for fx2tab -l, --length print sequence length -n, --name only print names (no sequences and qualities) -Q, --no-qual only output two column even for FASTQ file -i, --only-id print ID instead of full head -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -s, --seq-hash print hash (MD5) of sequence Usage (tab2fx) convert tabular format (first two/three columns) to FASTA/Q format Usage: seqkit tab2fx [flags] Flags: -b, --buffer-size string size of buffer, supported unit: K, M, G. You need increase the value when \"bufio.Scanner: token too long\" error reported (default \"1G\") -p, --comment-line-prefix strings comment line prefix (default [#,//]) -h, --help help for tab2fx Examples Default output $ seqkit fx2tab hairpin.fa.gz | head -n 2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU Print sequence length, GC content, and only print names (no sequences), we could also print title line by flag -H . $ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '&' pretty #name seq qual length GC cel-let-7 99 43.43 cel-lin-4 94 54.26 cel-mir-1 96 40.62 Use fx2tab and tab2fx in pipe $ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx $ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx Sort sequences by length (use seqkit sort -l ) $ zcat hairpin.fa.gz \\ | seqkit fx2tab -l \\ | sort -t\"`echo -e '\\t'`\" -n -k4,4 \\ | seqkit tab2fx >cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop UUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC >mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop UGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU >cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop ACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU $ seqkit sort -l hairpin.fa.gz Sorting or filtering by GC (or other base by -flag -B ) content could also achieved in similar way. Get first 1000 sequences (use seqkit head -n 1000 ) $ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx $ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx Extension After converting FASTA to tabular format with seqkit fx2tab , it could be handled with CSV/TSV tools, e.g. csvtk , a cross-platform, efficient and practical CSV/TSV toolkit csvtk grep could be used to filter sequences (similar with seqkit grep ) csvtk inter computates intersection of multiple files. It could achieve similar function as seqkit common -n along with shell. csvtk join joins multiple CSV/TSV files by multiple IDs. convert Usage convert FASTQ quality encoding between Sanger, Solexa and Illumina Usage: seqkit convert [flags] Flags: -d, --dry-run dry run -f, --force for Illumina-1.8+ -> Sanger, truncate scores > 40 to 40 --from string source quality encoding. if not given, we'll guess it -h, --help help for convert -n, --nrecords int number of records for guessing quality encoding (default 1000) -N, --thresh-B-in-n-most-common int threshold of 'B' in top N most common quality for guessing Illumina 1.5. (default 2) -F, --thresh-illumina1.5-frac float threshold of faction of Illumina 1.5 in the leading N records (default 0.1) --to string target quality encoding (default \"Sanger\") Examples: Note that seqkit convert always output sequences. The test dataset contains score 41 ( J ): $ seqkit head -n 1 tests/Illimina1.8.fq.gz @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< By default, nothing changes when converting Illumina 1.8 to Sanger. A warning message show that source and target quality encoding match. $ seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger [WARN] source and target quality encoding match. @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< When switching flag --force on, J (41) was converted to I (40). $ seqkit convert tests/Illimina1.8.fq.gz -f | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAIFFFIII<IIIIIFFFIFIIIIIFIIAIIIFIIFIFIIIIFAFI<IA<FFI7FIIFIIAAIIII<IIIIIIIFIIIAIIIIIFII77<IIII-F7A-FIFFIIIIII<FFI-<7FIIIFII)A7)7AA<7--)<-7F-A7FA< Other cases: To Illumina-1.5. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iiiiieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[ To Illumina-1.5 and back to Sanger. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit convert | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + !AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< Checking encoding $ seqkit convert tests/Illimina1.8.fq.gz --from Solexa [INFO] converting Solexa -> Sanger [ERRO] seq: invalid Solexa quality Real Illumina 1.5+ data $ seqkit seq tests/Illimina1.5.fq @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + efcfffffcfeefffcffffffddf`feed]`]_Ba_^__[YBBBBBBBBBBRTT\\]][]dddd`ddd^dddadd^BBBBBBBBBBBBBBBBBBBBBBBB $ seqkit convert tests/Illimina1.5.fq | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + FGDGGGGGDGFFGGGDGGGGGGEEGAGFFE>A>@!B@?@@<:!!!!!!!!!!355=>><>EEEEAEEE?EEEBEE?!!!!!!!!!!!!!!!!!!!!!!!! translate Usage translate DNA/RNA to protein sequence (supporting ambiguous bases) Note: 1. This command supports codons containing any ambiguous base. Please switch on flag -L INT for details. e.g., for standard table: ACN -> T CCN -> P CGN -> R CTN -> L GCN -> A GGN -> G GTN -> V TCN -> S MGR -> R YTR -> L Translate Tables/Genetic Codes: # https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes 1: The Standard Code 2: The Vertebrate Mitochondrial Code 3: The Yeast Mitochondrial Code 4: The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code 5: The Invertebrate Mitochondrial Code 6: The Ciliate, Dasycladacean and Hexamita Nuclear Code 9: The Echinoderm and Flatworm Mitochondrial Code 10: The Euplotid Nuclear Code 11: The Bacterial, Archaeal and Plant Plastid Code 12: The Alternative Yeast Nuclear Code 13: The Ascidian Mitochondrial Code 14: The Alternative Flatworm Mitochondrial Code 16: Chlorophycean Mitochondrial Code 21: Trematode Mitochondrial Code 22: Scenedesmus obliquus Mitochondrial Code 23: Thraustochytrium Mitochondrial Code 24: Pterobranchia Mitochondrial Code 25: Candidate Division SR1 and Gracilibacteria Code 26: Pachysolen tannophilus Nuclear Code 27: Karyorelict Nuclear 28: Condylostoma Nuclear 29: Mesodinium Nuclear 30: Peritrich Nuclear 31: Blastocrithidia Nuclear Usage: seqkit translate [flags] Flags: -x, --allow-unknown-codon translate unknown code to 'X'. And you may not use flag --trim which removes 'X' -F, --append-frame append frame information to sequence ID --clean change all STOP codon positions from the '*' character to 'X' (an unknown residue) -f, --frame strings frame(s) to translate, available value: 1, 2, 3, -1, -2, -3, and 6 for all six frames (default [1]) -h, --help help for translate -M, --init-codon-as-M translate initial codon at beginning to 'M' -l, --list-transl-table int show details of translate table N, 0 for all (default -1) -L, --list-transl-table-with-amb-codons int show details of translate table N (including ambigugous codons), 0 for all. (default -1) -T, --transl-table int translate table/genetic code, type 'seqkit translate --help' for more details (default 1) --trim remove all 'X' and '*' characters from the right end of the translation Examples common usage $ seqkit translate tests/mouse-p53-cds.fna >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD* trim the * $ seqkit translate tests/mouse-p53-cds.fna --trim >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD different translate table $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --trim >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF different frame $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] SESNFSE*ITNNSYGKSKHKAPSPLIISFHFFYKFRI*LSY*ERSFCFISNCFIVI*LCF NSS*TFEDFSPCLFLH $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit seq -r -p \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF* show details of translate table 1 $ seqkit translate -l 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAT: N ACA: T, ACC: T, ACG: T, ACT: T AGA: R, AGC: S, AGG: R, AGT: S ATA: I, ATC: I, ATG: M, ATT: I CAA: Q, CAC: H, CAG: Q, CAT: H CCA: P, CCC: P, CCG: P, CCT: P CGA: R, CGC: R, CGG: R, CGT: R CTA: L, CTC: L, CTG: L, CTT: L GAA: E, GAC: D, GAG: E, GAT: D GCA: A, GCC: A, GCG: A, GCT: A GGA: G, GGC: G, GGG: G, GGT: G GTA: V, GTC: V, GTG: V, GTT: V TAA: *, TAC: Y, TAG: *, TAT: Y TCA: S, TCC: S, TCG: S, TCT: S TGA: *, TGC: C, TGG: W, TGT: C TTA: L, TTC: F, TTG: L, TTT: F show details of translate table 1, including ambigugous codons $ seqkit translate -L 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAR: K, AAT: N, AAY: N ACA: T, ACC: T, ACM: T, ACG: T, ACR: T, ACS: T, ACV: T, ACT: T, ACW: T, ACY: T, ACH: T, ACK: T, ACD: T, ACB: T, ACN: T AGA: R, AGC: S, AGG: R, AGR: R, AGT: S, AGY: S ATA: I, ATC: I, ATM: I, ATG: M, ATT: I, ATW: I, ATY: I, ATH: I CAA: Q, CAC: H, CAG: Q, CAR: Q, CAT: H, CAY: H CCA: P, CCC: P, CCM: P, CCG: P, CCR: P, CCS: P, CCV: P, CCT: P, CCW: P, CCY: P, CCH: P, CCK: P, CCD: P, CCB: P, CCN: P CGA: R, CGC: R, CGM: R, CGG: R, CGR: R, CGS: R, CGV: R, CGT: R, CGW: R, CGY: R, CGH: R, CGK: R, CGD: R, CGB: R, CGN: R CTA: L, CTC: L, CTM: L, CTG: L, CTR: L, CTS: L, CTV: L, CTT: L, CTW: L, CTY: L, CTH: L, CTK: L, CTD: L, CTB: L, CTN: L MGA: R, MGG: R, MGR: R GAA: E, GAC: D, GAG: E, GAR: E, GAT: D, GAY: D GCA: A, GCC: A, GCM: A, GCG: A, GCR: A, GCS: A, GCV: A, GCT: A, GCW: A, GCY: A, GCH: A, GCK: A, GCD: A, GCB: A, GCN: A GGA: G, GGC: G, GGM: G, GGG: G, GGR: G, GGS: G, GGV: G, GGT: G, GGW: G, GGY: G, GGH: G, GGK: G, GGD: G, GGB: G, GGN: G GTA: V, GTC: V, GTM: V, GTG: V, GTR: V, GTS: V, GTV: V, GTT: V, GTW: V, GTY: V, GTH: V, GTK: V, GTD: V, GTB: V, GTN: V TAA: *, TAC: Y, TAG: *, TAR: *, TAT: Y, TAY: Y TCA: S, TCC: S, TCM: S, TCG: S, TCR: S, TCS: S, TCV: S, TCT: S, TCW: S, TCY: S, TCH: S, TCK: S, TCD: S, TCB: S, TCN: S TGA: *, TGC: C, TGG: W, TGT: C, TGY: C TRA: * TTA: L, TTC: F, TTG: L, TTR: L, TTT: F, TTY: F YTA: L, YTG: L, YTR: L grep Usage search sequences by ID/name/sequence/sequence motifs, mismatch allowed Attentions: 0. By default, we match sequence ID with patterns, use \"-n/--by-name\" for matching full name instead of just ID. 1. Unlike POSIX/GNU grep, we compare the pattern to the whole target (ID/full header) by default. Please switch \"-r/--use-regexp\" on for partly matching. 2. When searching by sequences, it's partly matching, and both positive and negative strands are searched. Mismatch is allowed using flag \"-m/--max-mismatch\", you can increase the value of \"-j/--threads\" to accelerate processing. 3. Degenerate bases/residues like \"RYMM..\" are also supported by flag -d. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". 4. When providing search patterns (motifs) via flag '-p', please use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"' or -p \"\\\"A{2,}\\\"\". Because the command line argument parser accepts comma-separated-values (CSV) for multiple values (motifs). Patterns in file do not follow this rule. 5. The order of sequences in result is consistent with that in original file, not the order of the query patterns. But for FASTA file, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt 6. For multiple patterns, you can either set \"-p\" multiple times, i.e., -p pattern1 -p pattern2, or give a file of patterns via \"-f/--pattern-file\". You can specify the sequence region for searching with the flag -R (--region). The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit grep [flags] Flags: -n, --by-name match by full name instead of just ID -s, --by-seq search subseq on seq, both positive and negative strand are searched, and mismatch allowed using flag -m/--max-mismatch -c, --circular circular genome -C, --count just print a count of matching records. with the -v/--invert-match flag, count non-matching records -d, --degenerate pattern/motif contains degenerate base --delete-matched delete a pattern right after being matched, this keeps the firstly matched data and speedups when using regular expressions -h, --help help for grep -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -v, --invert-match invert the sense of matching, to select non-matching records -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -P, --only-positive-strand only search on positive strand -p, --pattern strings search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern file (one record per line) -R, --region string specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases -r, --use-regexp patterns are regular expression Examples Searching with list of sequence IDs (do not contain whitespace) $ seqkit grep -f id.txt seqs.fq.gz -o result.fq.gz # ignore case $ seqkit grep -i -f id.txt seqs.fq.gz -o result.fq.gz Just print the matched number, like GNU grep ( grep -c ) $ seqkit grep -f id.txt seqs.fq.gz -C Serching non-canonical sequence IDs, Using --id-regexp to capture IDs. Refer to section Sequence ID and seqkit seq for examples. Searching with list of sequence names (they may contain whitespace). $ seqkit grep -n -f name.txt seqs.fa.gz -o result.fa.gz Useq -r/--use-regexp for partly matching, but this may produce \"false positive\" matches . For example, seq_1 matches seq_10 with -nri . Extract human hairpins (i.e. sequences with name starting with hsa ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU Remove human and mice hairpins (invert match with -v ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v Extract new entries by information from miRNA.diff.gz Get IDs of new entries. $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 > list $ more list cfa-mir-486 cfa-mir-339-1 pmi-let-7 Extract by ID list file $ zcat hairpin.fa.gz | seqkit grep -f list > new.fa Extract sequences containing AGGCG $ cat hairpin.fa.gz | seqkit grep -s -i -p aggcg Circular genome $ echo -e \">seq\\nACGTTGCA\" >seq ACGTTGCA $ echo -e \">seq\\nACGTTGCA\" | seqkit grep -s -i -p AA $ echo -e \">seq\\nACGTTGCA\" | seqkit grep -s -i -p AA -c >seq ACGTTGCA Extract sequences containing AGGCG (allow mismatch) $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,181 145,789 49 123.4 2,354 real 0m0.058s user 0m0.100s sys 0m0.017s $ time zcat hairpin.fa.gz | seqkit grep -s -i -p aggcg -m 1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 22,290 2,375,819 39 106.6 2,354 real 0m1.081s user 0m1.305s sys 0m0.158s Extract sequences starting with AGGCG $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G. $ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA It's equal to but simpler than: $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA Specify sequence regions for searching. e.g., leading 30 bases. $ seqkit grep -s -R 1:30 -i -r -p GCTGG locate Usage locate subsequences/motifs, mismatch allowed Attentions: 1. Motifs could be EITHER plain sequence containing \"ACTGN\" OR regular expression like \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" for ORFs. 2. Degenerate bases/residues like \"RYMM..\" are also supported by flag -d. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". 3. When providing search patterns (motifs) via flag '-p', please use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"' or -p \"\\\"A{2,}\\\"\". Because the command line argument parser accepts comma-separated-values (CSV) for multiple values (motifs). Patterns in file do not follow this rule. 4. Mismatch is allowed using flag \"-m/--max-mismatch\", you can increase the value of \"-j/--threads\" to accelerate processing. 5. When using flag --circular, end position of matched subsequence that crossing genome sequence end would be greater than sequence length. Usage: seqkit locate [flags] Flags: --bed output in BED6 format -c, --circular circular genome. type \"seqkit locate -h\" for details -d, --degenerate pattern/motif contains degenerate base --gtf output in GTF format -h, --help help for locate -M, --hide-matched do not show matched sequences -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -G, --non-greedy non-greedy mode, faster but may miss motifs overlapping with others -P, --only-positive-strand only search on positive strand -p, --pattern strings pattern/motif (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern/motif file (FASTA format) -F, --use-fmi use FM-index for much faster search of lots of sequence patterns -r, --use-regexp patterns/motifs are regular expression -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Locating subsequences (mismatch allowed) $ cat t.fa >seq agctggagctacc $ cat t.fa \\ | seqkit locate -p agc \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # do not show matched sequences $ cat t.fa \\ | seqkit locate -p agc -M \\ | csvtk pretty -t seqID patternName pattern strand start end seq agc agc + 1 3 seq agc agc + 7 9 seq agc agc - 8 10 seq agc agc - 2 4 # max mismatch: 1 $ cat t.fa \\ | seqkit locate -p agc -m 1 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc + 11 13 acc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # max mismatch: 2 $ cat t.fa \\ | seqkit locate -p agc -m 2 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 4 6 tgg seq agc agc + 5 7 gga seq agc agc + 7 9 agc seq agc agc + 10 12 tac seq agc agc + 11 13 acc seq agc agc - 11 13 ggt seq agc agc - 8 10 agc seq agc agc - 6 8 ctc seq agc agc - 5 7 tcc seq agc agc - 2 4 agc Locate ORFs. $ zcat hairpin.fa.gz \\ | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" -r \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-lin-4 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 1 36 AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 54 95 AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 43 51 AUGAUAUAG Locate Motif. $ zcat hairpin.fa.gz \\ | seqkit locate -i -d -p AUGGACUN \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-mir-58a AUGGACUN AUGGACUN + 81 88 AUGGACUG ath-MIR163 AUGGACUN AUGGACUN - 122 129 AUGGACUC cel-mir-270 AUGGACUN AUGGACUN + 84 91 AUGGACUG Output in GTF or BED6 format, which you can use in seqkit subseq $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --bed cel-mir-58a 80 88 AUGGACUN 0 + ath-MIR163 121 129 AUGGACUN 0 - $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --gtf cel-mir-58a SeqKit location 81 88 0 + . gene_id \"AUGGACUN\"; ath-MIR163 SeqKit location 122 129 0 - . gene_id \"AUGGACUN\"; Greedy mode (default) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 4 7 ACGA seq ACGA ACGA + 7 10 ACGA Non-greedy mode ( -G ) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA Circular genome. Note that end position of matched subsequence that crossing genome sequence end would be greater than sequence length. $ echo -e \">seq\\nACGTTGCA\" >seq ACGTTGCA $ echo -e \">seq\\nACGTTGCA\" \\ | seqkit locate -i -p aa seqID patternName pattern strand start end matched seq aa aa - 4 5 aa $ echo -e \">seq\\nACGTTGCA\" \\ | seqkit locate -i -p aa -c \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq aa aa + 8 9 aa seq aa aa - 4 5 aa fish Usage look for short sequences in larger sequences using local alignment Attention: 1. output coordinates are BED-like 0-based, left-close and right-open. 2. alignment information are printed to STDERR. Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular $ seqkit fish -q 4.7 -F GGCGGCTGTGACC -g mouse-p53-cds.fna Compare to seqkit locate : $ echo -e '>seq\\nACGACGACGA' \\ | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA $ echo -e '>seq\\nACGACGACGA' \\ | seqkit fish -F ACGA -a 2>&1 | csvtk -t pretty Ref RefStart RefEnd Query QueryStart QueryEnd Strand MapQual RawScore Acc ClipAcc QueryCov seq 6 10 q0 0 4 + 60.00 16 100.00 100.00 100.00 seq 0 4 q0 0 4 + 60.00 16 100.00 100.00 100.00 Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna amplicon Usage extract amplicon (or specific region around it) via primer(s). Attentions: 1. Only one (the longest) matching location is returned for every primer pair. 2. Mismatch is allowed, but the mismatch location (5' or 3') is not controled. You can increase the value of \"-j/--threads\" to accelerate processing. 3. Degenerate bases/residues like \"RYMM..\" are also supported. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". Examples: 0. no region given. F -----===============----- F R -----=====-----=====----- =============== amplicon 1. inner region (-r x:y). F -----===============----- 1 3 5 x/y -5-3-1 x/y F R -----=====-----=====----- x:y =============== 1:-1 ======= 1:7 ===== 3:7 ===== 6:10 ===== -10:-6 ===== -7:-3 -x:y (invalid) 2. flanking region (-r x:y -f) F -----===============----- -3-1 x/y 1 3 5 x/y F R -----=====-----=====----- ===== -5:-1 === -5:-3 ===== 1:5 === 3:5 ================= -1:1 ========================= -5:5 x:-y (invalid) Usage: seqkit amplicon [flags] Flags: --bed output in BED6+1 format with amplicon as the 7th column -f, --flanking-region region is flanking region -F, --forward string forward primer (5'-primer-3'), degenerate bases allowed -h, --help help for amplicon -I, --immediate-output print output immediately, do not use write buffer -m, --max-mismatch int max mismatch when matching primers, no degenerate bases allowed -P, --only-positive-strand only search on positive strand -M, --output-mismatches append the total mismatches and mismatches of 5' end and 3' end -p, --primer-file string 3- or 2-column tabular primer file, with first column as primer name -r, --region string specify region to return. type \"seqkit amplicon -h\" for detail -R, --reverse string reverse primer (5'-primer-3'), degenerate bases allowed -u, --save-unmatched also save records that do not match any primer -s, --strict-mode strict mode, i.e., discarding seqs not fully matching (shorter) given region range Examples No region given. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" >seq acgcccactgaaatga $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt >seq cccactgaaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt # BED6+1 $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt --bed seq 3 13 . 0 + cccactgaaa # supporting degenerate bases. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccR -R ttt --bed seq 4 13 . 0 + ccactgaaa Output mismatches: $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -M >seq mismatches=0(0+0) cccactgaaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -m 1 -M >seq mismatches=2(1+1) cgcccactgaaat $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -m 1 -M --bed seq 1 14 . 0 + cgcccactgaaat 2 1 1 Load primers from 3- or 2-column tabular primer file, with first column as primer name. $ cat seqs4amplicon.fa >seq1 ACGCCCACTGAAATGA >seq2 ACGTACGGTCAGATCCA $ cat primers.tsv p1 ccc ttt p2 ttt ccc p3 ttt p4 CG TG P5 CG GA # containing degenerate bases p6 TRC WGG $ cat seqs4amplicon.fa | seqkit amplicon -p primers.tsv --bed seq1 3 13 p1 0 + CCCACTGAAA seq1 1 7 p4 0 + CGCCCA seq1 3 13 p2 0 - TTTCAGTGGG seq1 10 13 p3 0 - TTT seq2 1 17 p4 0 + CGTACGGTCAGATCCA seq2 1 15 P5 0 + CGTACGGTCAGATC seq2 3 17 p6 0 + TACGGTCAGATCCA Inner region # region right behind forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 >seq actg # BED $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 --bed seq 6 10 . 0 + actg # more common case is triming primers $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:-4 >seq actg flanking region # in one of my sequencing data, I only care about # region downstream of forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 >seq tgaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 --bed seq 8 12 . 0 + tgaa # if given region if out scope of sequence. e.g, # 2-5bp downstream of aaa, we can get part of region (2-4) by default $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 >seq ga # you can also use strict mode to discard those cases $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 -s duplicate Usage duplicate sequences N times You may need \"seqkit rename\" to make the the sequence IDs unique. Usage: seqkit duplicate [flags] Aliases: duplicate, dup Flags: -h, --help help for duplicate -n, --times int duplication number (default 1) Examples Data $ cat tests/hairpin.fa | seqkit head -n 1 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA Duplicate 2 times $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA use seqkit rename to make the the sequence IDs unique. $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 | seqkit rename >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7_2 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA rmdup Usage remove duplicated sequences by ID/name/sequence Attentions: 1. When comparing by sequences, both positive and negative strands are compared. Switch on -P/--only-positive-strand for considering the positive strand only. 2. Only the first record is saved for duplicates. Usage: seqkit rmdup [flags] Flags: -n, --by-name by full name instead of just id -s, --by-seq by seq -D, --dup-num-file string file to save number and list of duplicated seqs -d, --dup-seqs-file string file to save duplicated seqs -h, --help help for rmdup -i, --ignore-case ignore case -P, --only-positive-strand only considering positive strand when comparing by sequence Examples Similar to common . General use $ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 2226 duplicated records removed $ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 1086 duplicated records removed Save duplicated sequences to file $ zcat hairpin.fa.gz \\ | seqkit rmdup -s -i -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ cat duplicated.detail.txt # here is not the entire list 3 hsa-mir-424, mml-mir-424, ppy-mir-424 3 hsa-mir-342, mml-mir-342, ppy-mir-342 2 ngi-mir-932, nlo-mir-932 2 ssc-mir-9784-1, ssc-mir-9784-2 common Usage find common sequences of multiple files by id/name/sequence Note: 1. 'seqkit common' is designed to support 2 and MORE files. 2. When comparing by sequences, both positive and negative strands are compared. Switch on -P/--only-positive-strand for considering the positive strand only. 3. For 2 files, 'seqkit grep' is much faster and consumes lesser memory: seqkit grep -f <(seqkit seq -n -i small.fq.gz) big.fq.gz # by seq ID seqkit grep -s -f <(seqkit seq -s small.fq.gz) big.fq.gz # by seq 4. Some records in one file may have same sequences/IDs. They will ALL be retrieved if the sequence/ID was shared in multiple files. So the records number may be larger than that of the smallest file. Usage: seqkit common [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq match by sequence -h, --help help for common -i, --ignore-case ignore case -P, --only-positive-strand only considering positive strand when comparing by sequence Examples By ID (default) seqkit common file*.fa -o common.fasta By full name seqkit common file*.fa -n -o common.fasta By sequence seqkit common file*.fa -s -i -o common.fasta split Usage split sequences into files by name ID, subsequence of given region, part size or number of parts. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. If you just want to split by parts or sizes, please use \"seqkit split2\", which also applies for paired- and single-end FASTQ. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit split [flags] Flags: -i, --by-id split squences according to sequence ID --by-id-prefix string file prefix for --by-id -p, --by-part int split sequences into N parts --by-part-prefix string file prefix for --by-part -r, --by-region string split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \"seqkit split -h\" for more examples --by-region-prefix string file prefix for --by-region -s, --by-size int split sequences into multi parts with N sequences --by-size-prefix string file prefix for --by-size -d, --dry-run dry run, just print message and no files will be created. -e, --extension string set output file extension, e.g., \".gz\", \".xz\", or \".zst\" -f, --force overwrite output directory -h, --help help for split -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -O, --out-dir string output directory (default value is $infile.split) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples Split sequences into parts with at most 10000 sequences $ seqkit split hairpin.fa.gz -s 10000 [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.part_001.gz [INFO] write 7162 sequences to file: hairpin.fa.part_002.gz [INFO] write 7162 sequences to file: hairpin.fa.part_003.gz [INFO] write 7159 sequences to file: hairpin.fa.part_004.gz To reduce memory usage when spliting big file, we should alwasy use flag --two-pass $ seqkit split hairpin.fa.gz -p 4 -2 [INFO] split into 4 parts [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 7162 sequences to file: hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.part_004.fa.gz Split sequences by species. i.e. by custom IDs (first three letters) $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2 [INFO] split by ID. idRegexp: ^([\\w]+)\\- [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 48 sequences to file: hairpin.id_cca.fa.gz [INFO] write 3 sequences to file: hairpin.id_hci.fa.gz [INFO] write 106 sequences to file: hairpin.id_str.fa.gz [INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz ... Split sequences by sequence region (for example, sequence barcode) $ seqkit split hairpin.fa.gz -r 1:3 -2 [INFO] split by region: 1:3 [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] read sequence IDs and sequence region from FASTA file ... [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz [INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz [INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz Sequence suffix could be defined as -r -12:-1 split2 Usage split sequences into files by part size or number of parts This command supports FASTA and paired- or single-end FASTQ with low memory occupation and fast speed. The prefix of output files: 1. For stdin: stdin 2. Others: same to the input file 3. Set via the option: -o/--out-file, e.g., outputting xxx.part_001.fasta: cat ../tests/hairpin.fa | ./seqkit split2 -p 2 -O test -o xxx The extension of output files: 1. For stdin: .fast[aq] 2. Others: same to the input file 3. Additional extension via the option -e/--extension, e.g.\uff0c outputting gzipped files for plain text input: seqkit split2 -p 2 -O test tests/hairpin.fa -e .gz Usage: seqkit split2 [flags] Flags: -l, --by-length string split sequences into chunks of >=N bases, supports K/M/G suffix --by-length-prefix string file prefix for --by-length -p, --by-part int split sequences into N parts --by-part-prefix string file prefix for --by-part -s, --by-size int split sequences into multi parts with N sequences --by-size-prefix string file prefix for --by-size -e, --extension string set output file extension, e.g., \".gz\", \".xz\", or \".zst\" -f, --force overwrite output directory -h, --help help for split2 -O, --out-dir string output directory (default value is $infile.split) -1, --read1 string (gzipped) read1 file -2, --read2 string (gzipped) read2 file Examples Split sequences into parts with at most 10000 sequences: $ seqkit split2 hairpin.fa -s 10000 [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_001.fa [INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_002.fa [INFO] write 8645 sequences to file: hairpin.fa.split/hairpin.part_003.fa Force compression for plain text input by adding an extra extension: # gzip $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.gz [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.gz [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.gz # xz $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .xz [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.xz [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.xz [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.xz # zstd $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .zst [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.zst [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.zst [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.zst Change the prefix of output files: $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz -o xxx [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/xxx.part_001.fa.gz [INFO] write 10000 sequences to file: test/xxx.part_002.fa.gz [INFO] write 8645 sequences to file: test/xxx.part_003.fa.gz # here, we also change the compression format from xz to zstd $ cat hairpin.fa.xz | seqkit split2 -O test -f -s 10000 -e .zst [INFO] split seqs from stdin [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/stdin.part_001.fasta.zst [INFO] write 10000 sequences to file: test/stdin.part_002.fasta.zst [INFO] write 8645 sequences to file: test/stdin.part_003.fasta.zst Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 -f [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.fa.gz.split/hairpin.part_004.fa.gz For FASTQ files (paired-end) $ seqkit split2 -1 reads_1.fq.gz -2 reads_2.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz and reads_2.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_2.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_2.part_002.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz For FASTA files (single-end) $ seqkit split2 -1 reads_1.fq.gz reads_2.fq.gz -p 2 -O out -f [INFO] flag -1/--read1 given, ignore: reads_2.fq.gz [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz $ seqkit split2 reads_1.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz pair Usage match up paired-end reads from two fastq files Attentions: 1. Orders of headers in the two files better be the same (not shuffled), otherwise, it consumes a huge number of memory for buffering reads in memory. 2. Unpaired reads are optional outputted with the flag -u/--save-unpaired. 3. If the flag -O/--out-dir is not given, the output will be saved in the same directory of input, with the suffix \"paired\", e.g., read_1.paired.fq.gz. Otherwise, names are kept untouched in the given output directory. 4. Paired gzipped files may be slightly larger than original files, because of using a different gzip package/library, don't worry. Tips: 1. Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI. You can simply specify the regular expression for extracting sequence IDs: --id-regexp '^(\\S+)\\/[12]' Usage: seqkit pair [flags] Flags: -f, --force overwrite output directory -h, --help help for pair -O, --out-dir string output directory -1, --read1 string (gzipped) read1 file -2, --read2 string (gzipped) read2 file -u, --save-unpaired save unpaired reads if there are Examples Simple one $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz # output reads_1.paired.fq.gz reads_2.paired.fq.gz Set output directory, file names are kept untouched. $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result $ tree result result/ \u251c\u2500\u2500 reads_1.fq.gz \u2514\u2500\u2500 reads_2.fq.gz Save unpaired reads if there are. $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result -u $ tree result result \u251c\u2500\u2500 reads_1.fq.gz \u251c\u2500\u2500 reads_1.unpaired.fq.gz \u251c\u2500\u2500 reads_2.fq.gz \u2514\u2500\u2500 reads_2.unpaired.fq.gz Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI. You can simply specify the regular expression for extracting sequence IDs: seqkit pair --id-regexp '^(\\S+)\\/[12]' -1 reads_1.fq.gz -2 reads_2.fq.gz sample Usage sample sequences by number or proportion. Attention: 1. Do not use '-n' on large FASTQ files, it loads all seqs into memory! use 'seqkit sample -p 0.1 seqs.fq.gz | seqkit head -n N' instead! Usage: seqkit sample [flags] Flags: -h, --help help for sample -n, --number int sample by number (result may not exactly match), DO NOT use on large FASTQ files. -p, --proportion float sample by proportion -s, --rand-seed int rand seed (default 11) -2, --two-pass 2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin Examples Sample by proportion $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz [INFO] sample by proportion [INFO] 2814 sequences outputed Sample by number $ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz [INFO] sample by number [INFO] 949 sequences outputed 949 != 1000 ??? see Effect of random seed on results of seqkit sample To reduce memory usage when spliting big file, we could use flag --two-pass We can also use seqkit sample -p followed with seqkit head -n : $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit head -n 1000 -o sample.fa.gz Set rand seed to reproduce the result $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 -s 11 Most of the time, we could shuffle after sampling $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit shuffle -o sample.fa.gz Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) head Usage print first N FASTA/Q records For returning the last N records, use: seqkit range -N:-1 seqs.fasta Usage: seqkit head [flags] Flags: -n, --number int print first N FASTA/Q records (default 10) Examples FASTA $ seqkit head -n 1 hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA FASTQ $ seqkit head -n 1 reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII head-genome Usage print sequences of the first genome with common prefixes in name For a FASTA file containing multiple contigs of strains (see example below), these's no list of IDs available for retrieving sequences of a certain strain, while descriptions of each strain share the same prefix. This command is used to restrieve sequences of the first strain, i.e., \"Vibrio cholerae strain M29\". >NZ_JFGR01000001.1 Vibrio cholerae strain M29 Contig_1, whole genome shotgun sequence >NZ_JFGR01000002.1 Vibrio cholerae strain M29 Contig_2, whole genome shotgun sequence >NZ_JFGR01000003.1 Vibrio cholerae strain M29 Contig_3, whole genome shotgun sequence >NZ_JSTP01000001.1 Vibrio cholerae strain 2012HC-12 NODE_79, whole genome shotgun sequence >NZ_JSTP01000002.1 Vibrio cholerae strain 2012HC-12 NODE_78, whole genome shotgun sequence Attention: 1. Sequences in file should be well organized. Usage: seqkit head-genome [flags] Flags: -h, --help help for head-genome -m, --mini-common-words int minimal shared prefix words (default 4) range Usage print FASTA/Q records in a range (start:end) Examples: 1. leading 100 records (head -n 100) seqkit range -r 1:100 2. last 100 records (tail -n 100) seqkit range -r -100:-1 3. remove leading 100 records (tail -n +101) seqkit range -r 101:-1 4. other ranges: seqkit range -r 10:100 seqkit range -r -100:-10 Usage: seqkit range [flags] Flags: -h, --help help for range -r, --range string range. e.g., 1:12 for first 12 records (head -n 12), -12:-1 for last 12 records (tail -n 12) Examples leading N records (head) $ cat tests/hairpin.fa | seqkit head -n 100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - $ cat tests/hairpin.fa | seqkit range -r 1:100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - last N records (tail) $ cat tests/hairpin.fa | seqkit range -r -100:-1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 100 8,656 58 86.6 172 remove leading 100 records (tail -n +101) $ seqkit range -r 101:-1 tests/hairpin.fa | seqkit sum -a seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db - 28545 2940929 $ seqkit fx2tab tests/hairpin.fa | tail -n +101 | seqkit tab2fx | seqkit sum -a seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db - 28545 2940929 Other ranges $ cat tests/hairpin.fa | seqkit range -r 101:150 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 50 3,777 63 75.5 96 $ cat tests/hairpin.fa | seqkit range -r -100:-2 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 99 8,484 58 85.7 146 replace Usage replace name/sequence by regular expression. Note that the replacement supports capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: use SINGLE quote NOT double quotes in *nix OS. Examples: Adding space to all bases. seqkit replace -p \"(.)\" -r '$1 ' -s Or use the \\ escape character. seqkit replace -p \"(.)\" -r \"\\$1 \" -s more on: http://bioinf.shenwei.me/seqkit/usage/#replace Special replacement symbols (only for replacing name not sequence): {nr} Record number, starting from 1 {kv} Corresponding value of the key (captured variable $n) by key-value file, n can be specified by flag -I (--key-capt-idx) (default: 1) Special cases: 1. If replacements contain '$', a). If using '{kv}', you need use '$$$$' instead of a single '$': -r '{kv}' -k <(sed 's/\\$/$$$$/' kv.txt) b). If not, use '$$': -r 'xxx$$xx' Filtering records to edit: You can use flags similar to those in \"seqkit grep\" to choose partly records to edit. Usage: seqkit replace [flags] Flags: -s, --by-seq replace seq (only FASTA) --f-by-name [target filter] match by full name instead of just ID --f-by-seq [target filter] search subseq on seq, both positive and negative strand are searched, and mismatch allowed using flag -m/--max-mismatch --f-ignore-case [target filter] ignore case --f-invert-match [target filter] invert the sense of matching, to select non-matching records --f-only-positive-strand [target filter] only search on positive strand --f-pattern strings [target filter] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') --f-pattern-file string [target filter] pattern file (one record per line) --f-use-regexp [target filter] patterns are regular expression -h, --help help for replace -i, --ignore-case ignore case -K, --keep-key keep the key as value when no value found for the key (only for sequence name) -U, --keep-untouch do not change anything when no value found for the key (only for sequence name) -I, --key-capt-idx int capture variable index of key (1-based) (default 1) -m, --key-miss-repl string replacement for key with no corresponding value -k, --kv-file string tab-delimited key-value file for replacing key with value when using \"{kv}\" in -r (--replacement) (only for sequence name) --nr-width int minimum width for {nr} in flag -r/--replacement. e.g., formatting \"1\" to \"001\" by --nr-width 3 (default 1) -p, --pattern string search regular expression -r, --replacement string replacement. supporting capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by \"{nr}\".use ${1} instead of $1 when {kv} given! Examples Prepend or append to the header $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT # prefix $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p ^ -r _prefix_ >_prefix_seq1 abc-123 ACGT-ACGT # suffix $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p $ -r _suffix_ >seq1 abc-123_suffix_ ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit seq -i \\ | seqkit replace -p $ -r _suffix_ >seq1_suffix_ ACGT-ACGT Remove descriptions $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\s.+\" >seq1 ACGT-ACGT Replace \"-\" with \"=\" $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\-\" -r '=' >seq1 abc=123 ACGT-ACGT Remove gaps in sequences. $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \" |-\" -s >seq1 abc-123 ACGTACGT Add space to every base. ATTENTION: use SINGLE quote NOT double quotes in *nix OS $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r '$1 ' -s >seq1 abc-123 A C G T - A C G T $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s >seq1 abc-123 A C G T - A C G T Transpose sequence with csvtk $ echo -e \">seq1\\nACTGACGT\\n>seq2\\nactgccgt\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s \\ | seqkit seq -s -u \\ | csvtk space2tab \\ | csvtk -t transpose A A C C T T G G A C C C G G T T Rename with number of record $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" >seq_1 ACTG >seq_2 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" --nr-width 5 >seq_00001 ACTG >seq_00002 ATTT Replace key with value by key-value file $ more test.fa >seq1 name1 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 name3 CCCCAAAACCCCATGTTGCTACTAG $ more alias.txt name0 ABC name1 123 name3 Hello name4 World $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG If the target to replace is the sequence ID, meanwhile you would like to keep the description. Please use this: # ^(\\S+) # ID # (.+)$ # description seqkit replace -p '^(\\S+)(.+?)$' -r '{kv}$2' -k alias.txt test.fa convert fasta to genbank style $ cat seq.fa >seq1 TTTAAAGAGACCGGCGATTCTAGTGAAATCGAACGGGCAGGTCAATTTCCAACCAGCGAT GACGTAATAGATAGATACAAGGAAGTCATTTTTCTTTTAAAGGATAGAAACGGTTAATGC TCTTGGGACGGCGCTTTTCTGTGCATAACT >seq2 AAGGATAGAAACGGTTAATGCTCTTGGGACGGCGCTTTTCTGTGCATAACTCGATGAAGC CCAGCAATTGCGTGTTTCTCCGGCAGGCAAAAGGTTGTCGAGAACCGGTGTCGAGGCTGT TTCCTTCCTGAGCGAAGCCTGGGGATGAACG $ cat seq.fa \\ | seqkit replace -s -p '(\\w{10})' -r '$1 ' -w 66 \\ | perl -ne 'if (/^>/) {print; $n=1} else {s/ \\r?\\n$/\\n/; printf \"%9d %s\", $n, $_; $n+=60;}' >seq1 1 TTTAAAGAGA CCGGCGATTC TAGTGAAATC GAACGGGCAG GTCAATTTCC AACCAGCGAT 61 GACGTAATAG ATAGATACAA GGAAGTCATT TTTCTTTTAA AGGATAGAAA CGGTTAATGC 121 TCTTGGGACG GCGCTTTTCT GTGCATAACT >seq2 1 AAGGATAGAA ACGGTTAATG CTCTTGGGAC GGCGCTTTTC TGTGCATAAC TCGATGAAGC 61 CCAGCAATTG CGTGTTTCTC CGGCAGGCAA AAGGTTGTCG AGAACCGGTG TCGAGGCTGT 121 TTCCTTCCTG AGCGAAGCCT GGGGATGAAC G only edit some of the records via patterns. Eight flags starting with --f- (with the same usage to these in seqkit grep ) can be used to filter records to edit. # prepend some text to header $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ >_abc ACTG >_123 ATTT # only edit some records $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ --f-use-regexp --f-pattern abc [INFO] 1 records matched by the filter >_abc ACTG >123 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ --f-use-regexp --f-invert-match --f-pattern abc [INFO] 1 records matched by the filter >abc ACTG >_123 ATTT rename Usage rename duplicated IDs Attention: 1. This command only appends \"_N\" to duplicated sequence IDs to make them unique. 2. Use \"seqkit replace\" for editing sequence IDs/headers using regular expression. Example: $ seqkit seq seqs.fasta >id comment actg >id description ACTG $ seqkit rename seqs.fasta >id comment actg >id_2 description ACTG Usage: seqkit rename [flags] Flags: -n, --by-name check duplication by full name instead of just id -f, --force overwrite output directory -h, --help help for rename -m, --multiple-outfiles write results into separated files for multiple input files -O, --out-dir string output directory (default \"renamed\") -1, --rename-1st-rec rename the first record as well -s, --separator string separator between original ID/name and the counter (default \"_\") -N, --start-num int starting count number for *duplicated* IDs/names, should be greater than zero (default 2 Examples $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" >a comment acgt >b comment of b ACTG >a comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename >a comment acgt >b comment of b ACTG >a_2 comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename -s '|' -N 2 -1 >a|1 comment acgt >b|1 comment of b ACTG >a|2 comment aaaa restart Usage reset start position for circular genome Examples $ echo -e \">seq\\nacgtnACGTN\" >seq acgtnACGTN $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i 2 >seq cgtnACGTNa $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i -2 >seq TNacgtnACG Usage: seqkit restart [flags] Flags: -i, --new-start int new start position (1-base, supporting negative value counting from the end) (default 1) concat Usage concatenate sequences with same ID from multiple files Attentions: 1. By default, only sequences with IDs that appear in all files are outputted. use -f/--full to output all sequences. 2. If there are more than one sequences of the same ID, we output the Cartesian product of sequences. 3. Description are also concatenated with a separator (-s/--separator). 4. Order of sequences with different IDs are random. Usage: seqkit concat [flags] Aliases: concat, concate Flags: -f, --full keep all sequences, like full/outer join -h, --help help for concat -s, --separator string separator for descriptions of records with the same ID (default \"|\") Examples $ cat a.fa >A 1 a1- >A 2 a2- >B 1 b1- $ cat b.fa >A x ax- >C 1 c1- $ seqkit concat a.fa b.fa >A 1|x a1-ax- >A 2|x a2-ax- $ seqkit concat a.fa b.fa --full >C 1 c1- >A 1|x a1-ax- >A 2|x a2-ax- >B 1 b1- mutate Usage edit sequence (point mutation, insertion, deletion) Attentions: 1. Mutiple point mutations (-p/--point) are allowed, but only single insertion (-i/--insertion) OR single deletion (-d/--deletion) is allowed. 2. Point mutation takes place before insertion/deletion. Notes: 1. You can choose certain sequences to edit using similar flags in 'seqkit grep'. The definition of position is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit mutate [flags] Flags: -n, --by-name [match seqs to mutate] match by full name instead of just id -d, --deletion string deletion mutation: deleting subsequence in a range. e.g., -d 1:2 for deleting leading two bases, -d -3:-1 for removing last 3 bases -h, --help help for mutate -I, --ignore-case [match seqs to mutate] ignore case of search pattern -i, --insertion string insertion mutation: inserting bases behind of given position, e.g., -i 0:ACGT for inserting ACGT at the beginning, -1:* for add * to the end -v, --invert-match [match seqs to mutate] invert the sense of matching, to select non-matching records -s, --pattern strings [match seqs to mutate] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string [match seqs to mutate] pattern file (one record per line) -p, --point strings point mutation: changing base at given position. e.g., -p 2:C for setting 2nd base as C, -p -1:A for change last base as A -r, --use-regexp [match seqs to mutate] search patterns are regular expression Examples: Point mutation: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" >1 ACTGNactgn >2 actgnACTGN # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x [INFO] edit seq: 1 [INFO] edit seq: 2 >1 xCTGNactgn >2 xctgnACTGN # 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 5:x --quiet >1 ACTGxactgn >2 actgxACTGN # last base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p -1:x --quiet >1 ACTGNactgx >2 actgnACTGx # mutiple locations: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x -p -1:x --quiet >1 xCTGNactgx >2 xctgnACTGx Deletion # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d 1:1 --quiet >1 CTGNactgn >2 ctgnACTGN # last 3 bases $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d -3:-1 --quiet >1 ACTGNac >2 actgnAC Insertion: inserting bases behind of given position # at the beginning $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 0:xx --quiet >1 xxACTGNactgn >2 xxactgnACTGN # at the end $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i -1:xx --quiet >1 ACTGNactgnxx >2 actgnACTGNxx # behind of 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 5:x --quiet >1 ACTGNxactgn >2 actgnxACTGN Choosing which sequences to edit , using similar flags in seqkit grep . $ cat tests/hsa.fa >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # only edit chr1 and chr2 # or cat tests/hsa.fa | seqkit mutate -p -1:X -s chr1 -s chr2 $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1,chr2 [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # using regular expression to match. # e,g., editing all chrosomes: $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -r -s chr [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq [INFO] edit seq: chr11 11th seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgn # excluding seqs $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1 -s chr2 -v [INFO] edit seq: chr11 11th seq [INFO] edit seq: MT mitochondrial seq >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgX shuffle Usage shuffle sequences. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence IDs. If the file is not plain FASTA file, seqkit will write the sequences to temporary files, and create FASTA index. Secondly, seqkit shuffles sequence IDs and extract sequences by FASTA index. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. Usage: seqkit shuffle [flags] Flags: -h, --help help for shuffle -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -s, --rand-seed int rand seed for shuffle (default 23) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples General use. $ seqkit shuffle hairpin.fa.gz > shuffled.fa [INFO] read sequences ... [INFO] 28645 sequences loaded [INFO] shuffle ... [INFO] output ... For big genome, you'd better use two-pass mode so seqkit could use FASTA index to reduce memory usage $ time seqkit shuffle -2 hsa.fa > shuffle.fa [INFO] create and read FASTA index ... [INFO] create FASTA index for hsa.fa [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... real 0m35.080s user 0m45.521s sys 0m3.411s Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) for read 1 and 2 files. sort Usage sort sequences by id/name/sequence/length. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence head and length information. If the file is not plain FASTA file, seqkit will write the sequences to temporary files, and create FASTA index. Secondly, seqkit sorts sequence by head and length information and extracts sequences by FASTA index. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. Usage: seqkit sort [flags] Flags: -b, --by-bases by non-gap bases -l, --by-length by sequence length -n, --by-name by full name instead of just id -s, --by-seq by sequence -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for sort -i, --ignore-case ignore case -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -N, --natural-order sort in natural order, when sorting by IDs/full name -r, --reverse reverse the result -L, --seq-prefix-length int length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples For FASTA format, use flag -2 (--two-pass) to reduce memory usage sort by ID $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by ID and in natural order $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit seq -n -i 3 1 Y x Mt 11 2 $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit sort -N -i -2 \\ | seqkit seq -n -i 1 2 3 11 Mt x Y sort by ID, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -i >seq1 ACGTNcccc >SEQ2 acgtnAAAA sort by seq, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -s -i >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by sequence length $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAAnnn\\n>seq3\\nacgt\" \\ | seqkit sort --quiet -l >seq3 acgt >seq1 ACGTNcccc >SEQ2 acgtnAAAAnnn bam monitoring and online histograms of BAM record features Usage: seqkit bam [flags] Flags: -B, --bins int number of histogram bins (default -1) -N, --bundle int partition BAM file into loci (-1) or bundles with this minimum size -c, --count string count reads per reference and save to this file -W, --delay int sleep this many seconds after plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -G, --exclude-ids string exclude records with IDs contained in this file -e, --exec-after string execute command after reporting -E, --exec-before string execute command before reporting -f, --field string target fields -g, --grep-ids string only keep records with IDs contained in this file -h, --help help for bam -C, --idx-count fast read per reference counting based on the BAM index -i, --idx-stat fast statistics based on the BAM index -O, --img string save histogram to this PDF/image file -H, --list-fields list all available BAM record features -L, --log log10(x+1) transform numeric values -q, --map-qual int minimum mapping quality -x, --pass passthrough mode (forward filtered BAM to output) -k, --pretty pretty print certain TSV outputs -F, --prim-only filter out non-primary alignment records -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -Q, --quiet-mode supress all plotting to stderr -M, --range-max float discard record with field (-f) value greater than this flag (default NaN) -m, --range-min float discard record with field (-f) value less than this flag (default NaN) -R, --reset reset histogram after every report -Z, --silent-mode supress TSV output to stderr -s, --stat print BAM satistics of the input files -T, --tool string invoke toolbox in YAML format (see documentation) -@, --top-bam string save the top -? records to this bam file -?, --top-size int size of the top-mode buffer (default 100) Examples Get detailed statistics from multiple BAM files. seqkit bam -s *.bam Get rough statistics from multiple indexed BAM files. seqkit bam -i *.bam Count reads mapped to references from a BAM stream. cat sample.bam | seqkit bam -c counts.tsv - Count reads mapped to references using the BAM index. seqkit bam -C sorted_indexed.bam Monitor alignment accuracy from a bam stream and report after every 1000 records, use 20 bins. cat sample.bam | seqkit bam -B -f Acc -p 1000 - Dump selected fields to TSV. seqkit bam -f Ref,Acc,RefCov,Strand sample.bam Save the best 100 records in terms of alignment accuracy to a BAM file. seqkit bam -f Acc -@ top_acc_100.bam -? 100 -Q sample.bam Inkvoke the BAM toolbox. The BAM toolbox is a collection of filters acting on a stream of BAM records, configured via YAML. The currently available tools can be listed by seqkit bam -T help : Tool Description ---- ----------- AccStats calculates mean accuracy weighted by aligment lengths AlnContext filter records by the sequence context at start and end Dump dump various record properties in TSV format help list all tools with description Example YAML configs: Invoking the AccStats tool directly from the command line or YAML config: seqkit bam -T '{AccStats: {Tsv: \"-\"}, Sink: True}' input.bam seqkit bam -T '{Yaml: \"tests/examples/bam_tool_acc_stats.yml\"}' input.bam Where the contents of bam_tool_acc_stats.yml are: AccStats: Tsv: \"-\" Sink: True Invoking the AlnContext tool using YAML: AlnContext: Tsv: \"-\" Ref: \"../SIRV_150601a.fasta\" LeftShift: -10 RightShift: 10 RegexStart: \"T{4,}\" RegexEnd: \"A{4,}\" Stranded: True Invert: True Sink: True Invoking the Dump tool using YAML: Dump: Tsv: \"-\" Fields: [\"Read\", \"Ref\", \"Pos\", \"EndPos\", \"MapQual\", \"Acc\", \"Match\", \"Mismatch\", \"Ins\", \"Del\", \"AlnLen\", \" ReadLen\", \"RefLen\", \"RefAln\", \"RefCov\", \"ReadAln\", \"ReadCov\", \"Strand\", \"MeanQual\", \"LeftClip\", \"RightClip\", \"Flags\", \"IsSec\", \" IsSup\", \"ReadSeq\", \"ReadAlnSeq\", \"LeftSoftClipSeq\", \"RightSoftClip\", \"LeftHardClip\", \"RightHardClip\"] Sink: True The tools can be chained together, for example the YAML using all three tools look like: AlnContext: Tsv: \"context.tsv\" Ref: \"../SIRV_150601a.fasta\" LeftShift: -10 RightShift: 10 RegexStart: \"T{4,}\" RegexEnd: \"A{4,}\" Stranded: True Invert: True Dump: Tsv: \"dump.tsv\" Fields: [\"Read\", \"Ref\", \"Pos\", \"EndPos\", \"MapQual\", \"Acc\", \"Match\", \"Mismatch\", \"Ins\", \"Del\", \"AlnLen\", \" ReadLen\", \"RefLen\", \"RefAln\", \"RefCov\", \"ReadAln\", \"ReadCov\", \"Strand\", \"MeanQual\", \"LeftClip\", \"RightClip\", \"Flags\", \"IsSec\", \" IsSup\", \"ReadSeq\", \"ReadAlnSeq\", \"LeftSoftClipSeq\", \"RightSoftClip\", \"LeftHardClip\", \"RightHardClip\"] AccStats: Tsv: \"-\" If the \"Sink\" parameter is not specified in the last pipeline step, the output BAM records are streamed to the standard output and can be piped into standard tools, for example: seqkit bam -T '{Yaml: \"bam_tool_pipeline.yml\"}' ../pcs109_5k_spliced.bam | samtools flagstat - genautocomplete Usage generate shell autocompletion script Supported shell: bash|zsh|fish|powershell Bash: # generate completion shell seqkit genautocomplete --shell bash # configure if never did. # install bash-completion if the \"complete\" command is not found. echo \"for bcfile in ~/.bash_completion.d/* ; do source \\$bcfile; done\" >> ~/.bash_completion echo \"source ~/.bash_completion\" >> ~/.bashrc Zsh: # generate completion shell seqkit genautocomplete --shell zsh --file ~/.zfunc/_seqkit # configure if never did echo 'fpath=( ~/.zfunc \"${fpath[@]}\" )' >> ~/.zshrc echo \"autoload -U compinit; compinit\" >> ~/.zshrc fish: seqkit genautocomplete --shell fish --file ~/.config/fish/completions/seqkit.fish Usage: seqkit genautocomplete [flags] Flags: --file string autocompletion file (default \"/home/shenwei/.bash_completion.d/seqkit.sh\") -h, --help help for genautocomplete --type string autocompletion type (currently only bash supported) (default \"bash\") /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"Usage"},{"location":"usage/#usage-and-examples","text":"","title":"Usage and Examples"},{"location":"usage/#quick-guide","text":"Basic: seq , stats , sum , subseq , sliding , faidx , watch , sana , scat Format conversion: fq2fa , fa2fq , fx2tab , tab2fx , convert , translate Searching: grep , locate , amplicon , fish Set operation: sample , rmdup , common , duplicate , split , split2 , head , head-genome , range , pair Edit: concat , replace , restart , mutate , rename Ordering: sort , shuffle BAM processing: bam","title":"Quick Guide"},{"location":"usage/#technical-details-and-guides-for-use","text":"","title":"Technical details and guides for use"},{"location":"usage/#fastaq-format-parsing-and-writing","text":"Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0 . Bzip2 format is supported since v2.4.0 . SeqKit uses the author's lightweight and high-performance bioinformatics package bio for FASTA/Q parsing, which has high performance close to the famous C lib klib ( kseq.h ). Notes: seqkit uses 4 threads by default. seqkit_t1 uses 1 thread. seqtk is single-threaded. seqtk+gzip : seqtk pipes data to the single-threaded gzip . seqtk+pigz : seqtk pipes data to the multithreaded pigz which uses 4 threads here.","title":"FASTA/Q format parsing and writing"},{"location":"usage/#input-and-output-files","text":"Seqkit accepts input data from standard input (STDIN) and plain or gzip-compressed files. Files can be given via positional arguments or the flag --infile-list . For example: seqkit seq a.fasta b.fasta seqkit seq --infile-list file-list.txt seqkit seq --infile-list <(find -name \"*.fq.gz\" directory) Result are printed to standard ouput (STDOUT) by default, you can also specify the output file via the flag -o/--out-file . The file name extension .gz is automatically recognized. For example: seqkit seq a.fasta -o a.fasta.gz seqkit grep -f IDs.txt read_1.fq.gz -o dir/read_1.fq.gz Seqkit utlizies the pgzip package to read and write gzip file, and the outputted gzip file would be slighty larger than files generated by GNU gzip . Seqkit writes gzip files very fast, much faster than the multi-threaded pigz , so there's no need to pipe the result to gzip / pigz .","title":"Input and output files"},{"location":"usage/#sequence-formats-and-types","text":"SeqKit seamlessly support FASTA and FASTQ format. Sequence format is automatically detected. All subcommands except for faidx and bam can handle both formats. And only when some commands ( subseq , split , sort and shuffle ) which utilise FASTA index to improve perfrmance for large files in two pass mode (by flag --two-pass ), only FASTA format is supported. Sequence type (DNA/RNA/Protein) is automatically detected by leading subsequences of the first sequences in file or STDIN. The length of the leading subsequences is configurable by global flag --alphabet-guess-seq-length with default value of 10000. If length of the sequences is less than that, whole sequences will be checked.","title":"Sequence formats and types"},{"location":"usage/#sequence-id","text":"By default, most softwares, including seqkit , take the leading non-space letters as sequence identifier (ID). For example, FASTA header ID >123456 gene name 123456 >longname longname >gi|110645304|ref|NC_002516.2| Pseudomona gi|110645304|ref|NC_002516.2| But for some sequences from NCBI, e.g. >gi|110645304|ref|NC_002516.2| Pseudomona , the ID is NC_002516.2 . In this case, we could set sequence ID parsing regular expression by global flag --id-regexp \"\\|([^\\|]+)\\| \" or just use flag --id-ncbi . If you want the gi number, then use --id-regexp \"^gi\\|([^\\|]+)\\|\" .","title":"Sequence ID"},{"location":"usage/#fasta-index","text":"For some commands, including subseq , split , sort and shuffle , when input files are (plain or gzipped) FASTA files, FASTA index would be optional used for rapid access of sequences and reducing memory occupation. ATTENTION: the .seqkit.fai file created by SeqKit is a little different from .fai file created by samtools . SeqKit uses full sequence head instead of just ID as key.","title":"FASTA index"},{"location":"usage/#parallelization-of-cpu-intensive-jobs","text":"The validation of sequences bases and complement process of sequences are parallelized for large sequences. Parsing of line-based files, including BED/GFF file and ID list file are also parallelized. The pgzip package reads and write gzip files in parallel. The Parallelization is implemented by multiple goroutines in golang which are similar to but much lighter weight than threads. The concurrency number is configurable with global flag -j or --threads (default value: 4). Using four threads is fast enough for most commands where FASTA/Q reading and writing is the performance bottleneck, and using more threads will not increase the speed . Few commands could benefit from multiple (>4) threads: stats scat grep -s -m locate -s -m amplicon -s -m","title":"Parallelization of CPU intensive jobs"},{"location":"usage/#memory-occupation","text":"Most of the subcommands do not read whole FASTA/Q records in to memory, including stat , fq2fa , fx2tab , tab2fx , grep , locate , replace , seq , sliding , subseq . Note that when using subseq --gtf | --bed , if the GTF/BED files are too big, the memory usage will increase. You could use --chr to specify chromesomes and --feature to limit features. Some subcommands could either read all records or read the files twice by flag -2 ( --two-pass ), including sample , split , shuffle and sort . They use FASTA index for rapid acccess of sequences and reducing memory occupation.","title":"Memory occupation"},{"location":"usage/#reproducibility","text":"Subcommands sample and shuffle use random function, random seed could be given by flag -s ( --rand-seed ). This makes sure that sampling result could be reproduced in different environments with same random seed.","title":"Reproducibility"},{"location":"usage/#seqkit","text":"SeqKit -- a cross-platform and ultrafast toolkit for FASTA/Q file manipulation Version: 2.4.0 Author: Wei Shen <shenwei356@gmail.com> Documents : http://bioinf.shenwei.me/seqkit Source code: https://github.com/shenwei356/seqkit Please cite: https://doi.org/10.1371/journal.pone.0163962 Seqkit utlizies the pgzip (https://github.com/klauspost/pgzip) package to read and write gzip file, and the outputted gzip file would be slighty larger than files generated by GNU gzip. Seqkit writes gzip files very fast, much faster than the multi-threaded pigz, therefore there's no need to pipe the result to gzip/pigz. Seqkit also supports reading and writing xz (.xz) and zstd (.zst) formats since v2.2.0. Bzip2 format is supported since v2.4.0. Compression level: format range default comment gzip 1-9 5 https://github.com/klauspost/pgzip sets 5 as the default value. xz NA NA https://github.com/ulikunitz/xz does not support. zstd 1-4 2 roughly equals to zstd 1, 3, 7, 11, respectively. bzip 1-9 6 https://github.com/dsnet/compress Usage: seqkit [command] Available Commands: amplicon extract amplicon (or specific region around it) via primer(s) bam monitoring and online histograms of BAM record features common find common sequences of multiple files by id/name/sequence concat concatenate sequences with the same ID from multiple files convert convert FASTQ quality encoding between Sanger, Solexa and Illumina duplicate duplicate sequences N times fa2fq retrieve corresponding FASTQ records by a FASTA file faidx create FASTA index file and extract subsequence fish look for short sequences in larger sequences using local alignment fq2fa convert FASTQ to FASTA fx2tab convert FASTA/Q to tabular format (and length, GC content, average quality...) genautocomplete generate shell autocompletion script (bash|zsh|fish|powershell) grep search sequences by ID/name/sequence/sequence motifs, mismatch allowed head print first N FASTA/Q records head-genome print sequences of the first genome with common prefixes in name locate locate subsequences/motifs, mismatch allowed mutate edit sequence (point mutation, insertion, deletion) pair match up paired-end reads from two fastq files range print FASTA/Q records in a range (start:end) rename rename duplicated IDs replace replace name/sequence by regular expression restart reset start position for circular genome rmdup remove duplicated sequences by ID/name/sequence sample sample sequences by number or proportion sana sanitize broken single line FASTQ files scat real time recursive concatenation and streaming of fastx files seq transform sequences (extract ID, filter by length, remove gaps, reverse complement...) shuffle shuffle sequences sliding extract subsequences in sliding windows sort sort sequences by id/name/sequence/length split split sequences into files by id/seq region/size/parts (mainly for FASTA) split2 split sequences into files by size/parts (FASTA, PE/SE FASTQ) stats simple statistics of FASTA/Q files subseq get subsequences by region/gtf/bed, including flanking sequences sum compute message digest for all sequences in FASTA/Q files tab2fx convert tabular format to FASTA/Q format translate translate DNA/RNA to protein sequence (supporting ambiguous bases) version print version information and check for update watch monitoring and online histograms of sequence features Flags: --alphabet-guess-seq-length int length of sequence prefix of the first FASTA record based on which seqkit guesses the sequence type (0 for whole seq) (default 10000) --compress-level int compression level for gzip, zstd, xz and bzip2. type \"seqkit -h\" for the range and default value for each format (default -1) -h, --help help for seqkit --id-ncbi FASTA head is NCBI-style, e.g. >gi|110645304|ref|NC_002516.2| Pseud... --id-regexp string regular expression for parsing ID (default \"^(\\\\S+)\\\\s?\") --infile-list string file of input files list (one file per line), if given, they are appended to files from cli arguments -w, --line-width int line width when outputting FASTA format (0 for no wrap) (default 60) -o, --out-file string out file (\"-\" for stdout, suffix .gz for gzipped out) (default \"-\") --quiet be quiet and do not show extra information -t, --seq-type string sequence type (dna|rna|protein|unlimit|auto) (for auto, it automatically detect by the first sequence) (default \"auto\") -j, --threads int number of CPUs. can also set with environment variable SEQKIT_THREADS) (default 4) Use \"seqkit [command] --help\" for more information about a command.","title":"seqkit"},{"location":"usage/#datasets","text":"Datasets from The miRBase Sequence Database -- Release 21 hairpin.fa.gz mature.fa.gz miRNA.diff.gz Human genome from ensembl (For seqkit subseq ) Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz Homo_sapiens.GRCh38.84.gtf.gz Homo_sapiens.GRCh38.84.bed.gz is converted from Homo_sapiens.GRCh38.84.gtf.gz by gtf2bed with command zcat Homo_sapiens.GRCh38.84.gtf.gz \\ | gtf2bed --do-not-sort \\ | gzip -c > Homo_sapiens.GRCh38.84.bed.gz Only DNA and gtf/bed data of Chr1 were used: chr1.fa.gz seqkit grep -p 1 Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa.gz -o chr1.fa.gz chr1.gtf.gz zcat Homo_sapiens.GRCh38.84.gtf.gz | grep -w '^1' | gzip -c > chr1.gtf.gz chr1.bed.gz zcat Homo_sapiens.GRCh38.84.bed.gz | grep -w '^1' | gzip -c > chr1.bed.gz","title":"Datasets"},{"location":"usage/#seq","text":"Usage transform sequences (extract ID, filter by length, remove gaps, reverse complement...) Usage: seqkit seq [flags] Flags: -k, --color colorize sequences - to be piped into \"less -R\" -p, --complement complement sequence, flag '-v' is recommended to switch on --dna2rna DNA to RNA -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for seq -l, --lower-case print sequences in lower case -M, --max-len int only print sequences shorter than or equal to the maximum length (-1 for no limit) (default -1) -R, --max-qual float only print sequences with average quality less than this limit (-1 for no limit) (default -1) -m, --min-len int only print sequences longer than or equal to the minimum length (-1 for no limit) (default -1) -Q, --min-qual float only print sequences with average quality qreater or equal than this limit (-1 for no limit) (default -1) -n, --name only print names -i, --only-id print ID instead of full head -q, --qual only print qualities -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -g, --remove-gaps remove gaps -r, --reverse reverse sequence --rna2dna RNA to DNA -s, --seq only print sequences -u, --upper-case print sequences in upper case -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Read and print From file: $ seqkit seq hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA $ seqkit seq reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII From stdin: zcat hairpin.fa.gz | seqkit seq Sequence types By default, seqkit seq automatically detect the sequence type $ echo -e \">seq\\nacgtryswkmbdhvACGTRYSWKMBDHV\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA DNA 1 28 28 28 28 $ echo -e \">seq\\nACGUN ACGUN\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1 11 11 11 11 $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA Protein 1 23 23 23 23 $ echo -e \"@read\\nACTGCN\\n+\\n@IICCG\" | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTQ DNA 1 6 6 6 6 You can also set sequence type by flag -t ( --seq-type ). But this only take effect on subcommands seq and locate . $ echo -e \">seq\\nabcdefghijklmnpqrstvwyz\" | seqkit seq -t dna [INFO] when flag -t (--seq-type) given, flag -v (--validate-seq) is automatically switched on [ERRO] error when parsing seq: seq (invalid DNAredundant letter: e) Only print names Full name: $ seqkit seq hairpin.fa.gz -n cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop Only ID: $ seqkit seq hairpin.fa.gz -n -i cel-let-7 cel-lin-4 cel-mir-1 Custom ID region by regular expression (this could be applied to all subcommands): $ seqkit seq hairpin.fa.gz -n -i --id-regexp \"^[^\\s]+\\s([^\\s]+)\\s\" MI0000001 MI0000002 MI0000003 Only print seq (global flag -w defines the output line width, 0 for no wrap) $ seqkit seq hairpin.fa.gz -s -w 0 UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAGU Convert multi-line FASTQ to 4-line FASTQ $ seqkit seq reads_1.fq.gz -w 0 Reverse comlement sequence $ seqkit seq hairpin.fa.gz -r -p >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA Remove gaps and to lower/upper case $ echo -e \">seq\\nACGT-ACTGC-ACC\" | seqkit seq -g -u >seq ACGTACTGCACC RNA to DNA $ echo -e \">seq\\nUCAUAUGCUUGUCUCAAAGAUUA\" | seqkit seq --rna2dna >seq TCATATGCTTGTCTCAAAGATTA Filter by sequence length $ cat hairpin.fa | seqkit seq | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 28,645 2,949,871 39 103 2,354 $ cat hairpin.fa | seqkit seq -m 100 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,975 1,565,486 100 142.6 2,354 $ cat hairpin.fa | seqkit seq -m 100 -M 1000 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 10,972 1,560,270 100 142.2 938","title":"seq"},{"location":"usage/#subseq","text":"Usage get subsequences by region/gtf/bed, including flanking sequences. Attentions: 1. Use \"seqkit grep\" for extract subsets of sequences. \"seqtk subseq seqs.fasta id.txt\" equals to \"seqkit grep -f id.txt seqs.fasta\" Recommendation: 1. Use plain FASTA file, so seqkit could utilize FASTA index. 2. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit subseq [flags] Flags: --bed string by tab-delimited BED file --chr strings select limited sequence with sequence IDs when using --gtf or --bed (multiple value supported, case ignored) -d, --down-stream int down stream length --feature strings select limited feature types (multiple value supported, case ignored, only works with GTF) --gtf string by GTF (version 2.2) file --gtf-tag string output this tag as sequence comment (default \"gene_id\") -h, --help help for subseq -f, --only-flank only return up/down stream sequence -r, --region string by region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases, 13:-1 for cutting first 12 bases. type \"seqkit subseq -h\" for more examples -u, --up-stream int up stream length -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples Recommendation: use plain FASTA file, so seqkit could utilize FASTA index. First 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 1:12 Last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r -12:-1 Subsequences without first and last 12 bases $ zcat hairpin.fa.gz | seqkit subseq -r 13:-13 Get subsequence by GTF file $ cat t.fa >seq actgACTGactgn $ cat t.gtf seq test CDS 5 8 . . . gene_id \"A\"; transcript_id \"\"; seq test CDS 5 8 . - . gene_id \"B\"; transcript_id \"\"; $ seqkit subseq --gtf t.gtf t.fa >seq_5:8:. A ACTG >seq_5:8:- B CAGT Human genome example: AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. We could specify chromesomes and features. $ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa > chr1.gtf.cds.fa $ seqkit stats chr1.gtf.cds.fa file format type num_seqs sum_len min_len avg_len max_len chr1.gtf.cds.fa FASTA DNA 65,012 9,842,274 1 151.4 12,045 Get CDS and 3bp up-stream sequences $ seqkit subseq --gtf t.gtf t.fa -u 3 >seq_5:8:._us:3 A ctgACTG >seq_5:8:-_us:3 B agtCAGT Get 3bp up-stream sequences of CDS, not including CDS $ seqkit subseq --gtf t.gtf t.fa -u 3 -f >seq_5:8:._usf:3 A ctg >seq_5:8:-_usf:3 B agt Get subsequences by BED file. AVOID loading all data from Homo_sapiens.GRCh38.84.gtf.gz, the uncompressed data are so big and may exhaust your RAM. $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ > chr1.bed.gz.fa We may need to remove duplicated sequences $ seqkit subseq --bed Homo_sapiens.GRCh38.84.bed.gz --chr 1 hsa.fa \\ | seqkit rmdup > chr1.bed.rmdup.fa [INFO] 141060 duplicated records removed Summary: $ seqkit stats chr1.gz.*.gz file seq_format seq_type num_seqs min_len avg_len max_len chr1.gz.fa FASTA DNA 231,974 1 3,089.5 1,551,957 chr1.gz.rmdup.fa FASTA DNA 90,914 1 6,455.8 1,551,957","title":"subseq"},{"location":"usage/#sliding","text":"Usage extract subsequences in sliding windows Usage: seqkit sliding [flags] Flags: -c, --circular circular genome (same to -C/--circular-genome) -C, --circular-genome circular genome (same to -c/--circular) -g, --greedy greedy mode, i.e., exporting last subsequences even shorter than windows size -h, --help help for sliding -s, --step int step size -S, --sufix string suffix added to the sequence ID -W, --window int window size Examples General use $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN Greedy mode $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -g >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-12 gtNN >seq_sliding:10-15 N Circular genome $ echo -e \">seq\\nACGTacgtNN\" | seqkit sliding -s 3 -W 6 -C >seq_sliding:1-6 ACGTac >seq_sliding:4-9 TacgtN >seq_sliding:7-2 gtNNAC >seq_sliding:10-5 NACGTa Generate GC content for ploting $ zcat hairpin.fa.gz \\ | seqkit sliding -s 5 -W 30 \\ | seqkit fx2tab -n -g cel-let-7_sliding:1-30 50.00 cel-let-7_sliding:6-35 46.67 cel-let-7_sliding:11-40 43.33 cel-let-7_sliding:16-45 36.67 cel-let-7_sliding:21-50 33.33 cel-let-7_sliding:26-55 40.00 ...","title":"sliding"},{"location":"usage/#stats","text":"Usage simple statistics of FASTA/Q files Columns: 1. file input file, \"-\" for STDIN 2. format FASTA or FASTQ 3. type DNA, RNA, Protein or Unlimit 4. num_seqs number of sequences 5. sum_len number of bases or residues , with gaps or spaces counted 6. min_len minimal sequence length , with gaps or spaces counted 7. avg_len average sequence length , with gaps or spaces counted 8. max_len miximal sequence length , with gaps or spaces counted 9. Q1 first quartile of sequence length , with gaps or spaces counted 10. Q2 median of sequence length , with gaps or spaces counted 11. Q3 third quartile of sequence length , with gaps or spaces counted 12. sum_gap number of gaps 13. N50 N50. https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics#N50 14. Q20(%) percentage of bases with the quality score greater than 20 15. Q30(%) percentage of bases with the quality score greater than 30 16. GC(%) percentage of GC content Attentions: 1. Sequence length metrics (sum_len, min_len, avg_len, max_len, Q1, Q2, Q3) count the number of gaps or spaces. You can remove them with \"seqkit seq -g\": seqkit seq -g input.fasta | seqkit stats Tips: 1. For lots of small files (especially on SDD), use big value of '-j' to parallelize counting. 2. Extract one metric with csvtk (https://github.com/shenwei356/csvtk): seqkit stats -Ta input.fastq.gz | csvtk cut -t -f \"Q30(%)\" | csvtk del-header Usage: seqkit stats [flags] Aliases: stats, stat Flags: -a, --all all statistics, including quartiles of seq length, sum_gap, N50 -b, --basename only output basename of files -E, --fq-encoding string fastq quality encoding. available values: 'sanger', 'solexa', 'illumina-1.3+', 'illumina-1.5+', 'illumina-1.8+'. (default \"sanger\") -G, --gap-letters string gap letters (default \"- .\") -h, --help help for stats -e, --skip-err skip error, only show warning message -i, --stdin-label string label for replacing default \"-\" for stdin (default \"-\") -T, --tabular output in machine-friendly tabular format Eexamples General use $ seqkit stats *.f{a,q}.gz file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Machine-friendly tabular format $ seqkit stats *.f{a,q}.gz -T file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # So you can process the result with tools like csvtk: http://bioinf.shenwei.me/csvtk $ seqkit stats *.f{a,q}.gz -T | csvtk pretty -t file format type num_seqs sum_len min_len avg_len max_len ----------------- ------ ---- -------- ------- ------- ------- ------- hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 # To markdown $ seqkit stats *.f{a,q}.gz -T | csvtk csv2md -t |file |format|type|num_seqs|sum_len|min_len|avg_len|max_len| |:----------------|:-----|:---|:-------|:------|:------|:------|:------| |hairpin.fa.gz |FASTA |RNA |28645 |2949871|39 |103.0 |2354 | |mature.fa.gz |FASTA |RNA |35828 |781222 |15 |21.8 |34 | |Illimina1.8.fq.gz|FASTQ |DNA |10000 |1500000|150 |150.0 |150 | |reads_1.fq.gz |FASTQ |DNA |2500 |567516 |226 |227.0 |229 | |reads_2.fq.gz |FASTQ |DNA |2500 |560002 |223 |224.0 |225 | file format type num_seqs sum_len min_len avg_len max_len hairpin.fa.gz FASTA RNA 28645 2949871 39 103.0 2354 mature.fa.gz FASTA RNA 35828 781222 15 21.8 34 Illimina1.8.fq.gz FASTQ DNA 10000 1500000 150 150.0 150 reads_1.fq.gz FASTQ DNA 2500 567516 226 227.0 229 reads_2.fq.gz FASTQ DNA 2500 560002 223 224.0 225 Extra information $ seqkit stats *.f{a,q}.gz -a file format type num_seqs sum_len min_len avg_len max_len Q1 Q2 Q3 sum_gap N50 Q20(%) Q30(%) GC(%) hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 76 91 111 0 101 0 0 45.77 mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 21 22 22 0 22 0 0 47.6 Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 75 150 75 0 150 96.16 89.71 49.91 nanopore.fq.gz FASTQ DNA 4,000 1,798,723 153 449.7 6,006 271 318 391 0 395 40.79 12.63 46.66 reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 227 227 227 0 227 91.24 86.62 53.63 reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 224 224 224 0 224 91.06 87.66 54.77 Parallelize counting files, it's much faster for lots of small files, especially for files on SSD seqkit stats -j 10 refseq/virual/*.fna.gz Skip error $ seqkit stats tests/* [ERRO] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format $ seqkit stats tests/* -e [WARN] tests/hairpin.fa.fai: fastx: invalid FASTA/Q format [WARN] tests/hairpin.fa.seqkit.fai: fastx: invalid FASTA/Q format [WARN] tests/miRNA.diff.gz: fastx: invalid FASTA/Q format [WARN] tests/test.sh: fastx: invalid FASTA/Q format file format type num_seqs sum_len min_len avg_len max_len tests/contigs.fa FASTA DNA 9 54 2 6 10 tests/hairpin.fa FASTA RNA 28,645 2,949,871 39 103 2,354 tests/Illimina1.5.fq FASTQ DNA 1 100 100 100 100 tests/Illimina1.8.fq.gz FASTQ DNA 10,000 1,500,000 150 150 150 tests/hairpin.fa.gz FASTA RNA 28,645 2,949,871 39 103 2,354 tests/reads_1.fq.gz FASTQ DNA 2,500 567,516 226 227 229 tests/mature.fa.gz FASTA RNA 35,828 781,222 15 21.8 34 tests/reads_2.fq.gz FASTQ DNA 2,500 560,002 223 224 225 Output basename instead of full path ( -b/--basename )","title":"stats"},{"location":"usage/#sum","text":"Usage compute message digest for all sequences in FASTA/Q files Attentions: 1. Sequence headers and qualities are skipped, only sequences matter. 2. The order of sequences records does not matter. 3. Circular complete genomes are supported with the flag -c/--circular. - The same double-stranded genomes with different start positions or in reverse complement strand will not affect the result. - For single-stranded genomes like ssRNA genomes, use -s/--single-strand. - The message digest would change with different values of k-mer size. 4. Multiple files are processed in parallel (-j/--threads). Method: 1. Converting the sequences to low cases, optionally removing gaps (-g). 2. Computing the hash (xxhash) for all sequences or k-mers of a circular complete genome (-c/--circular). 3. Sorting all hash values, for ignoring the order of sequences. 4. Computing MD5 digest from the hash values, sequences length, and the number of sequences. Following the seqhash in Poly (https://github.com/TimothyStiles/poly/), We add meta information to the message digest, with the format of: seqkit.<version>_<seq type><seq structure><strand>_<kmer size>_<seq digest> <version>: digest version <seq type>: 'D' for DNA, 'R' for RNA, 'P' for protein, 'N' for others <seq structure>: 'L' for linear sequence, 'C' for circular genome <strand>: 'D' for double-stranded, 'S' for single-stranded <kmer size>: 0 for linear sequence, other values for circular genome Examples: seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94 DNA.fq.gz seqkit.v0.1_PLS_k0_c244954e4960dd2a1409cd8ee53d92b9 Protein.fasta seqkit.v0.1_RLS_k0_0f1fb263f0c05a259ae179a61a80578d single-stranded RNA.fasta seqkit.v0.1_DCD_k31_e59dad6d561f1f1f28ebf185c6f4c183 double-stranded-circular DNA.fasta seqkit.v0.1_DCS_k31_dd050490cd62ea5f94d73d4d636b7d60 single-stranded-circular DNA.fasta Usage: seqkit sum [flags] Flags: -a, --all show all information, including the sequences length and the number of sequences -b, --basename only output basename of files -c, --circular the file contains a single cicular genome sequence -G, --gap-letters string gap letters (default \"- \\t.*\") -h, --help help for sum -k, --kmer-size int k-mer size for processing circular genomes (default 1000) -g, --remove-gaps remove gaps --rna2dna convert RNA to DNA -s, --single-strand only consider the positive strand of a circular genome, e.g., ssRNA virus genomes Examples: A, B, C, D are the same vircular genomes with different starting positions or strands: $ cat virus-{A,B,C,D}.fasta >seq TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA >seq.revcom TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA >seq.new-start GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT >seq.revcom.new-start TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT # cat to one file $ cat virus-{A,B,C,D}.fasta > virues.fasta # shuffle and rename $ cat virus-{A,B,C,D}.fasta \\ | seqkit shuffle \\ | seqkit replace -p '.*' -r '{nr}' \\ | tee virues.shuffled.fasta >1 TTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCAT >2 TGGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAA >3 GGTAGGGAGTTGAGTAGCATGGGTATAGTATAGTGTCATGATGCCAGATTTTAAAAAAAT >4 TTTTTTTAAAATCTGGCATCATGACACTATACTATACCCATGCTACTCAACTCCCTACCA Sum of all files (the sequences order does not matter): $ seqkit sum viru*.fasta seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17 virues.fasta seqkit.v0.1_DLS_k0_9bbe0abefc26013dffdde952a6725b17 virues.shuffled.fasta seqkit.v0.1_DLS_k0_176250c8d1cde6c385397df525aa1a94 virus-A.fasta seqkit.v0.1_DLS_k0_7a813339f9ae686b376b1df55cd596ca virus-B.fasta seqkit.v0.1_DLS_k0_0fd51028bfbfa85ddbdd2b86ef7bd1c1 virus-C.fasta seqkit.v0.1_DLS_k0_88b1d20dd0fe0dbf41c00b075fee4e4e virus-D.fasta Circular genomes (the same genomes with different start positions or in reverse complement strand will not affect the result): $ seqkit sum -c -k 21 virus-*.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-A.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-B.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-C.fasta seqkit.v0.1_DCD_k21_7efd18ce33380268d3aa335ffd2dd1cc virus-D.fasta $ seqkit sum -c -k 51 virus-*.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-A.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-B.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-C.fasta seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-D.fasta # collect files with the same genomes $ seqkit sum -c -k 51 virus-*.fasta | csvtk fold -Ht -f 1 -v 2 seqkit.v0.1_DCD_k51_39e267864fddeafd7a5cacd77e0a6a11 virus-A.fasta; virus-B.fasta; virus-C.fasta; virus-D.fasta","title":"sum"},{"location":"usage/#faidx","text":"Usage create FASTA index file and extract subsequence This command is similar with \"samtools faidx\" but has some extra features: 1. output full header line with the flag -f 2. support regular expression as sequence ID with the flag -r 3. if you have large number of IDs, you can use: seqkit faidx seqs.fasta -l IDs.txt Attentions: 1. The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit faidx [flags] <fasta-file> [regions...] Flags: -f, --full-head print full header line instead of just ID. New fasta index file ending with .seqkit.fai will be created -h, --help help for faidx -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -l, --region-file string file containing a list of regions -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed -r, --use-regexp IDs are regular expression. But subseq region is not supported here. Example common usage like samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 >hsa-let-7a-1 UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU output full header, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1 hsa-let-7a-2 -f >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU extract subsequence of specific region $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1-10 >hsa-let-7a-1:1-10 UGGGAUGAGG $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:-10--1 >hsa-let-7a-1:-10--1 GUCUUUCCUA $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:1 >hsa-let-7a-1:1-1 U supporting begin > start , i.e., returning reverse complement sequence, not supported by samtools faidx $ seqkit faidx tests/hairpin.fa hsa-let-7a-1:10-1 >hsa-let-7a-1:10-1 CCUCAUCCCA use regular expression $ seqkit faidx tests/hairpin.fa hsa -r | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,881 154,002 41 81.9 180","title":"faidx"},{"location":"usage/#watch","text":"Usage monitoring and online histograms of sequence features Usage: seqkit watch [flags] Flags: -B, --bins int number of histogram bins (default -1) -W, --delay int sleep this many seconds after online plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -f, --fields string target fields, available values: ReadLen, MeanQual, GC, GCSkew (default \"ReadLen\") -h, --help help for watch -O, --img string save histogram to this PDF/image file -H, --list-fields print out a list of available fields -L, --log log10(x+1) transform numeric values -x, --pass pass through mode (write input to stdout) -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -Q, --quiet-mode supress all plotting to stderr -R, --reset reset histogram after every report -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Histogram of sequence length seqkit watch --fields ReadLen nanopore.fq.gz -O len.png Dynamic histogram of log sequence length seqkit watch --log --fields ReadLen nanopore.fq.gz Histogram of mean base qualities every 500 record, also saved as png seqkit watch -p 500 -O qhist.png -f MeanQual nanopore.fq.gz","title":"watch"},{"location":"usage/#sana","text":"Usage sanitize broken single line FASTQ files Usage: seqkit sana [flags] Flags: -A, --allow-gaps allow gap character (-) in sequences -i, --format string input and output format: fastq or fasta (default \"fastq\") -h, --help help for sana -I, --in-format string input format: fastq or fasta -O, --out-format string output format: fastq or fasta -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) Examples Rescue usable reads from fastq file with malformed records. seqkit sana broken.fq.gz -o rescued.fq.gz","title":"sana"},{"location":"usage/#scat","text":"Usage real time recursive concatenation and streaming of fastx files Usage: seqkit scat [flags] Flags: -A, --allow-gaps allow gap character (-) in sequences -d, --delta int minimum size increase in kilobytes to trigger parsing (default 5) -D, --drop-time string Notification drop interval (default \"500ms\") -f, --find-only concatenate exisiting files and quit -i, --format string input and output format: fastq or fasta (fastq) (default \"fastq\") -g, --gz-only only look for gzipped files (.gz suffix) -h, --help help for scat -I, --in-format string input format: fastq or fasta (fastq) -O, --out-format string output format: fastq or fasta -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -r, --regexp string regexp for watched files, by default guessed from the input format -T, --time-limit string quit after inactive for this time period -p, --wait-pid int after process with this PID exited (default -1) Examples Concatenate all fastq files recursively under a directory seqkit scat -j 4 -f fastq_dir > all_records.fq Watch a directory and stream fastq records in real time until interrupt is recieved and plot read lengths using seqkit watch : seqkit scat -j 4 fastq_dir | seqkit watch -f ReadLen - Watch a directory and stream fastq records in real time until there is no write activity under the directory for 5 seconds: seqkit scat -j 4 -T \"5s\" fastq_dir > all_records.fq Watch a directory and stream fastq records in real time until a process with a specified PID is alive: seqkit scat -j 4 -p $PID fastq_dir > all_records.fq Notes : You might need to increase the ulimit allowance on open files if you intend to stream fastx records from a large number of files.","title":"scat"},{"location":"usage/#fq2fa","text":"Usage convert FASTQ to FASTA Usage: seqkit fq2fa [flags] Examples seqkit fq2fa reads_1.fq.gz -o reads_1.fa.gz","title":"fq2fa"},{"location":"usage/#fa2fq","text":"Usage retrieve corresponding FASTQ records by a FASTA file Attention: 1. We assume the FASTA file comes from the FASTQ file, so they share sequence IDs, and sequences in FASTA should be subseq of sequences in FASTQ file. Usage: seqkit fa2fq [flags] Flags: -f, --fasta-file string FASTA file) -h, --help help for fa2fq -P, --only-positive-strand only search on positive strand","title":"fa2fq"},{"location":"usage/#fx2tab-tab2fx","text":"Usage (fx2tab) convert FASTA/Q to tabular format, and provide various information, like sequence length, GC content/GC skew. Attention: 1. Fixed three columns (ID, sequence, quality) are outputted for either FASTA or FASTQ, except when flag -n/--name is on. This is for format compatibility. Usage: seqkit fx2tab [flags] Flags: -a, --alphabet print alphabet letters -q, --avg-qual print average quality of a read -B, --base-content strings print base content. (case ignored, multiple values supported) e.g. -B AT -B N -C, --base-count strings print base count. (case ignored, multiple values supported) e.g. -C AT -C N -I, --case-sensitive calculate case sensitive base content/sequence hash -g, --gc print GC content -G, --gc-skew print GC-Skew -H, --header-line print header line -h, --help help for fx2tab -l, --length print sequence length -n, --name only print names (no sequences and qualities) -Q, --no-qual only output two column even for FASTQ file -i, --only-id print ID instead of full head -b, --qual-ascii-base int ASCII BASE, 33 for Phred+33 (default 33) -s, --seq-hash print hash (MD5) of sequence Usage (tab2fx) convert tabular format (first two/three columns) to FASTA/Q format Usage: seqkit tab2fx [flags] Flags: -b, --buffer-size string size of buffer, supported unit: K, M, G. You need increase the value when \"bufio.Scanner: token too long\" error reported (default \"1G\") -p, --comment-line-prefix strings comment line prefix (default [#,//]) -h, --help help for tab2fx Examples Default output $ seqkit fx2tab hairpin.fa.gz | head -n 2 cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACGGUUUGAGCAGAU Print sequence length, GC content, and only print names (no sequences), we could also print title line by flag -H . $ seqkit fx2tab hairpin.fa.gz -l -g -n -i -H | head -n 4 | csvtk -t -C '&' pretty #name seq qual length GC cel-let-7 99 43.43 cel-lin-4 94 54.26 cel-mir-1 96 40.62 Use fx2tab and tab2fx in pipe $ zcat hairpin.fa.gz | seqkit fx2tab | seqkit tab2fx $ zcat reads_1.fq.gz | seqkit fx2tab | seqkit tab2fx Sort sequences by length (use seqkit sort -l ) $ zcat hairpin.fa.gz \\ | seqkit fx2tab -l \\ | sort -t\"`echo -e '\\t'`\" -n -k4,4 \\ | seqkit tab2fx >cin-mir-4129 MI0015684 Ciona intestinalis miR-4129 stem-loop UUCGUUAUUGGAAGACCUUAGUCCGUUAAUAAAGGCAUC >mmu-mir-7228 MI0023723 Mus musculus miR-7228 stem-loop UGGCGACCUGAACAGAUGUCGCAGUGUUCGGUCUCCAGU >cin-mir-4103 MI0015657 Ciona intestinalis miR-4103 stem-loop ACCACGGGUCUGUGACGUAGCAGCGCUGCGGGUCCGCUGU $ seqkit sort -l hairpin.fa.gz Sorting or filtering by GC (or other base by -flag -B ) content could also achieved in similar way. Get first 1000 sequences (use seqkit head -n 1000 ) $ seqkit fx2tab hairpin.fa.gz | head -n 1000 | seqkit tab2fx $ seqkit fx2tab reads_1.fq.gz | head -n 1000 | seqkit tab2fx Extension After converting FASTA to tabular format with seqkit fx2tab , it could be handled with CSV/TSV tools, e.g. csvtk , a cross-platform, efficient and practical CSV/TSV toolkit csvtk grep could be used to filter sequences (similar with seqkit grep ) csvtk inter computates intersection of multiple files. It could achieve similar function as seqkit common -n along with shell. csvtk join joins multiple CSV/TSV files by multiple IDs.","title":"fx2tab &amp; tab2fx"},{"location":"usage/#convert","text":"Usage convert FASTQ quality encoding between Sanger, Solexa and Illumina Usage: seqkit convert [flags] Flags: -d, --dry-run dry run -f, --force for Illumina-1.8+ -> Sanger, truncate scores > 40 to 40 --from string source quality encoding. if not given, we'll guess it -h, --help help for convert -n, --nrecords int number of records for guessing quality encoding (default 1000) -N, --thresh-B-in-n-most-common int threshold of 'B' in top N most common quality for guessing Illumina 1.5. (default 2) -F, --thresh-illumina1.5-frac float threshold of faction of Illumina 1.5 in the leading N records (default 0.1) --to string target quality encoding (default \"Sanger\") Examples: Note that seqkit convert always output sequences. The test dataset contains score 41 ( J ): $ seqkit head -n 1 tests/Illimina1.8.fq.gz @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< By default, nothing changes when converting Illumina 1.8 to Sanger. A warning message show that source and target quality encoding match. $ seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger [WARN] source and target quality encoding match. @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< When switching flag --force on, J (41) was converted to I (40). $ seqkit convert tests/Illimina1.8.fq.gz -f | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + #AAAFAAIFFFIII<IIIIIFFFIFIIIIIFIIAIIIFIIFIFIIIIFAFI<IA<FFI7FIIFIIAAIIII<IIIIIIIFIIIAIIIIIFII77<IIII-F7A-FIFFIIIIII<FFI-<7FIIIFII)A7)7AA<7--)<-7F-A7FA< Other cases: To Illumina-1.5. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iiiiieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[ To Illumina-1.5 and back to Sanger. $ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit convert | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.8+] [INFO] guessed quality encoding: Illumina-1.8+ [INFO] converting Illumina-1.8+ -> Illumina-1.5+ [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @ST-E00493:56:H33MFALXX:4:1101:23439:1379 1:N:0:NACAACCA NCGTGGAAAGACGCTAAGATTGTGATGTGCTTCCCTGACGATTACAACTGGCGTAAGGACGTTTTGCCTACCTATAAGGCTAACCGTAAGGGTTCTCGCAAGCCTGTAGGTTACAAGAGGTTCGTAGCCGAAGTGATGGCTGACTCACGG + !AAAFAAJFFFJJJ<JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ<JA<FFJ7FJJFJJAAJJJJ<JJJJJJJFJJJAJJJJJFJJ77<JJJJ-F7A-FJFFJJJJJJ<FFJ-<7FJJJFJJ)A7)7AA<7--)<-7F-A7FA< Checking encoding $ seqkit convert tests/Illimina1.8.fq.gz --from Solexa [INFO] converting Solexa -> Sanger [ERRO] seq: invalid Solexa quality Real Illumina 1.5+ data $ seqkit seq tests/Illimina1.5.fq @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + efcfffffcfeefffcffffffddf`feed]`]_Ba_^__[YBBBBBBBBBBRTT\\]][]dddd`ddd^dddadd^BBBBBBBBBBBBBBBBBBBBBBBB $ seqkit convert tests/Illimina1.5.fq | seqkit head -n 1 [INFO] possible quality encodings: [Illumina-1.5+] [INFO] guessed quality encoding: Illumina-1.5+ [INFO] converting Illumina-1.5+ -> Sanger @HWI-EAS209_0006_FC706VJ:5:58:5894:21141#ATCACG/1 TTAATTGGTAAATAAATCTCCTAATAGCTTAGATNTTACCTTNNNNNNNNNNTAGTTTCTTGAGATTTGTTGGGGGAGACATTTTTGTGATTGCCTTGAT + FGDGGGGGDGFFGGGDGGGGGGEEGAGFFE>A>@!B@?@@<:!!!!!!!!!!355=>><>EEEEAEEE?EEEBEE?!!!!!!!!!!!!!!!!!!!!!!!!","title":"convert"},{"location":"usage/#translate","text":"Usage translate DNA/RNA to protein sequence (supporting ambiguous bases) Note: 1. This command supports codons containing any ambiguous base. Please switch on flag -L INT for details. e.g., for standard table: ACN -> T CCN -> P CGN -> R CTN -> L GCN -> A GGN -> G GTN -> V TCN -> S MGR -> R YTR -> L Translate Tables/Genetic Codes: # https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes 1: The Standard Code 2: The Vertebrate Mitochondrial Code 3: The Yeast Mitochondrial Code 4: The Mold, Protozoan, and Coelenterate Mitochondrial Code and the Mycoplasma/Spiroplasma Code 5: The Invertebrate Mitochondrial Code 6: The Ciliate, Dasycladacean and Hexamita Nuclear Code 9: The Echinoderm and Flatworm Mitochondrial Code 10: The Euplotid Nuclear Code 11: The Bacterial, Archaeal and Plant Plastid Code 12: The Alternative Yeast Nuclear Code 13: The Ascidian Mitochondrial Code 14: The Alternative Flatworm Mitochondrial Code 16: Chlorophycean Mitochondrial Code 21: Trematode Mitochondrial Code 22: Scenedesmus obliquus Mitochondrial Code 23: Thraustochytrium Mitochondrial Code 24: Pterobranchia Mitochondrial Code 25: Candidate Division SR1 and Gracilibacteria Code 26: Pachysolen tannophilus Nuclear Code 27: Karyorelict Nuclear 28: Condylostoma Nuclear 29: Mesodinium Nuclear 30: Peritrich Nuclear 31: Blastocrithidia Nuclear Usage: seqkit translate [flags] Flags: -x, --allow-unknown-codon translate unknown code to 'X'. And you may not use flag --trim which removes 'X' -F, --append-frame append frame information to sequence ID --clean change all STOP codon positions from the '*' character to 'X' (an unknown residue) -f, --frame strings frame(s) to translate, available value: 1, 2, 3, -1, -2, -3, and 6 for all six frames (default [1]) -h, --help help for translate -M, --init-codon-as-M translate initial codon at beginning to 'M' -l, --list-transl-table int show details of translate table N, 0 for all (default -1) -L, --list-transl-table-with-amb-codons int show details of translate table N (including ambigugous codons), 0 for all. (default -1) -T, --transl-table int translate table/genetic code, type 'seqkit translate --help' for more details (default 1) --trim remove all 'X' and '*' characters from the right end of the translation Examples common usage $ seqkit translate tests/mouse-p53-cds.fna >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD* trim the * $ seqkit translate tests/mouse-p53-cds.fna --trim >lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS] MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD different translate table $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --trim >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF different frame $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] SESNFSE*ITNNSYGKSKHKAPSPLIISFHFFYKFRI*LSY*ERSFCFISNCFIVI*LCF NSS*TFEDFSPCLFLH $ cat tests/Lactococcus-lactis-phage-BK5-T-ORF25.fasta \\ | seqkit seq -r -p \\ | seqkit translate -T 11 --frame -1 >CAC80166.1 hypothetical protein [Lactococcus phage BK5-T] MEEQAWREVLERLARIETKLDNYETVRDKAERALLIAQSNAKLIEKMEANNKWAWGFMLT LAVTVIGYLFTKIRF* show details of translate table 1 $ seqkit translate -l 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAT: N ACA: T, ACC: T, ACG: T, ACT: T AGA: R, AGC: S, AGG: R, AGT: S ATA: I, ATC: I, ATG: M, ATT: I CAA: Q, CAC: H, CAG: Q, CAT: H CCA: P, CCC: P, CCG: P, CCT: P CGA: R, CGC: R, CGG: R, CGT: R CTA: L, CTC: L, CTG: L, CTT: L GAA: E, GAC: D, GAG: E, GAT: D GCA: A, GCC: A, GCG: A, GCT: A GGA: G, GGC: G, GGG: G, GGT: G GTA: V, GTC: V, GTG: V, GTT: V TAA: *, TAC: Y, TAG: *, TAT: Y TCA: S, TCC: S, TCG: S, TCT: S TGA: *, TGC: C, TGG: W, TGT: C TTA: L, TTC: F, TTG: L, TTT: F show details of translate table 1, including ambigugous codons $ seqkit translate -L 1 The Standard Code (transl_table=1) Source: https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes#SG1 Initiation Codons: ATG, CTG, TTG Stop Codons: TAA, TAG, TGA Stranslate Table: AAA: K, AAC: N, AAG: K, AAR: K, AAT: N, AAY: N ACA: T, ACC: T, ACM: T, ACG: T, ACR: T, ACS: T, ACV: T, ACT: T, ACW: T, ACY: T, ACH: T, ACK: T, ACD: T, ACB: T, ACN: T AGA: R, AGC: S, AGG: R, AGR: R, AGT: S, AGY: S ATA: I, ATC: I, ATM: I, ATG: M, ATT: I, ATW: I, ATY: I, ATH: I CAA: Q, CAC: H, CAG: Q, CAR: Q, CAT: H, CAY: H CCA: P, CCC: P, CCM: P, CCG: P, CCR: P, CCS: P, CCV: P, CCT: P, CCW: P, CCY: P, CCH: P, CCK: P, CCD: P, CCB: P, CCN: P CGA: R, CGC: R, CGM: R, CGG: R, CGR: R, CGS: R, CGV: R, CGT: R, CGW: R, CGY: R, CGH: R, CGK: R, CGD: R, CGB: R, CGN: R CTA: L, CTC: L, CTM: L, CTG: L, CTR: L, CTS: L, CTV: L, CTT: L, CTW: L, CTY: L, CTH: L, CTK: L, CTD: L, CTB: L, CTN: L MGA: R, MGG: R, MGR: R GAA: E, GAC: D, GAG: E, GAR: E, GAT: D, GAY: D GCA: A, GCC: A, GCM: A, GCG: A, GCR: A, GCS: A, GCV: A, GCT: A, GCW: A, GCY: A, GCH: A, GCK: A, GCD: A, GCB: A, GCN: A GGA: G, GGC: G, GGM: G, GGG: G, GGR: G, GGS: G, GGV: G, GGT: G, GGW: G, GGY: G, GGH: G, GGK: G, GGD: G, GGB: G, GGN: G GTA: V, GTC: V, GTM: V, GTG: V, GTR: V, GTS: V, GTV: V, GTT: V, GTW: V, GTY: V, GTH: V, GTK: V, GTD: V, GTB: V, GTN: V TAA: *, TAC: Y, TAG: *, TAR: *, TAT: Y, TAY: Y TCA: S, TCC: S, TCM: S, TCG: S, TCR: S, TCS: S, TCV: S, TCT: S, TCW: S, TCY: S, TCH: S, TCK: S, TCD: S, TCB: S, TCN: S TGA: *, TGC: C, TGG: W, TGT: C, TGY: C TRA: * TTA: L, TTC: F, TTG: L, TTR: L, TTT: F, TTY: F YTA: L, YTG: L, YTR: L","title":"translate"},{"location":"usage/#grep","text":"Usage search sequences by ID/name/sequence/sequence motifs, mismatch allowed Attentions: 0. By default, we match sequence ID with patterns, use \"-n/--by-name\" for matching full name instead of just ID. 1. Unlike POSIX/GNU grep, we compare the pattern to the whole target (ID/full header) by default. Please switch \"-r/--use-regexp\" on for partly matching. 2. When searching by sequences, it's partly matching, and both positive and negative strands are searched. Mismatch is allowed using flag \"-m/--max-mismatch\", you can increase the value of \"-j/--threads\" to accelerate processing. 3. Degenerate bases/residues like \"RYMM..\" are also supported by flag -d. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". 4. When providing search patterns (motifs) via flag '-p', please use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"' or -p \"\\\"A{2,}\\\"\". Because the command line argument parser accepts comma-separated-values (CSV) for multiple values (motifs). Patterns in file do not follow this rule. 5. The order of sequences in result is consistent with that in original file, not the order of the query patterns. But for FASTA file, you can use: seqkit faidx seqs.fasta --infile-list IDs.txt 6. For multiple patterns, you can either set \"-p\" multiple times, i.e., -p pattern1 -p pattern2, or give a file of patterns via \"-f/--pattern-file\". You can specify the sequence region for searching with the flag -R (--region). The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit grep [flags] Flags: -n, --by-name match by full name instead of just ID -s, --by-seq search subseq on seq, both positive and negative strand are searched, and mismatch allowed using flag -m/--max-mismatch -c, --circular circular genome -C, --count just print a count of matching records. with the -v/--invert-match flag, count non-matching records -d, --degenerate pattern/motif contains degenerate base --delete-matched delete a pattern right after being matched, this keeps the firstly matched data and speedups when using regular expressions -h, --help help for grep -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -v, --invert-match invert the sense of matching, to select non-matching records -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -P, --only-positive-strand only search on positive strand -p, --pattern strings search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern file (one record per line) -R, --region string specify sequence region for searching. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases -r, --use-regexp patterns are regular expression Examples Searching with list of sequence IDs (do not contain whitespace) $ seqkit grep -f id.txt seqs.fq.gz -o result.fq.gz # ignore case $ seqkit grep -i -f id.txt seqs.fq.gz -o result.fq.gz Just print the matched number, like GNU grep ( grep -c ) $ seqkit grep -f id.txt seqs.fq.gz -C Serching non-canonical sequence IDs, Using --id-regexp to capture IDs. Refer to section Sequence ID and seqkit seq for examples. Searching with list of sequence names (they may contain whitespace). $ seqkit grep -n -f name.txt seqs.fa.gz -o result.fa.gz Useq -r/--use-regexp for partly matching, but this may produce \"false positive\" matches . For example, seq_1 matches seq_10 with -nri . Extract human hairpins (i.e. sequences with name starting with hsa ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa >hsa-let-7a-1 MI0000060 Homo sapiens let-7a-1 stem-loop UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU ACAAUCUACUGUCUUUCCUA >hsa-let-7a-2 MI0000061 Homo sapiens let-7a-2 stem-loop AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU CCUAGCUUUCCU Remove human and mice hairpins (invert match with -v ) $ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v Extract new entries by information from miRNA.diff.gz Get IDs of new entries. $ zcat miRNA.diff.gz | grep ^# -v | grep NEW | cut -f 2 > list $ more list cfa-mir-486 cfa-mir-339-1 pmi-let-7 Extract by ID list file $ zcat hairpin.fa.gz | seqkit grep -f list > new.fa Extract sequences containing AGGCG $ cat hairpin.fa.gz | seqkit grep -s -i -p aggcg Circular genome $ echo -e \">seq\\nACGTTGCA\" >seq ACGTTGCA $ echo -e \">seq\\nACGTTGCA\" | seqkit grep -s -i -p AA $ echo -e \">seq\\nACGTTGCA\" | seqkit grep -s -i -p AA -c >seq ACGTTGCA Extract sequences containing AGGCG (allow mismatch) $ time cat hairpin.fa.gz | seqkit grep -s -i -p aggcg | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 1,181 145,789 49 123.4 2,354 real 0m0.058s user 0m0.100s sys 0m0.017s $ time zcat hairpin.fa.gz | seqkit grep -s -i -p aggcg -m 1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 22,290 2,375,819 39 106.6 2,354 real 0m1.081s user 0m1.305s sys 0m0.158s Extract sequences starting with AGGCG $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg Extract sequences with TTSAA (AgsI digest site) in SEQUENCE. Base S stands for C or G. $ zcat hairpin.fa.gz | seqkit grep -s -d -i -p TTSAA It's equal to but simpler than: $ zcat hairpin.fa.gz | seqkit grep -s -r -i -p TT[CG]AA Specify sequence regions for searching. e.g., leading 30 bases. $ seqkit grep -s -R 1:30 -i -r -p GCTGG","title":"grep"},{"location":"usage/#locate","text":"Usage locate subsequences/motifs, mismatch allowed Attentions: 1. Motifs could be EITHER plain sequence containing \"ACTGN\" OR regular expression like \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" for ORFs. 2. Degenerate bases/residues like \"RYMM..\" are also supported by flag -d. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". 3. When providing search patterns (motifs) via flag '-p', please use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"' or -p \"\\\"A{2,}\\\"\". Because the command line argument parser accepts comma-separated-values (CSV) for multiple values (motifs). Patterns in file do not follow this rule. 4. Mismatch is allowed using flag \"-m/--max-mismatch\", you can increase the value of \"-j/--threads\" to accelerate processing. 5. When using flag --circular, end position of matched subsequence that crossing genome sequence end would be greater than sequence length. Usage: seqkit locate [flags] Flags: --bed output in BED6 format -c, --circular circular genome. type \"seqkit locate -h\" for details -d, --degenerate pattern/motif contains degenerate base --gtf output in GTF format -h, --help help for locate -M, --hide-matched do not show matched sequences -i, --ignore-case ignore case -I, --immediate-output print output immediately, do not use write buffer -m, --max-mismatch int max mismatch when matching by seq. For large genomes like human genome, using mapping/alignment tools would be faster -G, --non-greedy non-greedy mode, faster but may miss motifs overlapping with others -P, --only-positive-strand only search on positive strand -p, --pattern strings pattern/motif (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') -f, --pattern-file string pattern/motif file (FASTA format) -F, --use-fmi use FM-index for much faster search of lots of sequence patterns -r, --use-regexp patterns/motifs are regular expression -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Locating subsequences (mismatch allowed) $ cat t.fa >seq agctggagctacc $ cat t.fa \\ | seqkit locate -p agc \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # do not show matched sequences $ cat t.fa \\ | seqkit locate -p agc -M \\ | csvtk pretty -t seqID patternName pattern strand start end seq agc agc + 1 3 seq agc agc + 7 9 seq agc agc - 8 10 seq agc agc - 2 4 # max mismatch: 1 $ cat t.fa \\ | seqkit locate -p agc -m 1 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 7 9 agc seq agc agc + 11 13 acc seq agc agc - 8 10 agc seq agc agc - 2 4 agc # max mismatch: 2 $ cat t.fa \\ | seqkit locate -p agc -m 2 \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq agc agc + 1 3 agc seq agc agc + 4 6 tgg seq agc agc + 5 7 gga seq agc agc + 7 9 agc seq agc agc + 10 12 tac seq agc agc + 11 13 acc seq agc agc - 11 13 ggt seq agc agc - 8 10 agc seq agc agc - 6 8 ctc seq agc agc - 5 7 tcc seq agc agc - 2 4 agc Locate ORFs. $ zcat hairpin.fa.gz \\ | seqkit locate -i -p \"A[TU]G(?:.{3})+?[TU](?:AG|AA|GA)\" -r \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-lin-4 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 1 36 AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGA cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) + 54 95 AUGGAUAUGGAAUGUAAAGAAGUAUGUAGAACGGGGUGGUAG cel-mir-1 A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) A[TU]G(?:.{3})+?[TU](?:AG|AA|GA) - 43 51 AUGAUAUAG Locate Motif. $ zcat hairpin.fa.gz \\ | seqkit locate -i -d -p AUGGACUN \\ | head -n 4 \\ | csvtk pretty -t seqID patternName pattern strand start end matched cel-mir-58a AUGGACUN AUGGACUN + 81 88 AUGGACUG ath-MIR163 AUGGACUN AUGGACUN - 122 129 AUGGACUC cel-mir-270 AUGGACUN AUGGACUN + 84 91 AUGGACUG Output in GTF or BED6 format, which you can use in seqkit subseq $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --bed cel-mir-58a 80 88 AUGGACUN 0 + ath-MIR163 121 129 AUGGACUN 0 - $ zcat hairpin.fa.gz | seqkit locate -i -d -p AUGGACUN --gtf cel-mir-58a SeqKit location 81 88 0 + . gene_id \"AUGGACUN\"; ath-MIR163 SeqKit location 122 129 0 - . gene_id \"AUGGACUN\"; Greedy mode (default) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 4 7 ACGA seq ACGA ACGA + 7 10 ACGA Non-greedy mode ( -G ) $ echo -e '>seq\\nACGACGACGA' | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA Circular genome. Note that end position of matched subsequence that crossing genome sequence end would be greater than sequence length. $ echo -e \">seq\\nACGTTGCA\" >seq ACGTTGCA $ echo -e \">seq\\nACGTTGCA\" \\ | seqkit locate -i -p aa seqID patternName pattern strand start end matched seq aa aa - 4 5 aa $ echo -e \">seq\\nACGTTGCA\" \\ | seqkit locate -i -p aa -c \\ | csvtk pretty -t seqID patternName pattern strand start end matched seq aa aa + 8 9 aa seq aa aa - 4 5 aa","title":"locate"},{"location":"usage/#fish","text":"Usage look for short sequences in larger sequences using local alignment Attention: 1. output coordinates are BED-like 0-based, left-close and right-open. 2. alignment information are printed to STDERR. Usage: seqkit fish [flags] Flags: -a, --all search all -p, --aln-params string alignment parameters in format \"<match>,<mismatch>,<gap_open>,<gap_extend>\" (default \"4,-4,-2,-1\") -h, --help help for fish -i, --invert print out references not matching with any query -q, --min-qual float minimum mapping quality (default 5) -b, --out-bam string save aligmnets to this BAM file (memory intensive) -x, --pass pass through mode (write input to stdout) -g, --print-aln print sequence alignments -D, --print-desc print full sequence header -f, --query-fastx string query fasta -F, --query-sequences string query sequences -r, --ranges string target ranges, for example: \":10,30:40,-20:\" -s, --stranded search + strand only -v, --validate-seq validate bases according to the alphabet -V, --validate-seq-length int length of sequence to validate (0 for whole seq) (default 10000) Examples Find best local alignment of a short sequence in reads in a fasta file, print results as tabular $ seqkit fish -q 4.7 -F GGCGGCTGTGACC -g mouse-p53-cds.fna Compare to seqkit locate : $ echo -e '>seq\\nACGACGACGA' \\ | seqkit locate -p ACGA -G | csvtk -t pretty seqID patternName pattern strand start end matched seq ACGA ACGA + 1 4 ACGA seq ACGA ACGA + 7 10 ACGA $ echo -e '>seq\\nACGACGACGA' \\ | seqkit fish -F ACGA -a 2>&1 | csvtk -t pretty Ref RefStart RefEnd Query QueryStart QueryEnd Strand MapQual RawScore Acc ClipAcc QueryCov seq 6 10 q0 0 4 + 60.00 16 100.00 100.00 100.00 seq 0 4 q0 0 4 + 60.00 16 100.00 100.00 100.00 Find all local alignment of a short sequences in reads in a fasta file, print results as tabular and save as BAM seqkit fish -a -q 4.67 -f query.fas -b alignments.bam -g mouse-p53-cds.fna","title":"fish"},{"location":"usage/#amplicon","text":"Usage extract amplicon (or specific region around it) via primer(s). Attentions: 1. Only one (the longest) matching location is returned for every primer pair. 2. Mismatch is allowed, but the mismatch location (5' or 3') is not controled. You can increase the value of \"-j/--threads\" to accelerate processing. 3. Degenerate bases/residues like \"RYMM..\" are also supported. But do not use degenerate bases/residues in regular expression, you need convert them to regular expression, e.g., change \"N\" or \"X\" to \".\". Examples: 0. no region given. F -----===============----- F R -----=====-----=====----- =============== amplicon 1. inner region (-r x:y). F -----===============----- 1 3 5 x/y -5-3-1 x/y F R -----=====-----=====----- x:y =============== 1:-1 ======= 1:7 ===== 3:7 ===== 6:10 ===== -10:-6 ===== -7:-3 -x:y (invalid) 2. flanking region (-r x:y -f) F -----===============----- -3-1 x/y 1 3 5 x/y F R -----=====-----=====----- ===== -5:-1 === -5:-3 ===== 1:5 === 3:5 ================= -1:1 ========================= -5:5 x:-y (invalid) Usage: seqkit amplicon [flags] Flags: --bed output in BED6+1 format with amplicon as the 7th column -f, --flanking-region region is flanking region -F, --forward string forward primer (5'-primer-3'), degenerate bases allowed -h, --help help for amplicon -I, --immediate-output print output immediately, do not use write buffer -m, --max-mismatch int max mismatch when matching primers, no degenerate bases allowed -P, --only-positive-strand only search on positive strand -M, --output-mismatches append the total mismatches and mismatches of 5' end and 3' end -p, --primer-file string 3- or 2-column tabular primer file, with first column as primer name -r, --region string specify region to return. type \"seqkit amplicon -h\" for detail -R, --reverse string reverse primer (5'-primer-3'), degenerate bases allowed -u, --save-unmatched also save records that do not match any primer -s, --strict-mode strict mode, i.e., discarding seqs not fully matching (shorter) given region range Examples No region given. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" >seq acgcccactgaaatga $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt >seq cccactgaaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt # BED6+1 $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt --bed seq 3 13 . 0 + cccactgaaa # supporting degenerate bases. $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccR -R ttt --bed seq 4 13 . 0 + ccactgaaa Output mismatches: $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -M >seq mismatches=0(0+0) cccactgaaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -m 1 -M >seq mismatches=2(1+1) cgcccactgaaat $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -m 1 -M --bed seq 1 14 . 0 + cgcccactgaaat 2 1 1 Load primers from 3- or 2-column tabular primer file, with first column as primer name. $ cat seqs4amplicon.fa >seq1 ACGCCCACTGAAATGA >seq2 ACGTACGGTCAGATCCA $ cat primers.tsv p1 ccc ttt p2 ttt ccc p3 ttt p4 CG TG P5 CG GA # containing degenerate bases p6 TRC WGG $ cat seqs4amplicon.fa | seqkit amplicon -p primers.tsv --bed seq1 3 13 p1 0 + CCCACTGAAA seq1 1 7 p4 0 + CGCCCA seq1 3 13 p2 0 - TTTCAGTGGG seq1 10 13 p3 0 - TTT seq2 1 17 p4 0 + CGTACGGTCAGATCCA seq2 1 15 P5 0 + CGTACGGTCAGATC seq2 3 17 p6 0 + TACGGTCAGATCCA Inner region # region right behind forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 >seq actg # BED $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:7 --bed seq 6 10 . 0 + actg # more common case is triming primers $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -R ttt -r 4:-4 >seq actg flanking region # in one of my sequencing data, I only care about # region downstream of forward primer $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 >seq tgaa $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F ccc -f -r 3:6 --bed seq 8 12 . 0 + tgaa # if given region if out scope of sequence. e.g, # 2-5bp downstream of aaa, we can get part of region (2-4) by default $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 >seq ga # you can also use strict mode to discard those cases $ echo -ne \">seq\\nacgcccactgaaatga\\n\" \\ | seqkit amplicon -F aaa -f -r 2:5 -s","title":"amplicon"},{"location":"usage/#duplicate","text":"Usage duplicate sequences N times You may need \"seqkit rename\" to make the the sequence IDs unique. Usage: seqkit duplicate [flags] Aliases: duplicate, dup Flags: -h, --help help for duplicate -n, --times int duplication number (default 1) Examples Data $ cat tests/hairpin.fa | seqkit head -n 1 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA Duplicate 2 times $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA use seqkit rename to make the the sequence IDs unique. $ cat tests/hairpin.fa | seqkit head -n 1 \\ | seqkit duplicate -n 2 | seqkit rename >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA >cel-let-7_2 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA","title":"duplicate"},{"location":"usage/#rmdup","text":"Usage remove duplicated sequences by ID/name/sequence Attentions: 1. When comparing by sequences, both positive and negative strands are compared. Switch on -P/--only-positive-strand for considering the positive strand only. 2. Only the first record is saved for duplicates. Usage: seqkit rmdup [flags] Flags: -n, --by-name by full name instead of just id -s, --by-seq by seq -D, --dup-num-file string file to save number and list of duplicated seqs -d, --dup-seqs-file string file to save duplicated seqs -h, --help help for rmdup -i, --ignore-case ignore case -P, --only-positive-strand only considering positive strand when comparing by sequence Examples Similar to common . General use $ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 2226 duplicated records removed $ zcat reads_1.fq.gz | seqkit rmdup -s -o clean.fa.gz [INFO] 1086 duplicated records removed Save duplicated sequences to file $ zcat hairpin.fa.gz \\ | seqkit rmdup -s -i -o clean.fa.gz -d duplicated.fa.gz -D duplicated.detail.txt $ cat duplicated.detail.txt # here is not the entire list 3 hsa-mir-424, mml-mir-424, ppy-mir-424 3 hsa-mir-342, mml-mir-342, ppy-mir-342 2 ngi-mir-932, nlo-mir-932 2 ssc-mir-9784-1, ssc-mir-9784-2","title":"rmdup"},{"location":"usage/#common","text":"Usage find common sequences of multiple files by id/name/sequence Note: 1. 'seqkit common' is designed to support 2 and MORE files. 2. When comparing by sequences, both positive and negative strands are compared. Switch on -P/--only-positive-strand for considering the positive strand only. 3. For 2 files, 'seqkit grep' is much faster and consumes lesser memory: seqkit grep -f <(seqkit seq -n -i small.fq.gz) big.fq.gz # by seq ID seqkit grep -s -f <(seqkit seq -s small.fq.gz) big.fq.gz # by seq 4. Some records in one file may have same sequences/IDs. They will ALL be retrieved if the sequence/ID was shared in multiple files. So the records number may be larger than that of the smallest file. Usage: seqkit common [flags] Flags: -n, --by-name match by full name instead of just id -s, --by-seq match by sequence -h, --help help for common -i, --ignore-case ignore case -P, --only-positive-strand only considering positive strand when comparing by sequence Examples By ID (default) seqkit common file*.fa -o common.fasta By full name seqkit common file*.fa -n -o common.fasta By sequence seqkit common file*.fa -s -i -o common.fasta","title":"common"},{"location":"usage/#split","text":"Usage split sequences into files by name ID, subsequence of given region, part size or number of parts. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. If you just want to split by parts or sizes, please use \"seqkit split2\", which also applies for paired- and single-end FASTQ. The definition of region is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit split [flags] Flags: -i, --by-id split squences according to sequence ID --by-id-prefix string file prefix for --by-id -p, --by-part int split sequences into N parts --by-part-prefix string file prefix for --by-part -r, --by-region string split squences according to subsequence of given region. e.g 1:12 for first 12 bases, -12:-1 for last 12 bases. type \"seqkit split -h\" for more examples --by-region-prefix string file prefix for --by-region -s, --by-size int split sequences into multi parts with N sequences --by-size-prefix string file prefix for --by-size -d, --dry-run dry run, just print message and no files will be created. -e, --extension string set output file extension, e.g., \".gz\", \".xz\", or \".zst\" -f, --force overwrite output directory -h, --help help for split -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -O, --out-dir string output directory (default value is $infile.split) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples Split sequences into parts with at most 10000 sequences $ seqkit split hairpin.fa.gz -s 10000 [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.part_001.gz [INFO] write 10000 sequences to file: hairpin.fa.part_002.gz [INFO] write 8645 sequences to file: hairpin.fa.part_003.gz Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.part_001.gz [INFO] write 7162 sequences to file: hairpin.fa.part_002.gz [INFO] write 7162 sequences to file: hairpin.fa.part_003.gz [INFO] write 7159 sequences to file: hairpin.fa.part_004.gz To reduce memory usage when spliting big file, we should alwasy use flag --two-pass $ seqkit split hairpin.fa.gz -p 4 -2 [INFO] split into 4 parts [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 7162 sequences to file: hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.part_004.fa.gz Split sequences by species. i.e. by custom IDs (first three letters) $ seqkit split hairpin.fa.gz -i --id-regexp \"^([\\w]+)\\-\" -2 [INFO] split by ID. idRegexp: ^([\\w]+)\\- [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 48 sequences to file: hairpin.id_cca.fa.gz [INFO] write 3 sequences to file: hairpin.id_hci.fa.gz [INFO] write 106 sequences to file: hairpin.id_str.fa.gz [INFO] write 1 sequences to file: hairpin.id_bkv.fa.gz ... Split sequences by sequence region (for example, sequence barcode) $ seqkit split hairpin.fa.gz -r 1:3 -2 [INFO] split by region: 1:3 [INFO] read and write sequences to temporary file: hairpin.fa.gz.fastx ... [INFO] 28645 sequences saved [INFO] read sequence IDs and sequence region from FASTA file ... [INFO] create or read FASTA index ... [INFO] create FASTA index for hairpin.fa.gz.fastx [INFO] 28645 records loaded from hairpin.fa.gz.fastx.seqkit.fai [INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz [INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz [INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz Sequence suffix could be defined as -r -12:-1","title":"split"},{"location":"usage/#split2","text":"Usage split sequences into files by part size or number of parts This command supports FASTA and paired- or single-end FASTQ with low memory occupation and fast speed. The prefix of output files: 1. For stdin: stdin 2. Others: same to the input file 3. Set via the option: -o/--out-file, e.g., outputting xxx.part_001.fasta: cat ../tests/hairpin.fa | ./seqkit split2 -p 2 -O test -o xxx The extension of output files: 1. For stdin: .fast[aq] 2. Others: same to the input file 3. Additional extension via the option -e/--extension, e.g.\uff0c outputting gzipped files for plain text input: seqkit split2 -p 2 -O test tests/hairpin.fa -e .gz Usage: seqkit split2 [flags] Flags: -l, --by-length string split sequences into chunks of >=N bases, supports K/M/G suffix --by-length-prefix string file prefix for --by-length -p, --by-part int split sequences into N parts --by-part-prefix string file prefix for --by-part -s, --by-size int split sequences into multi parts with N sequences --by-size-prefix string file prefix for --by-size -e, --extension string set output file extension, e.g., \".gz\", \".xz\", or \".zst\" -f, --force overwrite output directory -h, --help help for split2 -O, --out-dir string output directory (default value is $infile.split) -1, --read1 string (gzipped) read1 file -2, --read2 string (gzipped) read2 file Examples Split sequences into parts with at most 10000 sequences: $ seqkit split2 hairpin.fa -s 10000 [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_001.fa [INFO] write 10000 sequences to file: hairpin.fa.split/hairpin.part_002.fa [INFO] write 8645 sequences to file: hairpin.fa.split/hairpin.part_003.fa Force compression for plain text input by adding an extra extension: # gzip $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.gz [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.gz [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.gz # xz $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .xz [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.xz [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.xz [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.xz # zstd $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .zst [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/hairpin.part_001.fa.zst [INFO] write 10000 sequences to file: test/hairpin.part_002.fa.zst [INFO] write 8645 sequences to file: test/hairpin.part_003.fa.zst Change the prefix of output files: $ seqkit split2 hairpin.fa -O test -f -s 10000 -e .gz -o xxx [INFO] split seqs from hairpin.fa [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/xxx.part_001.fa.gz [INFO] write 10000 sequences to file: test/xxx.part_002.fa.gz [INFO] write 8645 sequences to file: test/xxx.part_003.fa.gz # here, we also change the compression format from xz to zstd $ cat hairpin.fa.xz | seqkit split2 -O test -f -s 10000 -e .zst [INFO] split seqs from stdin [INFO] split into 10000 seqs per file [INFO] write 10000 sequences to file: test/stdin.part_001.fasta.zst [INFO] write 10000 sequences to file: test/stdin.part_002.fasta.zst [INFO] write 8645 sequences to file: test/stdin.part_003.fasta.zst Split sequences into 4 parts $ seqkit split hairpin.fa.gz -p 4 -f [INFO] split into 4 parts [INFO] read sequences ... [INFO] read 28645 sequences [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_001.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_002.fa.gz [INFO] write 7162 sequences to file: hairpin.fa.gz.split/hairpin.part_003.fa.gz [INFO] write 7159 sequences to file: hairpin.fa.gz.split/hairpin.part_004.fa.gz For FASTQ files (paired-end) $ seqkit split2 -1 reads_1.fq.gz -2 reads_2.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz and reads_2.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_2.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_2.part_002.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz For FASTA files (single-end) $ seqkit split2 -1 reads_1.fq.gz reads_2.fq.gz -p 2 -O out -f [INFO] flag -1/--read1 given, ignore: reads_2.fq.gz [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz $ seqkit split2 reads_1.fq.gz -p 2 -O out -f [INFO] split seqs from reads_1.fq.gz [INFO] split into 2 parts [INFO] write 1250 sequences to file: out/reads_1.part_001.fq.gz [INFO] write 1250 sequences to file: out/reads_1.part_002.fq.gz","title":"split2"},{"location":"usage/#pair","text":"Usage match up paired-end reads from two fastq files Attentions: 1. Orders of headers in the two files better be the same (not shuffled), otherwise, it consumes a huge number of memory for buffering reads in memory. 2. Unpaired reads are optional outputted with the flag -u/--save-unpaired. 3. If the flag -O/--out-dir is not given, the output will be saved in the same directory of input, with the suffix \"paired\", e.g., read_1.paired.fq.gz. Otherwise, names are kept untouched in the given output directory. 4. Paired gzipped files may be slightly larger than original files, because of using a different gzip package/library, don't worry. Tips: 1. Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI. You can simply specify the regular expression for extracting sequence IDs: --id-regexp '^(\\S+)\\/[12]' Usage: seqkit pair [flags] Flags: -f, --force overwrite output directory -h, --help help for pair -O, --out-dir string output directory -1, --read1 string (gzipped) read1 file -2, --read2 string (gzipped) read2 file -u, --save-unpaired save unpaired reads if there are Examples Simple one $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz # output reads_1.paired.fq.gz reads_2.paired.fq.gz Set output directory, file names are kept untouched. $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result $ tree result result/ \u251c\u2500\u2500 reads_1.fq.gz \u2514\u2500\u2500 reads_2.fq.gz Save unpaired reads if there are. $ seqkit pair -1 reads_1.fq.gz -2 reads_2.fq.gz -O result -u $ tree result result \u251c\u2500\u2500 reads_1.fq.gz \u251c\u2500\u2500 reads_1.unpaired.fq.gz \u251c\u2500\u2500 reads_2.fq.gz \u2514\u2500\u2500 reads_2.unpaired.fq.gz Support for '/1 'and '/2' tags for paired read files generated by platforms like MGI. You can simply specify the regular expression for extracting sequence IDs: seqkit pair --id-regexp '^(\\S+)\\/[12]' -1 reads_1.fq.gz -2 reads_2.fq.gz","title":"pair"},{"location":"usage/#sample","text":"Usage sample sequences by number or proportion. Attention: 1. Do not use '-n' on large FASTQ files, it loads all seqs into memory! use 'seqkit sample -p 0.1 seqs.fq.gz | seqkit head -n N' instead! Usage: seqkit sample [flags] Flags: -h, --help help for sample -n, --number int sample by number (result may not exactly match), DO NOT use on large FASTQ files. -p, --proportion float sample by proportion -s, --rand-seed int rand seed (default 11) -2, --two-pass 2-pass mode read files twice to lower memory usage. Not allowed when reading from stdin Examples Sample by proportion $ zcat hairpin.fa.gz | seqkit sample -p 0.1 -o sample.fa.gz [INFO] sample by proportion [INFO] 2814 sequences outputed Sample by number $ zcat hairpin.fa.gz | seqkit sample -n 1000 -o sample.fa.gz [INFO] sample by number [INFO] 949 sequences outputed 949 != 1000 ??? see Effect of random seed on results of seqkit sample To reduce memory usage when spliting big file, we could use flag --two-pass We can also use seqkit sample -p followed with seqkit head -n : $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit head -n 1000 -o sample.fa.gz Set rand seed to reproduce the result $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 -s 11 Most of the time, we could shuffle after sampling $ zcat hairpin.fa.gz \\ | seqkit sample -p 0.1 \\ | seqkit shuffle -o sample.fa.gz Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed )","title":"sample"},{"location":"usage/#head","text":"Usage print first N FASTA/Q records For returning the last N records, use: seqkit range -N:-1 seqs.fasta Usage: seqkit head [flags] Flags: -n, --number int print first N FASTA/Q records (default 10) Examples FASTA $ seqkit head -n 1 hairpin.fa.gz >cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA FASTQ $ seqkit head -n 1 reads_1.fq.gz @HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGGTTGTAA + HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIIIIIIIII","title":"head"},{"location":"usage/#head-genome","text":"Usage print sequences of the first genome with common prefixes in name For a FASTA file containing multiple contigs of strains (see example below), these's no list of IDs available for retrieving sequences of a certain strain, while descriptions of each strain share the same prefix. This command is used to restrieve sequences of the first strain, i.e., \"Vibrio cholerae strain M29\". >NZ_JFGR01000001.1 Vibrio cholerae strain M29 Contig_1, whole genome shotgun sequence >NZ_JFGR01000002.1 Vibrio cholerae strain M29 Contig_2, whole genome shotgun sequence >NZ_JFGR01000003.1 Vibrio cholerae strain M29 Contig_3, whole genome shotgun sequence >NZ_JSTP01000001.1 Vibrio cholerae strain 2012HC-12 NODE_79, whole genome shotgun sequence >NZ_JSTP01000002.1 Vibrio cholerae strain 2012HC-12 NODE_78, whole genome shotgun sequence Attention: 1. Sequences in file should be well organized. Usage: seqkit head-genome [flags] Flags: -h, --help help for head-genome -m, --mini-common-words int minimal shared prefix words (default 4)","title":"head-genome"},{"location":"usage/#range","text":"Usage print FASTA/Q records in a range (start:end) Examples: 1. leading 100 records (head -n 100) seqkit range -r 1:100 2. last 100 records (tail -n 100) seqkit range -r -100:-1 3. remove leading 100 records (tail -n +101) seqkit range -r 101:-1 4. other ranges: seqkit range -r 10:100 seqkit range -r -100:-10 Usage: seqkit range [flags] Flags: -h, --help help for range -r, --range string range. e.g., 1:12 for first 12 records (head -n 12), -12:-1 for last 12 records (tail -n 12) Examples leading N records (head) $ cat tests/hairpin.fa | seqkit head -n 100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - $ cat tests/hairpin.fa | seqkit range -r 1:100 | md5sum f65116af7d9298d93ba4b3d19077bbf1 - last N records (tail) $ cat tests/hairpin.fa | seqkit range -r -100:-1 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 100 8,656 58 86.6 172 remove leading 100 records (tail -n +101) $ seqkit range -r 101:-1 tests/hairpin.fa | seqkit sum -a seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db - 28545 2940929 $ seqkit fx2tab tests/hairpin.fa | tail -n +101 | seqkit tab2fx | seqkit sum -a seqkit.v0.1_RLS_k0_e1feced9bb0be653afa8205dec4987db - 28545 2940929 Other ranges $ cat tests/hairpin.fa | seqkit range -r 101:150 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 50 3,777 63 75.5 96 $ cat tests/hairpin.fa | seqkit range -r -100:-2 | seqkit stats file format type num_seqs sum_len min_len avg_len max_len - FASTA RNA 99 8,484 58 85.7 146","title":"range"},{"location":"usage/#replace","text":"Usage replace name/sequence by regular expression. Note that the replacement supports capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: use SINGLE quote NOT double quotes in *nix OS. Examples: Adding space to all bases. seqkit replace -p \"(.)\" -r '$1 ' -s Or use the \\ escape character. seqkit replace -p \"(.)\" -r \"\\$1 \" -s more on: http://bioinf.shenwei.me/seqkit/usage/#replace Special replacement symbols (only for replacing name not sequence): {nr} Record number, starting from 1 {kv} Corresponding value of the key (captured variable $n) by key-value file, n can be specified by flag -I (--key-capt-idx) (default: 1) Special cases: 1. If replacements contain '$', a). If using '{kv}', you need use '$$$$' instead of a single '$': -r '{kv}' -k <(sed 's/\\$/$$$$/' kv.txt) b). If not, use '$$': -r 'xxx$$xx' Filtering records to edit: You can use flags similar to those in \"seqkit grep\" to choose partly records to edit. Usage: seqkit replace [flags] Flags: -s, --by-seq replace seq (only FASTA) --f-by-name [target filter] match by full name instead of just ID --f-by-seq [target filter] search subseq on seq, both positive and negative strand are searched, and mismatch allowed using flag -m/--max-mismatch --f-ignore-case [target filter] ignore case --f-invert-match [target filter] invert the sense of matching, to select non-matching records --f-only-positive-strand [target filter] only search on positive strand --f-pattern strings [target filter] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"') --f-pattern-file string [target filter] pattern file (one record per line) --f-use-regexp [target filter] patterns are regular expression -h, --help help for replace -i, --ignore-case ignore case -K, --keep-key keep the key as value when no value found for the key (only for sequence name) -U, --keep-untouch do not change anything when no value found for the key (only for sequence name) -I, --key-capt-idx int capture variable index of key (1-based) (default 1) -m, --key-miss-repl string replacement for key with no corresponding value -k, --kv-file string tab-delimited key-value file for replacing key with value when using \"{kv}\" in -r (--replacement) (only for sequence name) --nr-width int minimum width for {nr} in flag -r/--replacement. e.g., formatting \"1\" to \"001\" by --nr-width 3 (default 1) -p, --pattern string search regular expression -r, --replacement string replacement. supporting capture variables. e.g. $1 represents the text of the first submatch. ATTENTION: for *nix OS, use SINGLE quote NOT double quotes or use the \\ escape character. Record number is also supported by \"{nr}\".use ${1} instead of $1 when {kv} given! Examples Prepend or append to the header $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT # prefix $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p ^ -r _prefix_ >_prefix_seq1 abc-123 ACGT-ACGT # suffix $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p $ -r _suffix_ >seq1 abc-123_suffix_ ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit seq -i \\ | seqkit replace -p $ -r _suffix_ >seq1_suffix_ ACGT-ACGT Remove descriptions $ echo -e \">seq1 abc-123\\nACGT-ACGT\" >seq1 abc-123 ACGT-ACGT $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\s.+\" >seq1 ACGT-ACGT Replace \"-\" with \"=\" $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"\\-\" -r '=' >seq1 abc=123 ACGT-ACGT Remove gaps in sequences. $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \" |-\" -s >seq1 abc-123 ACGTACGT Add space to every base. ATTENTION: use SINGLE quote NOT double quotes in *nix OS $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r '$1 ' -s >seq1 abc-123 A C G T - A C G T $ echo -e \">seq1 abc-123\\nACGT-ACGT\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s >seq1 abc-123 A C G T - A C G T Transpose sequence with csvtk $ echo -e \">seq1\\nACTGACGT\\n>seq2\\nactgccgt\" \\ | seqkit replace -p \"(.)\" -r \"\\$1 \" -s \\ | seqkit seq -s -u \\ | csvtk space2tab \\ | csvtk -t transpose A A C C T T G G A C C C G G T T Rename with number of record $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" >seq_1 ACTG >seq_2 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p .+ -r \"seq_{nr}\" --nr-width 5 >seq_00001 ACTG >seq_00002 ATTT Replace key with value by key-value file $ more test.fa >seq1 name1 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 name3 CCCCAAAACCCCATGTTGCTACTAG $ more alias.txt name0 ABC name1 123 name3 Hello name4 World $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG $ seqkit replace -p ' (.+)$' -r ' {kv}' -k alias.txt test.fa --keep-key [INFO] read key-value file: alias.txt [INFO] 4 pairs of key-value loaded >seq1 123 CCCCAAAACCCCATGATCATGGATC >seq2 name2 CCCCAAAACCCCATGGCATCATTCA >seq3 Hello CCCCAAAACCCCATGTTGCTACTAG If the target to replace is the sequence ID, meanwhile you would like to keep the description. Please use this: # ^(\\S+) # ID # (.+)$ # description seqkit replace -p '^(\\S+)(.+?)$' -r '{kv}$2' -k alias.txt test.fa convert fasta to genbank style $ cat seq.fa >seq1 TTTAAAGAGACCGGCGATTCTAGTGAAATCGAACGGGCAGGTCAATTTCCAACCAGCGAT GACGTAATAGATAGATACAAGGAAGTCATTTTTCTTTTAAAGGATAGAAACGGTTAATGC TCTTGGGACGGCGCTTTTCTGTGCATAACT >seq2 AAGGATAGAAACGGTTAATGCTCTTGGGACGGCGCTTTTCTGTGCATAACTCGATGAAGC CCAGCAATTGCGTGTTTCTCCGGCAGGCAAAAGGTTGTCGAGAACCGGTGTCGAGGCTGT TTCCTTCCTGAGCGAAGCCTGGGGATGAACG $ cat seq.fa \\ | seqkit replace -s -p '(\\w{10})' -r '$1 ' -w 66 \\ | perl -ne 'if (/^>/) {print; $n=1} else {s/ \\r?\\n$/\\n/; printf \"%9d %s\", $n, $_; $n+=60;}' >seq1 1 TTTAAAGAGA CCGGCGATTC TAGTGAAATC GAACGGGCAG GTCAATTTCC AACCAGCGAT 61 GACGTAATAG ATAGATACAA GGAAGTCATT TTTCTTTTAA AGGATAGAAA CGGTTAATGC 121 TCTTGGGACG GCGCTTTTCT GTGCATAACT >seq2 1 AAGGATAGAA ACGGTTAATG CTCTTGGGAC GGCGCTTTTC TGTGCATAAC TCGATGAAGC 61 CCAGCAATTG CGTGTTTCTC CGGCAGGCAA AAGGTTGTCG AGAACCGGTG TCGAGGCTGT 121 TTCCTTCCTG AGCGAAGCCT GGGGATGAAC G only edit some of the records via patterns. Eight flags starting with --f- (with the same usage to these in seqkit grep ) can be used to filter records to edit. # prepend some text to header $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ >_abc ACTG >_123 ATTT # only edit some records $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ --f-use-regexp --f-pattern abc [INFO] 1 records matched by the filter >_abc ACTG >123 ATTT $ echo -e \">abc\\nACTG\\n>123\\nATTT\" \\ | seqkit replace -p ^ -r _ --f-use-regexp --f-invert-match --f-pattern abc [INFO] 1 records matched by the filter >abc ACTG >_123 ATTT","title":"replace"},{"location":"usage/#rename","text":"Usage rename duplicated IDs Attention: 1. This command only appends \"_N\" to duplicated sequence IDs to make them unique. 2. Use \"seqkit replace\" for editing sequence IDs/headers using regular expression. Example: $ seqkit seq seqs.fasta >id comment actg >id description ACTG $ seqkit rename seqs.fasta >id comment actg >id_2 description ACTG Usage: seqkit rename [flags] Flags: -n, --by-name check duplication by full name instead of just id -f, --force overwrite output directory -h, --help help for rename -m, --multiple-outfiles write results into separated files for multiple input files -O, --out-dir string output directory (default \"renamed\") -1, --rename-1st-rec rename the first record as well -s, --separator string separator between original ID/name and the counter (default \"_\") -N, --start-num int starting count number for *duplicated* IDs/names, should be greater than zero (default 2 Examples $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" >a comment acgt >b comment of b ACTG >a comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename >a comment acgt >b comment of b ACTG >a_2 comment aaaa $ echo -e \">a comment\\nacgt\\n>b comment of b\\nACTG\\n>a comment\\naaaa\" \\ | seqkit rename -s '|' -N 2 -1 >a|1 comment acgt >b|1 comment of b ACTG >a|2 comment aaaa","title":"rename"},{"location":"usage/#restart","text":"Usage reset start position for circular genome Examples $ echo -e \">seq\\nacgtnACGTN\" >seq acgtnACGTN $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i 2 >seq cgtnACGTNa $ echo -e \">seq\\nacgtnACGTN\" | seqkit restart -i -2 >seq TNacgtnACG Usage: seqkit restart [flags] Flags: -i, --new-start int new start position (1-base, supporting negative value counting from the end) (default 1)","title":"restart"},{"location":"usage/#concat","text":"Usage concatenate sequences with same ID from multiple files Attentions: 1. By default, only sequences with IDs that appear in all files are outputted. use -f/--full to output all sequences. 2. If there are more than one sequences of the same ID, we output the Cartesian product of sequences. 3. Description are also concatenated with a separator (-s/--separator). 4. Order of sequences with different IDs are random. Usage: seqkit concat [flags] Aliases: concat, concate Flags: -f, --full keep all sequences, like full/outer join -h, --help help for concat -s, --separator string separator for descriptions of records with the same ID (default \"|\") Examples $ cat a.fa >A 1 a1- >A 2 a2- >B 1 b1- $ cat b.fa >A x ax- >C 1 c1- $ seqkit concat a.fa b.fa >A 1|x a1-ax- >A 2|x a2-ax- $ seqkit concat a.fa b.fa --full >C 1 c1- >A 1|x a1-ax- >A 2|x a2-ax- >B 1 b1-","title":"concat"},{"location":"usage/#mutate","text":"Usage edit sequence (point mutation, insertion, deletion) Attentions: 1. Mutiple point mutations (-p/--point) are allowed, but only single insertion (-i/--insertion) OR single deletion (-d/--deletion) is allowed. 2. Point mutation takes place before insertion/deletion. Notes: 1. You can choose certain sequences to edit using similar flags in 'seqkit grep'. The definition of position is 1-based and with some custom design. Examples: 1-based index 1 2 3 4 5 6 7 8 9 10 negative index 0-9-8-7-6-5-4-3-2-1 seq A C G T N a c g t n 1:1 A 2:4 C G T -4:-2 c g t -4:-1 c g t n -1:-1 n 2:-2 C G T N a c g t 1:-1 A C G T N a c g t n 1:12 A C G T N a c g t n -12:-1 A C G T N a c g t n Usage: seqkit mutate [flags] Flags: -n, --by-name [match seqs to mutate] match by full name instead of just id -d, --deletion string deletion mutation: deleting subsequence in a range. e.g., -d 1:2 for deleting leading two bases, -d -3:-1 for removing last 3 bases -h, --help help for mutate -I, --ignore-case [match seqs to mutate] ignore case of search pattern -i, --insertion string insertion mutation: inserting bases behind of given position, e.g., -i 0:ACGT for inserting ACGT at the beginning, -1:* for add * to the end -v, --invert-match [match seqs to mutate] invert the sense of matching, to select non-matching records -s, --pattern strings [match seqs to mutate] search pattern (multiple values supported. Attention: use double quotation marks for patterns containing comma, e.g., -p '\"A{2,}\"')) -f, --pattern-file string [match seqs to mutate] pattern file (one record per line) -p, --point strings point mutation: changing base at given position. e.g., -p 2:C for setting 2nd base as C, -p -1:A for change last base as A -r, --use-regexp [match seqs to mutate] search patterns are regular expression Examples: Point mutation: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" >1 ACTGNactgn >2 actgnACTGN # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x [INFO] edit seq: 1 [INFO] edit seq: 2 >1 xCTGNactgn >2 xctgnACTGN # 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 5:x --quiet >1 ACTGxactgn >2 actgxACTGN # last base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p -1:x --quiet >1 ACTGNactgx >2 actgnACTGx # mutiple locations: $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -p 1:x -p -1:x --quiet >1 xCTGNactgx >2 xctgnACTGx Deletion # first base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d 1:1 --quiet >1 CTGNactgn >2 ctgnACTGN # last 3 bases $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -d -3:-1 --quiet >1 ACTGNac >2 actgnAC Insertion: inserting bases behind of given position # at the beginning $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 0:xx --quiet >1 xxACTGNactgn >2 xxactgnACTGN # at the end $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i -1:xx --quiet >1 ACTGNactgnxx >2 actgnACTGNxx # behind of 5th base $ echo -ne \">1\\nACTGNactgn\\n>2\\nactgnACTGN\\n\" \\ | seqkit mutate -i 5:x --quiet >1 ACTGNxactgn >2 actgnxACTGN Choosing which sequences to edit , using similar flags in seqkit grep . $ cat tests/hsa.fa >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # only edit chr1 and chr2 # or cat tests/hsa.fa | seqkit mutate -p -1:X -s chr1 -s chr2 $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1,chr2 [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGN >MT mitochondrial seq actgnactgn # using regular expression to match. # e,g., editing all chrosomes: $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -r -s chr [INFO] edit seq: chr1 1th seq [INFO] edit seq: chr2 2nd seq [INFO] edit seq: chr11 11th seq >chr1 1th seq ACTGNactgX >chr2 2nd seq actgnACTGX >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgn # excluding seqs $ cat tests/hsa.fa \\ | seqkit mutate -p -1:X -s chr1 -s chr2 -v [INFO] edit seq: chr11 11th seq [INFO] edit seq: MT mitochondrial seq >chr1 1th seq ACTGNactgn >chr2 2nd seq actgnACTGN >chr11 11th seq ACTGNACTGX >MT mitochondrial seq actgnactgX","title":"mutate"},{"location":"usage/#shuffle","text":"Usage shuffle sequences. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence IDs. If the file is not plain FASTA file, seqkit will write the sequences to temporary files, and create FASTA index. Secondly, seqkit shuffles sequence IDs and extract sequences by FASTA index. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. Usage: seqkit shuffle [flags] Flags: -h, --help help for shuffle -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -s, --rand-seed int rand seed for shuffle (default 23) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples General use. $ seqkit shuffle hairpin.fa.gz > shuffled.fa [INFO] read sequences ... [INFO] 28645 sequences loaded [INFO] shuffle ... [INFO] output ... For big genome, you'd better use two-pass mode so seqkit could use FASTA index to reduce memory usage $ time seqkit shuffle -2 hsa.fa > shuffle.fa [INFO] create and read FASTA index ... [INFO] create FASTA index for hsa.fa [INFO] read sequence IDs from FASTA index ... [INFO] 194 sequences loaded [INFO] shuffle ... [INFO] output ... real 0m35.080s user 0m45.521s sys 0m3.411s Note that when sampling on FASTQ files, make sure using same random seed by flag -s ( --rand-seed ) for read 1 and 2 files.","title":"shuffle"},{"location":"usage/#sort","text":"Usage sort sequences by id/name/sequence/length. By default, all records will be readed into memory. For FASTA format, use flag -2 (--two-pass) to reduce memory usage. FASTQ not supported. Firstly, seqkit reads the sequence head and length information. If the file is not plain FASTA file, seqkit will write the sequences to temporary files, and create FASTA index. Secondly, seqkit sorts sequence by head and length information and extracts sequences by FASTA index. Attentions: 1. For the two-pass mode (-2/--two-pass), The flag -U/--update-faidx is recommended to ensure the .fai file matches the FASTA file. Usage: seqkit sort [flags] Flags: -b, --by-bases by non-gap bases -l, --by-length by sequence length -n, --by-name by full name instead of just id -s, --by-seq by sequence -G, --gap-letters string gap letters (default \"- \\t.\") -h, --help help for sort -i, --ignore-case ignore case -k, --keep-temp keep temporary FASTA and .fai file when using 2-pass mode -N, --natural-order sort in natural order, when sorting by IDs/full name -r, --reverse reverse the result -L, --seq-prefix-length int length of sequence prefix on which seqkit sorts by sequences (0 for whole sequence) (default 10000) -2, --two-pass two-pass mode read files twice to lower memory usage. (only for FASTA format) -U, --update-faidx update the fasta index file if it exists. Use this if you are not sure whether the fasta file changed Examples For FASTA format, use flag -2 (--two-pass) to reduce memory usage sort by ID $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by ID and in natural order $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit seq -n -i 3 1 Y x Mt 11 2 $ echo -e \">3\\na\\n>1\\na\\n>Y\\na\\n>x\\na\\n>Mt\\na\\n>11\\na\\n>2\\na\\n\" \\ | seqkit sort -N -i -2 \\ | seqkit seq -n -i 1 2 3 11 Mt x Y sort by ID, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -i >seq1 ACGTNcccc >SEQ2 acgtnAAAA sort by seq, ignoring case. $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAA\" \\ | seqkit sort --quiet -s -i >SEQ2 acgtnAAAA >seq1 ACGTNcccc sort by sequence length $ echo -e \">seq1\\nACGTNcccc\\n>SEQ2\\nacgtnAAAAnnn\\n>seq3\\nacgt\" \\ | seqkit sort --quiet -l >seq3 acgt >seq1 ACGTNcccc >SEQ2 acgtnAAAAnnn","title":"sort"},{"location":"usage/#bam","text":"monitoring and online histograms of BAM record features Usage: seqkit bam [flags] Flags: -B, --bins int number of histogram bins (default -1) -N, --bundle int partition BAM file into loci (-1) or bundles with this minimum size -c, --count string count reads per reference and save to this file -W, --delay int sleep this many seconds after plotting (default 1) -y, --dump print histogram data to stderr instead of plotting -G, --exclude-ids string exclude records with IDs contained in this file -e, --exec-after string execute command after reporting -E, --exec-before string execute command before reporting -f, --field string target fields -g, --grep-ids string only keep records with IDs contained in this file -h, --help help for bam -C, --idx-count fast read per reference counting based on the BAM index -i, --idx-stat fast statistics based on the BAM index -O, --img string save histogram to this PDF/image file -H, --list-fields list all available BAM record features -L, --log log10(x+1) transform numeric values -q, --map-qual int minimum mapping quality -x, --pass passthrough mode (forward filtered BAM to output) -k, --pretty pretty print certain TSV outputs -F, --prim-only filter out non-primary alignment records -p, --print-freq int print/report after this many records (-1 for print after EOF) (default -1) -Q, --quiet-mode supress all plotting to stderr -M, --range-max float discard record with field (-f) value greater than this flag (default NaN) -m, --range-min float discard record with field (-f) value less than this flag (default NaN) -R, --reset reset histogram after every report -Z, --silent-mode supress TSV output to stderr -s, --stat print BAM satistics of the input files -T, --tool string invoke toolbox in YAML format (see documentation) -@, --top-bam string save the top -? records to this bam file -?, --top-size int size of the top-mode buffer (default 100) Examples Get detailed statistics from multiple BAM files. seqkit bam -s *.bam Get rough statistics from multiple indexed BAM files. seqkit bam -i *.bam Count reads mapped to references from a BAM stream. cat sample.bam | seqkit bam -c counts.tsv - Count reads mapped to references using the BAM index. seqkit bam -C sorted_indexed.bam Monitor alignment accuracy from a bam stream and report after every 1000 records, use 20 bins. cat sample.bam | seqkit bam -B -f Acc -p 1000 - Dump selected fields to TSV. seqkit bam -f Ref,Acc,RefCov,Strand sample.bam Save the best 100 records in terms of alignment accuracy to a BAM file. seqkit bam -f Acc -@ top_acc_100.bam -? 100 -Q sample.bam Inkvoke the BAM toolbox. The BAM toolbox is a collection of filters acting on a stream of BAM records, configured via YAML. The currently available tools can be listed by seqkit bam -T help : Tool Description ---- ----------- AccStats calculates mean accuracy weighted by aligment lengths AlnContext filter records by the sequence context at start and end Dump dump various record properties in TSV format help list all tools with description Example YAML configs: Invoking the AccStats tool directly from the command line or YAML config: seqkit bam -T '{AccStats: {Tsv: \"-\"}, Sink: True}' input.bam seqkit bam -T '{Yaml: \"tests/examples/bam_tool_acc_stats.yml\"}' input.bam Where the contents of bam_tool_acc_stats.yml are: AccStats: Tsv: \"-\" Sink: True Invoking the AlnContext tool using YAML: AlnContext: Tsv: \"-\" Ref: \"../SIRV_150601a.fasta\" LeftShift: -10 RightShift: 10 RegexStart: \"T{4,}\" RegexEnd: \"A{4,}\" Stranded: True Invert: True Sink: True Invoking the Dump tool using YAML: Dump: Tsv: \"-\" Fields: [\"Read\", \"Ref\", \"Pos\", \"EndPos\", \"MapQual\", \"Acc\", \"Match\", \"Mismatch\", \"Ins\", \"Del\", \"AlnLen\", \" ReadLen\", \"RefLen\", \"RefAln\", \"RefCov\", \"ReadAln\", \"ReadCov\", \"Strand\", \"MeanQual\", \"LeftClip\", \"RightClip\", \"Flags\", \"IsSec\", \" IsSup\", \"ReadSeq\", \"ReadAlnSeq\", \"LeftSoftClipSeq\", \"RightSoftClip\", \"LeftHardClip\", \"RightHardClip\"] Sink: True The tools can be chained together, for example the YAML using all three tools look like: AlnContext: Tsv: \"context.tsv\" Ref: \"../SIRV_150601a.fasta\" LeftShift: -10 RightShift: 10 RegexStart: \"T{4,}\" RegexEnd: \"A{4,}\" Stranded: True Invert: True Dump: Tsv: \"dump.tsv\" Fields: [\"Read\", \"Ref\", \"Pos\", \"EndPos\", \"MapQual\", \"Acc\", \"Match\", \"Mismatch\", \"Ins\", \"Del\", \"AlnLen\", \" ReadLen\", \"RefLen\", \"RefAln\", \"RefCov\", \"ReadAln\", \"ReadCov\", \"Strand\", \"MeanQual\", \"LeftClip\", \"RightClip\", \"Flags\", \"IsSec\", \" IsSup\", \"ReadSeq\", \"ReadAlnSeq\", \"LeftSoftClipSeq\", \"RightSoftClip\", \"LeftHardClip\", \"RightHardClip\"] AccStats: Tsv: \"-\" If the \"Sink\" parameter is not specified in the last pipeline step, the output BAM records are streamed to the standard output and can be piped into standard tools, for example: seqkit bam -T '{Yaml: \"bam_tool_pipeline.yml\"}' ../pcs109_5k_spliced.bam | samtools flagstat -","title":"bam"},{"location":"usage/#genautocomplete","text":"Usage generate shell autocompletion script Supported shell: bash|zsh|fish|powershell Bash: # generate completion shell seqkit genautocomplete --shell bash # configure if never did. # install bash-completion if the \"complete\" command is not found. echo \"for bcfile in ~/.bash_completion.d/* ; do source \\$bcfile; done\" >> ~/.bash_completion echo \"source ~/.bash_completion\" >> ~/.bashrc Zsh: # generate completion shell seqkit genautocomplete --shell zsh --file ~/.zfunc/_seqkit # configure if never did echo 'fpath=( ~/.zfunc \"${fpath[@]}\" )' >> ~/.zshrc echo \"autoload -U compinit; compinit\" >> ~/.zshrc fish: seqkit genautocomplete --shell fish --file ~/.config/fish/completions/seqkit.fish Usage: seqkit genautocomplete [flags] Flags: --file string autocompletion file (default \"/home/shenwei/.bash_completion.d/seqkit.sh\") -h, --help help for genautocomplete --type string autocompletion type (currently only bash supported) (default \"bash\") /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = '//seqkit.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus.","title":"genautocomplete"},{"location":"yanlilab/","text":"","title":"Yanlilab"}]}